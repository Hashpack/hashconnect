var __assign = (this && this.__assign) || function () {
    __assign = Object.assign || function(t) {
        for (var s, i = 1, n = arguments.length; i < n; i++) {
            s = arguments[i];
            for (var p in s) if (Object.prototype.hasOwnProperty.call(s, p))
                t[p] = s[p];
        }
        return t;
    };
    return __assign.apply(this, arguments);
};
/* eslint-disable */
import Long from 'long';
import _m0 from 'protobufjs/minimal';
import { WakuMessage } from '../../waku/v2/message';
export var protobufPackage = 'waku.v2';
export var PagingInfo_Direction;
(function (PagingInfo_Direction) {
    PagingInfo_Direction[PagingInfo_Direction["DIRECTION_BACKWARD_UNSPECIFIED"] = 0] = "DIRECTION_BACKWARD_UNSPECIFIED";
    PagingInfo_Direction[PagingInfo_Direction["DIRECTION_FORWARD"] = 1] = "DIRECTION_FORWARD";
    PagingInfo_Direction[PagingInfo_Direction["UNRECOGNIZED"] = -1] = "UNRECOGNIZED";
})(PagingInfo_Direction || (PagingInfo_Direction = {}));
export function pagingInfo_DirectionFromJSON(object) {
    switch (object) {
        case 0:
        case 'DIRECTION_BACKWARD_UNSPECIFIED':
            return PagingInfo_Direction.DIRECTION_BACKWARD_UNSPECIFIED;
        case 1:
        case 'DIRECTION_FORWARD':
            return PagingInfo_Direction.DIRECTION_FORWARD;
        case -1:
        case 'UNRECOGNIZED':
        default:
            return PagingInfo_Direction.UNRECOGNIZED;
    }
}
export function pagingInfo_DirectionToJSON(object) {
    switch (object) {
        case PagingInfo_Direction.DIRECTION_BACKWARD_UNSPECIFIED:
            return 'DIRECTION_BACKWARD_UNSPECIFIED';
        case PagingInfo_Direction.DIRECTION_FORWARD:
            return 'DIRECTION_FORWARD';
        default:
            return 'UNKNOWN';
    }
}
export var HistoryResponse_Error;
(function (HistoryResponse_Error) {
    HistoryResponse_Error[HistoryResponse_Error["ERROR_NONE_UNSPECIFIED"] = 0] = "ERROR_NONE_UNSPECIFIED";
    HistoryResponse_Error[HistoryResponse_Error["ERROR_INVALID_CURSOR"] = 1] = "ERROR_INVALID_CURSOR";
    HistoryResponse_Error[HistoryResponse_Error["UNRECOGNIZED"] = -1] = "UNRECOGNIZED";
})(HistoryResponse_Error || (HistoryResponse_Error = {}));
export function historyResponse_ErrorFromJSON(object) {
    switch (object) {
        case 0:
        case 'ERROR_NONE_UNSPECIFIED':
            return HistoryResponse_Error.ERROR_NONE_UNSPECIFIED;
        case 1:
        case 'ERROR_INVALID_CURSOR':
            return HistoryResponse_Error.ERROR_INVALID_CURSOR;
        case -1:
        case 'UNRECOGNIZED':
        default:
            return HistoryResponse_Error.UNRECOGNIZED;
    }
}
export function historyResponse_ErrorToJSON(object) {
    switch (object) {
        case HistoryResponse_Error.ERROR_NONE_UNSPECIFIED:
            return 'ERROR_NONE_UNSPECIFIED';
        case HistoryResponse_Error.ERROR_INVALID_CURSOR:
            return 'ERROR_INVALID_CURSOR';
        default:
            return 'UNKNOWN';
    }
}
var baseIndex = { receivedTime: 0, senderTime: 0 };
export var Index = {
    encode: function (message, writer) {
        if (writer === void 0) { writer = _m0.Writer.create(); }
        if (message.digest.length !== 0) {
            writer.uint32(10).bytes(message.digest);
        }
        if (message.receivedTime !== 0) {
            writer.uint32(17).double(message.receivedTime);
        }
        if (message.senderTime !== 0) {
            writer.uint32(25).double(message.senderTime);
        }
        return writer;
    },
    decode: function (input, length) {
        var reader = input instanceof _m0.Reader ? input : new _m0.Reader(input);
        var end = length === undefined ? reader.len : reader.pos + length;
        var message = __assign({}, baseIndex);
        message.digest = new Uint8Array();
        while (reader.pos < end) {
            var tag = reader.uint32();
            switch (tag >>> 3) {
                case 1:
                    message.digest = reader.bytes();
                    break;
                case 2:
                    message.receivedTime = reader.double();
                    break;
                case 3:
                    message.senderTime = reader.double();
                    break;
                default:
                    reader.skipType(tag & 7);
                    break;
            }
        }
        return message;
    },
    fromJSON: function (object) {
        var message = __assign({}, baseIndex);
        message.digest = new Uint8Array();
        if (object.digest !== undefined && object.digest !== null) {
            message.digest = bytesFromBase64(object.digest);
        }
        if (object.receivedTime !== undefined && object.receivedTime !== null) {
            message.receivedTime = Number(object.receivedTime);
        }
        else {
            message.receivedTime = 0;
        }
        if (object.senderTime !== undefined && object.senderTime !== null) {
            message.senderTime = Number(object.senderTime);
        }
        else {
            message.senderTime = 0;
        }
        return message;
    },
    toJSON: function (message) {
        var obj = {};
        message.digest !== undefined &&
            (obj.digest = base64FromBytes(message.digest !== undefined ? message.digest : new Uint8Array()));
        message.receivedTime !== undefined &&
            (obj.receivedTime = message.receivedTime);
        message.senderTime !== undefined && (obj.senderTime = message.senderTime);
        return obj;
    },
    fromPartial: function (object) {
        var message = __assign({}, baseIndex);
        if (object.digest !== undefined && object.digest !== null) {
            message.digest = object.digest;
        }
        else {
            message.digest = new Uint8Array();
        }
        if (object.receivedTime !== undefined && object.receivedTime !== null) {
            message.receivedTime = object.receivedTime;
        }
        else {
            message.receivedTime = 0;
        }
        if (object.senderTime !== undefined && object.senderTime !== null) {
            message.senderTime = object.senderTime;
        }
        else {
            message.senderTime = 0;
        }
        return message;
    },
};
var basePagingInfo = { pageSize: 0, direction: 0 };
export var PagingInfo = {
    encode: function (message, writer) {
        if (writer === void 0) { writer = _m0.Writer.create(); }
        if (message.pageSize !== 0) {
            writer.uint32(8).uint64(message.pageSize);
        }
        if (message.cursor !== undefined) {
            Index.encode(message.cursor, writer.uint32(18).fork()).ldelim();
        }
        if (message.direction !== 0) {
            writer.uint32(24).int32(message.direction);
        }
        return writer;
    },
    decode: function (input, length) {
        var reader = input instanceof _m0.Reader ? input : new _m0.Reader(input);
        var end = length === undefined ? reader.len : reader.pos + length;
        var message = __assign({}, basePagingInfo);
        while (reader.pos < end) {
            var tag = reader.uint32();
            switch (tag >>> 3) {
                case 1:
                    message.pageSize = longToNumber(reader.uint64());
                    break;
                case 2:
                    message.cursor = Index.decode(reader, reader.uint32());
                    break;
                case 3:
                    message.direction = reader.int32();
                    break;
                default:
                    reader.skipType(tag & 7);
                    break;
            }
        }
        return message;
    },
    fromJSON: function (object) {
        var message = __assign({}, basePagingInfo);
        if (object.pageSize !== undefined && object.pageSize !== null) {
            message.pageSize = Number(object.pageSize);
        }
        else {
            message.pageSize = 0;
        }
        if (object.cursor !== undefined && object.cursor !== null) {
            message.cursor = Index.fromJSON(object.cursor);
        }
        else {
            message.cursor = undefined;
        }
        if (object.direction !== undefined && object.direction !== null) {
            message.direction = pagingInfo_DirectionFromJSON(object.direction);
        }
        else {
            message.direction = 0;
        }
        return message;
    },
    toJSON: function (message) {
        var obj = {};
        message.pageSize !== undefined && (obj.pageSize = message.pageSize);
        message.cursor !== undefined &&
            (obj.cursor = message.cursor ? Index.toJSON(message.cursor) : undefined);
        message.direction !== undefined &&
            (obj.direction = pagingInfo_DirectionToJSON(message.direction));
        return obj;
    },
    fromPartial: function (object) {
        var message = __assign({}, basePagingInfo);
        if (object.pageSize !== undefined && object.pageSize !== null) {
            message.pageSize = object.pageSize;
        }
        else {
            message.pageSize = 0;
        }
        if (object.cursor !== undefined && object.cursor !== null) {
            message.cursor = Index.fromPartial(object.cursor);
        }
        else {
            message.cursor = undefined;
        }
        if (object.direction !== undefined && object.direction !== null) {
            message.direction = object.direction;
        }
        else {
            message.direction = 0;
        }
        return message;
    },
};
var baseContentFilter = { contentTopic: '' };
export var ContentFilter = {
    encode: function (message, writer) {
        if (writer === void 0) { writer = _m0.Writer.create(); }
        if (message.contentTopic !== '') {
            writer.uint32(10).string(message.contentTopic);
        }
        return writer;
    },
    decode: function (input, length) {
        var reader = input instanceof _m0.Reader ? input : new _m0.Reader(input);
        var end = length === undefined ? reader.len : reader.pos + length;
        var message = __assign({}, baseContentFilter);
        while (reader.pos < end) {
            var tag = reader.uint32();
            switch (tag >>> 3) {
                case 1:
                    message.contentTopic = reader.string();
                    break;
                default:
                    reader.skipType(tag & 7);
                    break;
            }
        }
        return message;
    },
    fromJSON: function (object) {
        var message = __assign({}, baseContentFilter);
        if (object.contentTopic !== undefined && object.contentTopic !== null) {
            message.contentTopic = String(object.contentTopic);
        }
        else {
            message.contentTopic = '';
        }
        return message;
    },
    toJSON: function (message) {
        var obj = {};
        message.contentTopic !== undefined &&
            (obj.contentTopic = message.contentTopic);
        return obj;
    },
    fromPartial: function (object) {
        var message = __assign({}, baseContentFilter);
        if (object.contentTopic !== undefined && object.contentTopic !== null) {
            message.contentTopic = object.contentTopic;
        }
        else {
            message.contentTopic = '';
        }
        return message;
    },
};
var baseHistoryQuery = {};
export var HistoryQuery = {
    encode: function (message, writer) {
        if (writer === void 0) { writer = _m0.Writer.create(); }
        if (message.pubSubTopic !== undefined) {
            writer.uint32(18).string(message.pubSubTopic);
        }
        for (var _i = 0, _a = message.contentFilters; _i < _a.length; _i++) {
            var v = _a[_i];
            ContentFilter.encode(v, writer.uint32(26).fork()).ldelim();
        }
        if (message.pagingInfo !== undefined) {
            PagingInfo.encode(message.pagingInfo, writer.uint32(34).fork()).ldelim();
        }
        if (message.startTime !== undefined) {
            writer.uint32(41).double(message.startTime);
        }
        if (message.endTime !== undefined) {
            writer.uint32(49).double(message.endTime);
        }
        return writer;
    },
    decode: function (input, length) {
        var reader = input instanceof _m0.Reader ? input : new _m0.Reader(input);
        var end = length === undefined ? reader.len : reader.pos + length;
        var message = __assign({}, baseHistoryQuery);
        message.contentFilters = [];
        while (reader.pos < end) {
            var tag = reader.uint32();
            switch (tag >>> 3) {
                case 2:
                    message.pubSubTopic = reader.string();
                    break;
                case 3:
                    message.contentFilters.push(ContentFilter.decode(reader, reader.uint32()));
                    break;
                case 4:
                    message.pagingInfo = PagingInfo.decode(reader, reader.uint32());
                    break;
                case 5:
                    message.startTime = reader.double();
                    break;
                case 6:
                    message.endTime = reader.double();
                    break;
                default:
                    reader.skipType(tag & 7);
                    break;
            }
        }
        return message;
    },
    fromJSON: function (object) {
        var message = __assign({}, baseHistoryQuery);
        message.contentFilters = [];
        if (object.pubSubTopic !== undefined && object.pubSubTopic !== null) {
            message.pubSubTopic = String(object.pubSubTopic);
        }
        else {
            message.pubSubTopic = undefined;
        }
        if (object.contentFilters !== undefined && object.contentFilters !== null) {
            for (var _i = 0, _a = object.contentFilters; _i < _a.length; _i++) {
                var e = _a[_i];
                message.contentFilters.push(ContentFilter.fromJSON(e));
            }
        }
        if (object.pagingInfo !== undefined && object.pagingInfo !== null) {
            message.pagingInfo = PagingInfo.fromJSON(object.pagingInfo);
        }
        else {
            message.pagingInfo = undefined;
        }
        if (object.startTime !== undefined && object.startTime !== null) {
            message.startTime = Number(object.startTime);
        }
        else {
            message.startTime = undefined;
        }
        if (object.endTime !== undefined && object.endTime !== null) {
            message.endTime = Number(object.endTime);
        }
        else {
            message.endTime = undefined;
        }
        return message;
    },
    toJSON: function (message) {
        var obj = {};
        message.pubSubTopic !== undefined &&
            (obj.pubSubTopic = message.pubSubTopic);
        if (message.contentFilters) {
            obj.contentFilters = message.contentFilters.map(function (e) {
                return e ? ContentFilter.toJSON(e) : undefined;
            });
        }
        else {
            obj.contentFilters = [];
        }
        message.pagingInfo !== undefined &&
            (obj.pagingInfo = message.pagingInfo
                ? PagingInfo.toJSON(message.pagingInfo)
                : undefined);
        message.startTime !== undefined && (obj.startTime = message.startTime);
        message.endTime !== undefined && (obj.endTime = message.endTime);
        return obj;
    },
    fromPartial: function (object) {
        var message = __assign({}, baseHistoryQuery);
        message.contentFilters = [];
        if (object.pubSubTopic !== undefined && object.pubSubTopic !== null) {
            message.pubSubTopic = object.pubSubTopic;
        }
        else {
            message.pubSubTopic = undefined;
        }
        if (object.contentFilters !== undefined && object.contentFilters !== null) {
            for (var _i = 0, _a = object.contentFilters; _i < _a.length; _i++) {
                var e = _a[_i];
                message.contentFilters.push(ContentFilter.fromPartial(e));
            }
        }
        if (object.pagingInfo !== undefined && object.pagingInfo !== null) {
            message.pagingInfo = PagingInfo.fromPartial(object.pagingInfo);
        }
        else {
            message.pagingInfo = undefined;
        }
        if (object.startTime !== undefined && object.startTime !== null) {
            message.startTime = object.startTime;
        }
        else {
            message.startTime = undefined;
        }
        if (object.endTime !== undefined && object.endTime !== null) {
            message.endTime = object.endTime;
        }
        else {
            message.endTime = undefined;
        }
        return message;
    },
};
var baseHistoryResponse = { error: 0 };
export var HistoryResponse = {
    encode: function (message, writer) {
        if (writer === void 0) { writer = _m0.Writer.create(); }
        for (var _i = 0, _a = message.messages; _i < _a.length; _i++) {
            var v = _a[_i];
            WakuMessage.encode(v, writer.uint32(18).fork()).ldelim();
        }
        if (message.pagingInfo !== undefined) {
            PagingInfo.encode(message.pagingInfo, writer.uint32(26).fork()).ldelim();
        }
        if (message.error !== 0) {
            writer.uint32(32).int32(message.error);
        }
        return writer;
    },
    decode: function (input, length) {
        var reader = input instanceof _m0.Reader ? input : new _m0.Reader(input);
        var end = length === undefined ? reader.len : reader.pos + length;
        var message = __assign({}, baseHistoryResponse);
        message.messages = [];
        while (reader.pos < end) {
            var tag = reader.uint32();
            switch (tag >>> 3) {
                case 2:
                    message.messages.push(WakuMessage.decode(reader, reader.uint32()));
                    break;
                case 3:
                    message.pagingInfo = PagingInfo.decode(reader, reader.uint32());
                    break;
                case 4:
                    message.error = reader.int32();
                    break;
                default:
                    reader.skipType(tag & 7);
                    break;
            }
        }
        return message;
    },
    fromJSON: function (object) {
        var message = __assign({}, baseHistoryResponse);
        message.messages = [];
        if (object.messages !== undefined && object.messages !== null) {
            for (var _i = 0, _a = object.messages; _i < _a.length; _i++) {
                var e = _a[_i];
                message.messages.push(WakuMessage.fromJSON(e));
            }
        }
        if (object.pagingInfo !== undefined && object.pagingInfo !== null) {
            message.pagingInfo = PagingInfo.fromJSON(object.pagingInfo);
        }
        else {
            message.pagingInfo = undefined;
        }
        if (object.error !== undefined && object.error !== null) {
            message.error = historyResponse_ErrorFromJSON(object.error);
        }
        else {
            message.error = 0;
        }
        return message;
    },
    toJSON: function (message) {
        var obj = {};
        if (message.messages) {
            obj.messages = message.messages.map(function (e) {
                return e ? WakuMessage.toJSON(e) : undefined;
            });
        }
        else {
            obj.messages = [];
        }
        message.pagingInfo !== undefined &&
            (obj.pagingInfo = message.pagingInfo
                ? PagingInfo.toJSON(message.pagingInfo)
                : undefined);
        message.error !== undefined &&
            (obj.error = historyResponse_ErrorToJSON(message.error));
        return obj;
    },
    fromPartial: function (object) {
        var message = __assign({}, baseHistoryResponse);
        message.messages = [];
        if (object.messages !== undefined && object.messages !== null) {
            for (var _i = 0, _a = object.messages; _i < _a.length; _i++) {
                var e = _a[_i];
                message.messages.push(WakuMessage.fromPartial(e));
            }
        }
        if (object.pagingInfo !== undefined && object.pagingInfo !== null) {
            message.pagingInfo = PagingInfo.fromPartial(object.pagingInfo);
        }
        else {
            message.pagingInfo = undefined;
        }
        if (object.error !== undefined && object.error !== null) {
            message.error = object.error;
        }
        else {
            message.error = 0;
        }
        return message;
    },
};
var baseHistoryRPC = { requestId: '' };
export var HistoryRPC = {
    encode: function (message, writer) {
        if (writer === void 0) { writer = _m0.Writer.create(); }
        if (message.requestId !== '') {
            writer.uint32(10).string(message.requestId);
        }
        if (message.query !== undefined) {
            HistoryQuery.encode(message.query, writer.uint32(18).fork()).ldelim();
        }
        if (message.response !== undefined) {
            HistoryResponse.encode(message.response, writer.uint32(26).fork()).ldelim();
        }
        return writer;
    },
    decode: function (input, length) {
        var reader = input instanceof _m0.Reader ? input : new _m0.Reader(input);
        var end = length === undefined ? reader.len : reader.pos + length;
        var message = __assign({}, baseHistoryRPC);
        while (reader.pos < end) {
            var tag = reader.uint32();
            switch (tag >>> 3) {
                case 1:
                    message.requestId = reader.string();
                    break;
                case 2:
                    message.query = HistoryQuery.decode(reader, reader.uint32());
                    break;
                case 3:
                    message.response = HistoryResponse.decode(reader, reader.uint32());
                    break;
                default:
                    reader.skipType(tag & 7);
                    break;
            }
        }
        return message;
    },
    fromJSON: function (object) {
        var message = __assign({}, baseHistoryRPC);
        if (object.requestId !== undefined && object.requestId !== null) {
            message.requestId = String(object.requestId);
        }
        else {
            message.requestId = '';
        }
        if (object.query !== undefined && object.query !== null) {
            message.query = HistoryQuery.fromJSON(object.query);
        }
        else {
            message.query = undefined;
        }
        if (object.response !== undefined && object.response !== null) {
            message.response = HistoryResponse.fromJSON(object.response);
        }
        else {
            message.response = undefined;
        }
        return message;
    },
    toJSON: function (message) {
        var obj = {};
        message.requestId !== undefined && (obj.requestId = message.requestId);
        message.query !== undefined &&
            (obj.query = message.query
                ? HistoryQuery.toJSON(message.query)
                : undefined);
        message.response !== undefined &&
            (obj.response = message.response
                ? HistoryResponse.toJSON(message.response)
                : undefined);
        return obj;
    },
    fromPartial: function (object) {
        var message = __assign({}, baseHistoryRPC);
        if (object.requestId !== undefined && object.requestId !== null) {
            message.requestId = object.requestId;
        }
        else {
            message.requestId = '';
        }
        if (object.query !== undefined && object.query !== null) {
            message.query = HistoryQuery.fromPartial(object.query);
        }
        else {
            message.query = undefined;
        }
        if (object.response !== undefined && object.response !== null) {
            message.response = HistoryResponse.fromPartial(object.response);
        }
        else {
            message.response = undefined;
        }
        return message;
    },
};
var globalThis = (function () {
    if (typeof globalThis !== 'undefined')
        return globalThis;
    if (typeof self !== 'undefined')
        return self;
    if (typeof window !== 'undefined')
        return window;
    if (typeof global !== 'undefined')
        return global;
    throw 'Unable to locate global object';
})();
var atob = globalThis.atob ||
    (function (b64) { return globalThis.Buffer.from(b64, 'base64').toString('binary'); });
function bytesFromBase64(b64) {
    var bin = atob(b64);
    var arr = new Uint8Array(bin.length);
    for (var i = 0; i < bin.length; ++i) {
        arr[i] = bin.charCodeAt(i);
    }
    return arr;
}
var btoa = globalThis.btoa ||
    (function (bin) { return globalThis.Buffer.from(bin, 'binary').toString('base64'); });
function base64FromBytes(arr) {
    var bin = [];
    for (var _i = 0, arr_1 = arr; _i < arr_1.length; _i++) {
        var byte = arr_1[_i];
        bin.push(String.fromCharCode(byte));
    }
    return btoa(bin.join(''));
}
function longToNumber(long) {
    if (long.gt(Number.MAX_SAFE_INTEGER)) {
        throw new globalThis.Error('Value is larger than Number.MAX_SAFE_INTEGER');
    }
    return long.toNumber();
}
if (_m0.util.Long !== Long) {
    _m0.util.Long = Long;
    _m0.configure();
}
//# sourceMappingURL=store.js.map