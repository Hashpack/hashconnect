"use strict";
var __createBinding = (this && this.__createBinding) || (Object.create ? (function(o, m, k, k2) {
    if (k2 === undefined) k2 = k;
    Object.defineProperty(o, k2, { enumerable: true, get: function() { return m[k]; } });
}) : (function(o, m, k, k2) {
    if (k2 === undefined) k2 = k;
    o[k2] = m[k];
}));
var __setModuleDefault = (this && this.__setModuleDefault) || (Object.create ? (function(o, v) {
    Object.defineProperty(o, "default", { enumerable: true, value: v });
}) : function(o, v) {
    o["default"] = v;
});
var __importStar = (this && this.__importStar) || function (mod) {
    if (mod && mod.__esModule) return mod;
    var result = {};
    if (mod != null) for (var k in mod) if (k !== "default" && Object.prototype.hasOwnProperty.call(mod, k)) __createBinding(result, mod, k);
    __setModuleDefault(result, mod);
    return result;
};
var __importDefault = (this && this.__importDefault) || function (mod) {
    return (mod && mod.__esModule) ? mod : { "default": mod };
};
Object.defineProperty(exports, "__esModule", { value: true });
exports.WakuMessage = void 0;
// Ensure that this class matches the proto interface while
const buffer_1 = require("buffer");
const debug_1 = __importDefault(require("debug"));
const minimal_1 = require("protobufjs/minimal");
// Protecting the user from protobuf oddities
const proto = __importStar(require("../../proto/waku/v2/message"));
const version_1 = __importStar(require("./version_1"));
const DefaultVersion = 0;
const dbg = debug_1.default('waku:message');
class WakuMessage {
    constructor(proto, _signaturePublicKey, _signature) {
        this.proto = proto;
        this._signaturePublicKey = _signaturePublicKey;
        this._signature = _signature;
    }
    /**
     * Create Message with a utf-8 string as payload.
     */
    static async fromUtf8String(utf8, contentTopic, opts) {
        const payload = buffer_1.Buffer.from(utf8, 'utf-8');
        return WakuMessage.fromBytes(payload, contentTopic, opts);
    }
    /**
     * Create a Waku Message with the given payload.
     *
     * By default, the payload is kept clear (version 0).
     * If `opts.encPublicKey` is passed, the payload is encrypted using
     * asymmetric encryption (version 1).
     *
     * If `opts.sigPrivKey` is passed and version 1 is used, the payload is signed
     * before encryption.
     *
     * @throws if both `opts.encPublicKey` and `opt.symKey` are passed
     */
    static async fromBytes(payload, contentTopic, opts) {
        const { timestamp, encPublicKey, symKey, sigPrivKey } = Object.assign({ timestamp: new Date() }, opts ? opts : {});
        let _payload = payload;
        let version = DefaultVersion;
        let sig;
        if (encPublicKey && symKey) {
            throw 'Pass either `encPublicKey` or `symKey`, not both.';
        }
        if (encPublicKey) {
            const enc = version_1.clearEncode(_payload, sigPrivKey);
            _payload = await version_1.encryptAsymmetric(enc.payload, encPublicKey);
            sig = enc.sig;
            version = 1;
        }
        else if (symKey) {
            const enc = version_1.clearEncode(_payload, sigPrivKey);
            _payload = await version_1.encryptSymmetric(enc.payload, symKey);
            sig = enc.sig;
            version = 1;
        }
        return new WakuMessage({
            payload: _payload,
            timestamp: timestamp.valueOf() / 1000,
            version,
            contentTopic,
        }, sig === null || sig === void 0 ? void 0 : sig.publicKey, sig === null || sig === void 0 ? void 0 : sig.signature);
    }
    /**
     * Decode a byte array into Waku Message.
     *
     * @params bytes The message encoded using protobuf as defined in [14/WAKU2-MESSAGE](https://rfc.vac.dev/spec/14/).
     * @params decryptionKeys If the payload is encrypted (version = 1), then the
     * keys are used to attempt decryption of the message. The passed key can either
     * be asymmetric private keys or symmetric keys, both method are tried for each
     * key until the message is decrypted or combinations are ran out.
     */
    static async decode(bytes, decryptionKeys) {
        const protoBuf = proto.WakuMessage.decode(minimal_1.Reader.create(bytes));
        return WakuMessage.decodeProto(protoBuf, decryptionKeys);
    }
    /**
     * Decode and decrypt Waku Message Protobuf Object into Waku Message.
     *
     * @params protoBuf The message to decode and decrypt.
     * @params decryptionKeys If the payload is encrypted (version = 1), then the
     * keys are used to attempt decryption of the message. The passed key can either
     * be asymmetric private keys or symmetric keys, both method are tried for each
     * key until the message is decrypted or combinations are ran out.
     */
    static async decodeProto(protoBuf, decryptionKeys) {
        var _a, _b;
        if (protoBuf.payload === undefined) {
            dbg('Payload is undefined');
            return;
        }
        const payload = protoBuf.payload;
        let signaturePublicKey;
        let signature;
        if (protoBuf.version === 1 && protoBuf.payload) {
            if (decryptionKeys === undefined) {
                dbg('Payload is encrypted but no private keys have been provided.');
                return;
            }
            // Returns a bunch of `undefined` and hopefully one decrypted result
            const allResults = await Promise.all(decryptionKeys.map(async (privateKey) => {
                try {
                    return await version_1.decryptSymmetric(payload, privateKey);
                }
                catch (e) {
                    dbg('Failed to decrypt message using symmetric encryption', e);
                    try {
                        return await version_1.decryptAsymmetric(payload, privateKey);
                    }
                    catch (e) {
                        dbg('Failed to decrypt message using asymmetric encryption', e);
                        return;
                    }
                }
            }));
            const isDefined = (dec) => {
                return !!dec;
            };
            const decodedResults = allResults.filter(isDefined);
            if (decodedResults.length === 0) {
                dbg('Failed to decrypt payload.');
                return;
            }
            const dec = decodedResults[0];
            const res = await version_1.clearDecode(dec);
            if (!res) {
                dbg('Failed to decode payload.');
                return;
            }
            Object.assign(protoBuf, { payload: res.payload });
            signaturePublicKey = (_a = res.sig) === null || _a === void 0 ? void 0 : _a.publicKey;
            signature = (_b = res.sig) === null || _b === void 0 ? void 0 : _b.signature;
        }
        return new WakuMessage(protoBuf, signaturePublicKey, signature);
    }
    encode() {
        return proto.WakuMessage.encode(this.proto).finish();
    }
    get payloadAsUtf8() {
        if (!this.proto.payload) {
            return '';
        }
        return buffer_1.Buffer.from(this.proto.payload).toString('utf-8');
    }
    get payload() {
        return this.proto.payload;
    }
    get contentTopic() {
        return this.proto.contentTopic;
    }
    get version() {
        return this.proto.version;
    }
    get timestamp() {
        if (this.proto.timestamp) {
            return new Date(this.proto.timestamp * 1000);
        }
        return;
    }
    /**
     * The public key used to sign the message.
     *
     * MAY be present if the message is version 1.
     */
    get signaturePublicKey() {
        return this._signaturePublicKey;
    }
    /**
     * The signature of the message.
     *
     * MAY be present if the message is version 1.
     */
    get signature() {
        return this._signature;
    }
}
exports.WakuMessage = WakuMessage;
//# sourceMappingURL=index.js.map