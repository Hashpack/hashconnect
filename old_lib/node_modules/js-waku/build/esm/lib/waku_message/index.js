var __awaiter = (this && this.__awaiter) || function (thisArg, _arguments, P, generator) {
    function adopt(value) { return value instanceof P ? value : new P(function (resolve) { resolve(value); }); }
    return new (P || (P = Promise))(function (resolve, reject) {
        function fulfilled(value) { try { step(generator.next(value)); } catch (e) { reject(e); } }
        function rejected(value) { try { step(generator["throw"](value)); } catch (e) { reject(e); } }
        function step(result) { result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected); }
        step((generator = generator.apply(thisArg, _arguments || [])).next());
    });
};
var __generator = (this && this.__generator) || function (thisArg, body) {
    var _ = { label: 0, sent: function() { if (t[0] & 1) throw t[1]; return t[1]; }, trys: [], ops: [] }, f, y, t, g;
    return g = { next: verb(0), "throw": verb(1), "return": verb(2) }, typeof Symbol === "function" && (g[Symbol.iterator] = function() { return this; }), g;
    function verb(n) { return function (v) { return step([n, v]); }; }
    function step(op) {
        if (f) throw new TypeError("Generator is already executing.");
        while (_) try {
            if (f = 1, y && (t = op[0] & 2 ? y["return"] : op[0] ? y["throw"] || ((t = y["return"]) && t.call(y), 0) : y.next) && !(t = t.call(y, op[1])).done) return t;
            if (y = 0, t) op = [op[0] & 2, t.value];
            switch (op[0]) {
                case 0: case 1: t = op; break;
                case 4: _.label++; return { value: op[1], done: false };
                case 5: _.label++; y = op[1]; op = [0]; continue;
                case 7: op = _.ops.pop(); _.trys.pop(); continue;
                default:
                    if (!(t = _.trys, t = t.length > 0 && t[t.length - 1]) && (op[0] === 6 || op[0] === 2)) { _ = 0; continue; }
                    if (op[0] === 3 && (!t || (op[1] > t[0] && op[1] < t[3]))) { _.label = op[1]; break; }
                    if (op[0] === 6 && _.label < t[1]) { _.label = t[1]; t = op; break; }
                    if (t && _.label < t[2]) { _.label = t[2]; _.ops.push(op); break; }
                    if (t[2]) _.ops.pop();
                    _.trys.pop(); continue;
            }
            op = body.call(thisArg, _);
        } catch (e) { op = [6, e]; y = 0; } finally { f = t = 0; }
        if (op[0] & 5) throw op[1]; return { value: op[0] ? op[1] : void 0, done: true };
    }
};
// Ensure that this class matches the proto interface while
import { Buffer } from 'buffer';
import debug from 'debug';
import { Reader } from 'protobufjs/minimal';
// Protecting the user from protobuf oddities
import * as proto from '../../proto/waku/v2/message';
import * as version_1 from './version_1';
var DefaultVersion = 0;
var dbg = debug('waku:message');
var WakuMessage = /** @class */ (function () {
    function WakuMessage(proto, _signaturePublicKey, _signature) {
        this.proto = proto;
        this._signaturePublicKey = _signaturePublicKey;
        this._signature = _signature;
    }
    /**
     * Create Message with a utf-8 string as payload.
     */
    WakuMessage.fromUtf8String = function (utf8, contentTopic, opts) {
        return __awaiter(this, void 0, void 0, function () {
            var payload;
            return __generator(this, function (_a) {
                payload = Buffer.from(utf8, 'utf-8');
                return [2 /*return*/, WakuMessage.fromBytes(payload, contentTopic, opts)];
            });
        });
    };
    /**
     * Create a Waku Message with the given payload.
     *
     * By default, the payload is kept clear (version 0).
     * If `opts.encPublicKey` is passed, the payload is encrypted using
     * asymmetric encryption (version 1).
     *
     * If `opts.sigPrivKey` is passed and version 1 is used, the payload is signed
     * before encryption.
     *
     * @throws if both `opts.encPublicKey` and `opt.symKey` are passed
     */
    WakuMessage.fromBytes = function (payload, contentTopic, opts) {
        return __awaiter(this, void 0, void 0, function () {
            var _a, timestamp, encPublicKey, symKey, sigPrivKey, _payload, version, sig, enc, enc;
            return __generator(this, function (_b) {
                switch (_b.label) {
                    case 0:
                        _a = Object.assign({ timestamp: new Date() }, opts ? opts : {}), timestamp = _a.timestamp, encPublicKey = _a.encPublicKey, symKey = _a.symKey, sigPrivKey = _a.sigPrivKey;
                        _payload = payload;
                        version = DefaultVersion;
                        if (encPublicKey && symKey) {
                            throw 'Pass either `encPublicKey` or `symKey`, not both.';
                        }
                        if (!encPublicKey) return [3 /*break*/, 2];
                        enc = version_1.clearEncode(_payload, sigPrivKey);
                        return [4 /*yield*/, version_1.encryptAsymmetric(enc.payload, encPublicKey)];
                    case 1:
                        _payload = _b.sent();
                        sig = enc.sig;
                        version = 1;
                        return [3 /*break*/, 4];
                    case 2:
                        if (!symKey) return [3 /*break*/, 4];
                        enc = version_1.clearEncode(_payload, sigPrivKey);
                        return [4 /*yield*/, version_1.encryptSymmetric(enc.payload, symKey)];
                    case 3:
                        _payload = _b.sent();
                        sig = enc.sig;
                        version = 1;
                        _b.label = 4;
                    case 4: return [2 /*return*/, new WakuMessage({
                            payload: _payload,
                            timestamp: timestamp.valueOf() / 1000,
                            version: version,
                            contentTopic: contentTopic,
                        }, sig === null || sig === void 0 ? void 0 : sig.publicKey, sig === null || sig === void 0 ? void 0 : sig.signature)];
                }
            });
        });
    };
    /**
     * Decode a byte array into Waku Message.
     *
     * @params bytes The message encoded using protobuf as defined in [14/WAKU2-MESSAGE](https://rfc.vac.dev/spec/14/).
     * @params decryptionKeys If the payload is encrypted (version = 1), then the
     * keys are used to attempt decryption of the message. The passed key can either
     * be asymmetric private keys or symmetric keys, both method are tried for each
     * key until the message is decrypted or combinations are ran out.
     */
    WakuMessage.decode = function (bytes, decryptionKeys) {
        return __awaiter(this, void 0, void 0, function () {
            var protoBuf;
            return __generator(this, function (_a) {
                protoBuf = proto.WakuMessage.decode(Reader.create(bytes));
                return [2 /*return*/, WakuMessage.decodeProto(protoBuf, decryptionKeys)];
            });
        });
    };
    /**
     * Decode and decrypt Waku Message Protobuf Object into Waku Message.
     *
     * @params protoBuf The message to decode and decrypt.
     * @params decryptionKeys If the payload is encrypted (version = 1), then the
     * keys are used to attempt decryption of the message. The passed key can either
     * be asymmetric private keys or symmetric keys, both method are tried for each
     * key until the message is decrypted or combinations are ran out.
     */
    WakuMessage.decodeProto = function (protoBuf, decryptionKeys) {
        var _a, _b;
        return __awaiter(this, void 0, void 0, function () {
            var payload, signaturePublicKey, signature, allResults, isDefined, decodedResults, dec, res;
            var _this = this;
            return __generator(this, function (_c) {
                switch (_c.label) {
                    case 0:
                        if (protoBuf.payload === undefined) {
                            dbg('Payload is undefined');
                            return [2 /*return*/];
                        }
                        payload = protoBuf.payload;
                        if (!(protoBuf.version === 1 && protoBuf.payload)) return [3 /*break*/, 3];
                        if (decryptionKeys === undefined) {
                            dbg('Payload is encrypted but no private keys have been provided.');
                            return [2 /*return*/];
                        }
                        return [4 /*yield*/, Promise.all(decryptionKeys.map(function (privateKey) { return __awaiter(_this, void 0, void 0, function () {
                                var e_1, e_2;
                                return __generator(this, function (_a) {
                                    switch (_a.label) {
                                        case 0:
                                            _a.trys.push([0, 2, , 7]);
                                            return [4 /*yield*/, version_1.decryptSymmetric(payload, privateKey)];
                                        case 1: return [2 /*return*/, _a.sent()];
                                        case 2:
                                            e_1 = _a.sent();
                                            dbg('Failed to decrypt message using symmetric encryption', e_1);
                                            _a.label = 3;
                                        case 3:
                                            _a.trys.push([3, 5, , 6]);
                                            return [4 /*yield*/, version_1.decryptAsymmetric(payload, privateKey)];
                                        case 4: return [2 /*return*/, _a.sent()];
                                        case 5:
                                            e_2 = _a.sent();
                                            dbg('Failed to decrypt message using asymmetric encryption', e_2);
                                            return [2 /*return*/];
                                        case 6: return [3 /*break*/, 7];
                                        case 7: return [2 /*return*/];
                                    }
                                });
                            }); }))];
                    case 1:
                        allResults = _c.sent();
                        isDefined = function (dec) {
                            return !!dec;
                        };
                        decodedResults = allResults.filter(isDefined);
                        if (decodedResults.length === 0) {
                            dbg('Failed to decrypt payload.');
                            return [2 /*return*/];
                        }
                        dec = decodedResults[0];
                        return [4 /*yield*/, version_1.clearDecode(dec)];
                    case 2:
                        res = _c.sent();
                        if (!res) {
                            dbg('Failed to decode payload.');
                            return [2 /*return*/];
                        }
                        Object.assign(protoBuf, { payload: res.payload });
                        signaturePublicKey = (_a = res.sig) === null || _a === void 0 ? void 0 : _a.publicKey;
                        signature = (_b = res.sig) === null || _b === void 0 ? void 0 : _b.signature;
                        _c.label = 3;
                    case 3: return [2 /*return*/, new WakuMessage(protoBuf, signaturePublicKey, signature)];
                }
            });
        });
    };
    WakuMessage.prototype.encode = function () {
        return proto.WakuMessage.encode(this.proto).finish();
    };
    Object.defineProperty(WakuMessage.prototype, "payloadAsUtf8", {
        get: function () {
            if (!this.proto.payload) {
                return '';
            }
            return Buffer.from(this.proto.payload).toString('utf-8');
        },
        enumerable: false,
        configurable: true
    });
    Object.defineProperty(WakuMessage.prototype, "payload", {
        get: function () {
            return this.proto.payload;
        },
        enumerable: false,
        configurable: true
    });
    Object.defineProperty(WakuMessage.prototype, "contentTopic", {
        get: function () {
            return this.proto.contentTopic;
        },
        enumerable: false,
        configurable: true
    });
    Object.defineProperty(WakuMessage.prototype, "version", {
        get: function () {
            return this.proto.version;
        },
        enumerable: false,
        configurable: true
    });
    Object.defineProperty(WakuMessage.prototype, "timestamp", {
        get: function () {
            if (this.proto.timestamp) {
                return new Date(this.proto.timestamp * 1000);
            }
            return;
        },
        enumerable: false,
        configurable: true
    });
    Object.defineProperty(WakuMessage.prototype, "signaturePublicKey", {
        /**
         * The public key used to sign the message.
         *
         * MAY be present if the message is version 1.
         */
        get: function () {
            return this._signaturePublicKey;
        },
        enumerable: false,
        configurable: true
    });
    Object.defineProperty(WakuMessage.prototype, "signature", {
        /**
         * The signature of the message.
         *
         * MAY be present if the message is version 1.
         */
        get: function () {
            return this._signature;
        },
        enumerable: false,
        configurable: true
    });
    return WakuMessage;
}());
export { WakuMessage };
//# sourceMappingURL=index.js.map