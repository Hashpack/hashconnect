"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.hierarchyTemplate = void 0;
const utils_1 = require("../../../../utils");
const models_1 = require("../../../../models");
function fullHierarchy(context, root) {
    // Note: We don't use root.anchor for the anchor, because those are built on a per page basis.
    // And classes/interfaces get their own page, so all the anchors will be empty anyways.
    // Full name should be safe here, since this list only includes classes/interfaces.
    return (utils_1.JSX.createElement("li", null,
        utils_1.JSX.createElement("a", { id: root.getFullName(), class: "tsd-anchor" }),
        utils_1.JSX.createElement("a", { href: context.urlTo(root) },
            context.icons[root.kind](),
            root.name),
        utils_1.JSX.createElement("ul", null,
            root.implementedBy?.map((child) => {
                return child.reflection && fullHierarchy(context, child.reflection);
            }),
            root.extendedBy?.map((child) => {
                return child.reflection && fullHierarchy(context, child.reflection);
            }))));
}
function hierarchyTemplate(context, props) {
    // Keep this condition in sync with the one in DefaultTheme.tsx
    const roots = props.project.getReflectionsByKind(models_1.ReflectionKind.ClassOrInterface)
        .filter((refl) => !(refl.implementedTypes || refl.extendedTypes) && (refl.implementedBy || refl.extendedBy))
        .sort((a, b) => a.name.localeCompare(b.name));
    return (utils_1.JSX.createElement(utils_1.JSX.Fragment, null,
        utils_1.JSX.createElement("h2", null, "Class Hierarchy"),
        roots.map((root) => (utils_1.JSX.createElement("ul", { class: "tsd-full-hierarchy" }, fullHierarchy(context, root))))));
}
exports.hierarchyTemplate = hierarchyTemplate;
