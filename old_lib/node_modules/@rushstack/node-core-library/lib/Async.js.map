{"version":3,"file":"Async.js","sourceRoot":"","sources":["../src/Async.ts"],"names":[],"mappings":";AAAA,4FAA4F;AAC5F,2DAA2D;;;AAkB3D;;;;GAIG;AACH,MAAa,KAAK;IAChB;;;;;;;;;;;;;;;;;;;OAmBG;IACI,MAAM,CAAC,KAAK,CAAC,QAAQ,CAC1B,KAAe,EACf,QAAiE,EACjE,OAA8C;QAE9C,MAAM,MAAM,GAAc,EAAE,CAAC;QAE7B,MAAM,KAAK,CAAC,YAAY,CACtB,KAAK,EACL,KAAK,EAAE,IAAY,EAAE,UAAkB,EAAiB,EAAE;YACxD,MAAM,CAAC,UAAU,CAAC,GAAG,MAAM,QAAQ,CAAC,IAAI,EAAE,UAAU,CAAC,CAAC;QACxD,CAAC,EACD,OAAO,CACR,CAAC;QAEF,OAAO,MAAM,CAAC;IAChB,CAAC;IAED;;;;;;;;;;;;;;;;;OAiBG;IACI,MAAM,CAAC,KAAK,CAAC,YAAY,CAC9B,KAAe,EACf,QAA8D,EAC9D,OAA8C;QAE9C,MAAM,IAAI,OAAO,CAAC,CAAC,OAAmB,EAAE,MAA8B,EAAE,EAAE;YACxE,MAAM,WAAW,GACf,CAAA,OAAO,aAAP,OAAO,uBAAP,OAAO,CAAE,WAAW,KAAI,OAAO,CAAC,WAAW,GAAG,CAAC,CAAC,CAAC,CAAC,OAAO,CAAC,WAAW,CAAC,CAAC,CAAC,QAAQ,CAAC;YACnF,IAAI,oBAAoB,GAAW,CAAC,CAAC;YACrC,IAAI,UAAU,GAAW,CAAC,CAAC;YAE3B,SAAS,qBAAqB;gBAC5B,oBAAoB,EAAE,CAAC;gBACvB,IAAI,oBAAoB,KAAK,CAAC,IAAI,UAAU,IAAI,KAAK,CAAC,MAAM,EAAE;oBAC5D,OAAO,EAAE,CAAC;iBACX;gBAED,OAAO,oBAAoB,GAAG,WAAW,EAAE;oBACzC,IAAI,UAAU,GAAG,KAAK,CAAC,MAAM,EAAE;wBAC7B,oBAAoB,EAAE,CAAC;wBACvB,IAAI;4BACF,OAAO,CAAC,OAAO,CAAC,QAAQ,CAAC,KAAK,CAAC,UAAU,CAAC,EAAE,UAAU,EAAE,CAAC,CAAC;iCACvD,IAAI,CAAC,GAAG,EAAE,CAAC,qBAAqB,EAAE,CAAC;iCACnC,KAAK,CAAC,MAAM,CAAC,CAAC;yBAClB;wBAAC,OAAO,KAAK,EAAE;4BACd,MAAM,CAAC,KAAK,CAAC,CAAC;yBACf;qBACF;yBAAM;wBACL,MAAM;qBACP;iBACF;YACH,CAAC;YAED,qBAAqB,EAAE,CAAC;QAC1B,CAAC,CAAC,CAAC;IACL,CAAC;IAED;;OAEG;IACI,MAAM,CAAC,KAAK,CAAC,KAAK,CAAC,EAAU;QAClC,MAAM,IAAI,OAAO,CAAC,CAAC,OAAO,EAAE,EAAE;YAC5B,UAAU,CAAC,OAAO,EAAE,EAAE,CAAC,CAAC;QAC1B,CAAC,CAAC,CAAC;IACL,CAAC;CACF;AAtGD,sBAsGC","sourcesContent":["// Copyright (c) Microsoft Corporation. All rights reserved. Licensed under the MIT license.\r\n// See LICENSE in the project root for license information.\r\n\r\n/**\r\n * Options for controlling the parallelism of asynchronous operations.\r\n *\r\n * @remarks\r\n * Used with {@link Async.mapAsync} and {@link Async.forEachAsync}.\r\n *\r\n * @beta\r\n */\r\nexport interface IAsyncParallelismOptions {\r\n  /**\r\n   * Optionally used with the  {@link Async.mapAsync} and {@link Async.forEachAsync}\r\n   * to limit the maximum number of concurrent promises to the specified number.\r\n   */\r\n  concurrency?: number;\r\n}\r\n\r\n/**\r\n * Utilities for parallel asynchronous operations, for use with the system `Promise` APIs.\r\n *\r\n * @beta\r\n */\r\nexport class Async {\r\n  /**\r\n   * Given an input array and a `callback` function, invoke the callback to start a\r\n   * promise for each element in the array.  Returns an array containing the results.\r\n   *\r\n   * @remarks\r\n   * This API is similar to the system `Array#map`, except that the loop is asynchronous,\r\n   * and the maximum number of concurrent promises can be throttled\r\n   * using {@link IAsyncParallelismOptions.concurrency}.\r\n   *\r\n   * If `callback` throws a synchronous exception, or if it returns a promise that rejects,\r\n   * then the loop stops immediately.  Any remaining array items will be skipped, and\r\n   * overall operation will reject with the first error that was encountered.\r\n   *\r\n   * @param array - the array of inputs for the callback function\r\n   * @param callback - a function that starts an asynchronous promise for an element\r\n   *   from the array\r\n   * @param options - options for customizing the control flow\r\n   * @returns an array containing the result for each callback, in the same order\r\n   *   as the original input `array`\r\n   */\r\n  public static async mapAsync<TEntry, TRetVal>(\r\n    array: TEntry[],\r\n    callback: (entry: TEntry, arrayIndex: number) => Promise<TRetVal>,\r\n    options?: IAsyncParallelismOptions | undefined\r\n  ): Promise<TRetVal[]> {\r\n    const result: TRetVal[] = [];\r\n\r\n    await Async.forEachAsync(\r\n      array,\r\n      async (item: TEntry, arrayIndex: number): Promise<void> => {\r\n        result[arrayIndex] = await callback(item, arrayIndex);\r\n      },\r\n      options\r\n    );\r\n\r\n    return result;\r\n  }\r\n\r\n  /**\r\n   * Given an input array and a `callback` function, invoke the callback to start a\r\n   * promise for each element in the array.\r\n   *\r\n   * @remarks\r\n   * This API is similar to the system `Array#forEach`, except that the loop is asynchronous,\r\n   * and the maximum number of concurrent promises can be throttled\r\n   * using {@link IAsyncParallelismOptions.concurrency}.\r\n   *\r\n   * If `callback` throws a synchronous exception, or if it returns a promise that rejects,\r\n   * then the loop stops immediately.  Any remaining array items will be skipped, and\r\n   * overall operation will reject with the first error that was encountered.\r\n   *\r\n   * @param array - the array of inputs for the callback function\r\n   * @param callback - a function that starts an asynchronous promise for an element\r\n   *   from the array\r\n   * @param options - options for customizing the control flow\r\n   */\r\n  public static async forEachAsync<TEntry>(\r\n    array: TEntry[],\r\n    callback: (entry: TEntry, arrayIndex: number) => Promise<void>,\r\n    options?: IAsyncParallelismOptions | undefined\r\n  ): Promise<void> {\r\n    await new Promise((resolve: () => void, reject: (error: Error) => void) => {\r\n      const concurrency: number =\r\n        options?.concurrency && options.concurrency > 0 ? options.concurrency : Infinity;\r\n      let operationsInProgress: number = 1;\r\n      let arrayIndex: number = 0;\r\n\r\n      function onOperationCompletion(): void {\r\n        operationsInProgress--;\r\n        if (operationsInProgress === 0 && arrayIndex >= array.length) {\r\n          resolve();\r\n        }\r\n\r\n        while (operationsInProgress < concurrency) {\r\n          if (arrayIndex < array.length) {\r\n            operationsInProgress++;\r\n            try {\r\n              Promise.resolve(callback(array[arrayIndex], arrayIndex++))\r\n                .then(() => onOperationCompletion())\r\n                .catch(reject);\r\n            } catch (error) {\r\n              reject(error);\r\n            }\r\n          } else {\r\n            break;\r\n          }\r\n        }\r\n      }\r\n\r\n      onOperationCompletion();\r\n    });\r\n  }\r\n\r\n  /**\r\n   * Return a promise that resolves after the specified number of milliseconds.\r\n   */\r\n  public static async sleep(ms: number): Promise<void> {\r\n    await new Promise((resolve) => {\r\n      setTimeout(resolve, ms);\r\n    });\r\n  }\r\n}\r\n"]}