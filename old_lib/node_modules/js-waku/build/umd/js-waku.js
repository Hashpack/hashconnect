(function webpackUniversalModuleDefinition(root, factory) {
	if(typeof exports === 'object' && typeof module === 'object')
		module.exports = factory();
	else if(typeof define === 'function' && define.amd)
		define([], factory);
	else if(typeof exports === 'object')
		exports["jswaku"] = factory();
	else
		root["jswaku"] = factory();
})(this, function() {
return /******/ (() => { // webpackBootstrap
/******/ 	var __webpack_modules__ = ({

/***/ "./src/index.ts":
/*!**********************!*\
  !*** ./src/index.ts ***!
  \**********************/
/***/ (function(__unused_webpack_module, exports, __webpack_require__) {

"use strict";

var __createBinding = (this && this.__createBinding) || (Object.create ? (function(o, m, k, k2) {
    if (k2 === undefined) k2 = k;
    Object.defineProperty(o, k2, { enumerable: true, get: function() { return m[k]; } });
}) : (function(o, m, k, k2) {
    if (k2 === undefined) k2 = k;
    o[k2] = m[k];
}));
var __setModuleDefault = (this && this.__setModuleDefault) || (Object.create ? (function(o, v) {
    Object.defineProperty(o, "default", { enumerable: true, value: v });
}) : function(o, v) {
    o["default"] = v;
});
var __importStar = (this && this.__importStar) || function (mod) {
    if (mod && mod.__esModule) return mod;
    var result = {};
    if (mod != null) for (var k in mod) if (k !== "default" && Object.prototype.hasOwnProperty.call(mod, k)) __createBinding(result, mod, k);
    __setModuleDefault(result, mod);
    return result;
};
Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.proto = exports.StoreCodec = exports.WakuStore = exports.PageDirection = exports.RelayCodecs = exports.WakuRelay = exports.PushResponse = exports.LightPushCodec = exports.WakuLightPush = exports.getPublicKey = exports.generateSymmetricKey = exports.generatePrivateKey = exports.WakuMessage = exports.DefaultPubSubTopic = exports.Waku = exports.utils = exports.getBootstrapNodes = void 0;
var discovery_1 = __webpack_require__(/*! ./lib/discovery */ "./src/lib/discovery.ts");
Object.defineProperty(exports, "getBootstrapNodes", ({ enumerable: true, get: function () { return discovery_1.getBootstrapNodes; } }));
exports.utils = __importStar(__webpack_require__(/*! ./lib/utils */ "./src/lib/utils.ts"));
var waku_1 = __webpack_require__(/*! ./lib/waku */ "./src/lib/waku.ts");
Object.defineProperty(exports, "Waku", ({ enumerable: true, get: function () { return waku_1.Waku; } }));
Object.defineProperty(exports, "DefaultPubSubTopic", ({ enumerable: true, get: function () { return waku_1.DefaultPubSubTopic; } }));
var waku_message_1 = __webpack_require__(/*! ./lib/waku_message */ "./src/lib/waku_message/index.ts");
Object.defineProperty(exports, "WakuMessage", ({ enumerable: true, get: function () { return waku_message_1.WakuMessage; } }));
var version_1_1 = __webpack_require__(/*! ./lib/waku_message/version_1 */ "./src/lib/waku_message/version_1.ts");
Object.defineProperty(exports, "generatePrivateKey", ({ enumerable: true, get: function () { return version_1_1.generatePrivateKey; } }));
Object.defineProperty(exports, "generateSymmetricKey", ({ enumerable: true, get: function () { return version_1_1.generateSymmetricKey; } }));
Object.defineProperty(exports, "getPublicKey", ({ enumerable: true, get: function () { return version_1_1.getPublicKey; } }));
var waku_light_push_1 = __webpack_require__(/*! ./lib/waku_light_push */ "./src/lib/waku_light_push/index.ts");
Object.defineProperty(exports, "WakuLightPush", ({ enumerable: true, get: function () { return waku_light_push_1.WakuLightPush; } }));
Object.defineProperty(exports, "LightPushCodec", ({ enumerable: true, get: function () { return waku_light_push_1.LightPushCodec; } }));
Object.defineProperty(exports, "PushResponse", ({ enumerable: true, get: function () { return waku_light_push_1.PushResponse; } }));
var waku_relay_1 = __webpack_require__(/*! ./lib/waku_relay */ "./src/lib/waku_relay/index.ts");
Object.defineProperty(exports, "WakuRelay", ({ enumerable: true, get: function () { return waku_relay_1.WakuRelay; } }));
Object.defineProperty(exports, "RelayCodecs", ({ enumerable: true, get: function () { return waku_relay_1.RelayCodecs; } }));
var waku_store_1 = __webpack_require__(/*! ./lib/waku_store */ "./src/lib/waku_store/index.ts");
Object.defineProperty(exports, "PageDirection", ({ enumerable: true, get: function () { return waku_store_1.PageDirection; } }));
Object.defineProperty(exports, "WakuStore", ({ enumerable: true, get: function () { return waku_store_1.WakuStore; } }));
Object.defineProperty(exports, "StoreCodec", ({ enumerable: true, get: function () { return waku_store_1.StoreCodec; } }));
exports.proto = __importStar(__webpack_require__(/*! ./proto */ "./src/proto/index.ts"));


/***/ }),

/***/ "./src/lib/discovery.ts":
/*!******************************!*\
  !*** ./src/lib/discovery.ts ***!
  \******************************/
/***/ (function(__unused_webpack_module, exports, __webpack_require__) {

"use strict";

var __importDefault = (this && this.__importDefault) || function (mod) {
    return (mod && mod.__esModule) ? mod : { "default": mod };
};
Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.getPseudoRandomSubset = exports.getBootstrapNodes = void 0;
const axios_1 = __importDefault(__webpack_require__(/*! axios */ "./node_modules/axios/index.js"));
const debug_1 = __importDefault(__webpack_require__(/*! debug */ "./node_modules/debug/src/browser.js"));
const utils_1 = __webpack_require__(/*! libp2p-gossipsub/src/utils */ "./node_modules/libp2p-gossipsub/src/utils/index.js");
const dbg = debug_1.default('waku:discovery');
const DefaultWantedNumber = 1;
/**
 * GET list of nodes from remote HTTP host.
 *
 * Default behaviour is to return nodes hosted by Status.
 *
 * @param path The property path to access the node list. The result should be
 * a string, a string array or an object. If the result is an object then the
 * values of the objects are used as multiaddresses. For example, if the GET
 * request returns `{ foo: { bar: [address1, address2] } }` then `path` should be
 * `[ "foo", "bar" ]`.
 * @param url Remote host containing bootstrap peers in JSON format.
 * @param wantedNumber The number of connections desired. Defaults to [DefaultWantedNumber].
 *
 * @returns An array of multiaddresses.
 * @throws If the remote host is unreachable or the response cannot be parsed
 * according to the passed _path_.
 */
async function getBootstrapNodes(path = ['fleets', 'wakuv2.prod', 'waku-websocket'], url = 'https://fleets.status.im/', wantedNumber = DefaultWantedNumber) {
    if (wantedNumber <= 0) {
        return [];
    }
    const res = await axios_1.default.get(url, {
        headers: { 'Content-Type': 'application/json' },
    });
    let nodes = res.data;
    for (const prop of path) {
        if (nodes[prop] === undefined) {
            dbg(`Failed to retrieve bootstrap nodes: ${prop} does not exist on `, nodes);
            throw `Failed to retrieve bootstrap nodes: ${prop} does not exist on ${JSON.stringify(nodes)}`;
        }
        nodes = nodes[prop];
    }
    if (Array.isArray(nodes)) {
        return getPseudoRandomSubset(nodes, wantedNumber);
    }
    if (typeof nodes === 'string') {
        return [nodes];
    }
    if (typeof nodes === 'object') {
        nodes = Object.values(nodes);
        return getPseudoRandomSubset(nodes, wantedNumber);
    }
    throw `Failed to retrieve bootstrap nodes: response format is not supported: ${JSON.stringify(nodes)}`;
}
exports.getBootstrapNodes = getBootstrapNodes;
function getPseudoRandomSubset(values, wantedNumber) {
    if (values.length <= wantedNumber) {
        return values;
    }
    return utils_1.shuffle(values).slice(0, wantedNumber);
}
exports.getPseudoRandomSubset = getPseudoRandomSubset;


/***/ }),

/***/ "./src/lib/select_peer.ts":
/*!********************************!*\
  !*** ./src/lib/select_peer.ts ***!
  \********************************/
/***/ ((__unused_webpack_module, exports) => {

"use strict";

Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.getPeersForProtocol = exports.selectRandomPeer = void 0;
/**
 * Returns a pseudo-random peer that supports the given protocol.
 * Useful for protocols such as store and light push
 */
function selectRandomPeer(peers) {
    if (peers.length === 0)
        return;
    const index = Math.round(Math.random() * (peers.length - 1));
    return peers[index];
}
exports.selectRandomPeer = selectRandomPeer;
/**
 * Returns the list of peers that supports the given protocol.
 */
function getPeersForProtocol(libp2p, protocol) {
    return Array.from(libp2p.peerStore.peers.values()).filter((peer) => peer.protocols.includes(protocol));
}
exports.getPeersForProtocol = getPeersForProtocol;


/***/ }),

/***/ "./src/lib/utils.ts":
/*!**************************!*\
  !*** ./src/lib/utils.ts ***!
  \**************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

"use strict";
/* provided dependency */ var Buffer = __webpack_require__(/*! buffer */ "./node_modules/buffer/index.js")["Buffer"];

Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.equalByteArrays = exports.bufToHex = exports.hexToBuf = void 0;
function hexToBuf(hex) {
    if (typeof hex === 'string') {
        return Buffer.from(hex.replace(/^0x/i, ''), 'hex');
    }
    else {
        return Buffer.from(hex);
    }
}
exports.hexToBuf = hexToBuf;
function bufToHex(buf) {
    const _buf = Buffer.from(buf);
    return _buf.toString('hex');
}
exports.bufToHex = bufToHex;
function equalByteArrays(a, b) {
    let aBuf;
    let bBuf;
    if (typeof a === 'string') {
        aBuf = hexToBuf(a);
    }
    else {
        aBuf = Buffer.from(a);
    }
    if (typeof b === 'string') {
        bBuf = hexToBuf(b);
    }
    else {
        bBuf = Buffer.from(b);
    }
    return aBuf.compare(bBuf) === 0;
}
exports.equalByteArrays = equalByteArrays;


/***/ }),

/***/ "./src/lib/waku.ts":
/*!*************************!*\
  !*** ./src/lib/waku.ts ***!
  \*************************/
/***/ (function(__unused_webpack_module, exports, __webpack_require__) {

"use strict";

var __importDefault = (this && this.__importDefault) || function (mod) {
    return (mod && mod.__esModule) ? mod : { "default": mod };
};
Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.Waku = exports.DefaultPubSubTopic = exports.DefaultRelayKeepAliveValueSecs = exports.DefaultPingKeepAliveValueSecs = void 0;
const noise_1 = __webpack_require__(/*! @chainsafe/libp2p-noise/dist/src/noise */ "./node_modules/@chainsafe/libp2p-noise/dist/src/noise.js");
const debug_1 = __importDefault(__webpack_require__(/*! debug */ "./node_modules/debug/src/browser.js"));
const libp2p_1 = __importDefault(__webpack_require__(/*! libp2p */ "./node_modules/libp2p/src/index.js"));
const libp2p_bootstrap_1 = __importDefault(__webpack_require__(/*! libp2p-bootstrap */ "./node_modules/libp2p-bootstrap/src/index.js"));
// eslint-disable-next-line @typescript-eslint/ban-ts-comment
// @ts-ignore: No types available
const libp2p_mplex_1 = __importDefault(__webpack_require__(/*! libp2p-mplex */ "./node_modules/libp2p-mplex/src/index.js"));
// eslint-disable-next-line @typescript-eslint/ban-ts-comment
// @ts-ignore: No types available
const libp2p_websockets_1 = __importDefault(__webpack_require__(/*! libp2p-websockets */ "./node_modules/libp2p-websockets/src/index.js"));
// eslint-disable-next-line @typescript-eslint/ban-ts-comment
// @ts-ignore: No types available
const filters_1 = __importDefault(__webpack_require__(/*! libp2p-websockets/src/filters */ "./node_modules/libp2p-websockets/src/filters.js"));
const ping_1 = __importDefault(__webpack_require__(/*! libp2p/src/ping */ "./node_modules/libp2p/src/ping/index.js"));
const multiaddr_1 = __webpack_require__(/*! multiaddr */ "./node_modules/multiaddr/src/index.js");
const peer_id_1 = __importDefault(__webpack_require__(/*! peer-id */ "./node_modules/peer-id/src/index.js"));
const discovery_1 = __webpack_require__(/*! ./discovery */ "./src/lib/discovery.ts");
const select_peer_1 = __webpack_require__(/*! ./select_peer */ "./src/lib/select_peer.ts");
const waku_light_push_1 = __webpack_require__(/*! ./waku_light_push */ "./src/lib/waku_light_push/index.ts");
const waku_message_1 = __webpack_require__(/*! ./waku_message */ "./src/lib/waku_message/index.ts");
const waku_relay_1 = __webpack_require__(/*! ./waku_relay */ "./src/lib/waku_relay/index.ts");
const constants_1 = __webpack_require__(/*! ./waku_relay/constants */ "./src/lib/waku_relay/constants.ts");
const waku_store_1 = __webpack_require__(/*! ./waku_store */ "./src/lib/waku_store/index.ts");
const websocketsTransportKey = libp2p_websockets_1.default.prototype[Symbol.toStringTag];
exports.DefaultPingKeepAliveValueSecs = 0;
exports.DefaultRelayKeepAliveValueSecs = 5 * 60;
/**
 * DefaultPubSubTopic is the default gossipsub topic to use for Waku.
 */
exports.DefaultPubSubTopic = '/waku/2/default-waku/proto';
const dbg = debug_1.default('waku:waku');
class Waku {
    constructor(options, libp2p, store, lightPush) {
        var _a;
        this.libp2p = libp2p;
        this.relay = libp2p.pubsub;
        this.store = store;
        this.lightPush = lightPush;
        this.pingKeepAliveTimers = {};
        this.relayKeepAliveTimers = {};
        const pingKeepAlive = options.pingKeepAlive || exports.DefaultPingKeepAliveValueSecs;
        const relayKeepAlive = options.relayKeepAlive || exports.DefaultRelayKeepAliveValueSecs;
        libp2p.connectionManager.on('peer:connect', (connection) => {
            this.startKeepAlive(connection.remotePeer, pingKeepAlive, relayKeepAlive);
        });
        libp2p.connectionManager.on('peer:disconnect', (connection) => {
            this.stopKeepAlive(connection.remotePeer);
        });
        (_a = options === null || options === void 0 ? void 0 : options.decryptionKeys) === null || _a === void 0 ? void 0 : _a.forEach(this.addDecryptionKey);
    }
    /**
     * Create new waku node
     *
     * @param options Takes the same options than `Libp2p`.
     */
    static async create(options) {
        var _a, _b, _c;
        // Get an object in case options or libp2p are undefined
        const libp2pOpts = Object.assign({}, options === null || options === void 0 ? void 0 : options.libp2p);
        // Default for Websocket filter is `all`:
        // Returns all TCP and DNS based addresses, both with ws or wss.
        libp2pOpts.config = Object.assign({
            transport: {
                [websocketsTransportKey]: {
                    filter: filters_1.default.all,
                },
            },
        }, (_a = options === null || options === void 0 ? void 0 : options.libp2p) === null || _a === void 0 ? void 0 : _a.config);
        // Pass pubsub topic to relay
        if (options === null || options === void 0 ? void 0 : options.pubSubTopic) {
            libp2pOpts.config.pubsub = Object.assign({ pubSubTopic: options.pubSubTopic }, libp2pOpts.config.pubsub);
        }
        libp2pOpts.modules = Object.assign({}, (_b = options === null || options === void 0 ? void 0 : options.libp2p) === null || _b === void 0 ? void 0 : _b.modules);
        // Default transport for libp2p is Websockets
        libp2pOpts.modules = Object.assign({
            transport: [libp2p_websockets_1.default],
        }, (_c = options === null || options === void 0 ? void 0 : options.libp2p) === null || _c === void 0 ? void 0 : _c.modules);
        // streamMuxer, connection encryption and pubsub are overridden
        // as those are the only ones currently supported by Waku nodes.
        libp2pOpts.modules = Object.assign(libp2pOpts.modules, {
            streamMuxer: [libp2p_mplex_1.default],
            connEncryption: [new noise_1.Noise(options === null || options === void 0 ? void 0 : options.staticNoiseKey)],
            pubsub: waku_relay_1.WakuRelay,
        });
        if (options === null || options === void 0 ? void 0 : options.bootstrap) {
            let bootstrap;
            if (options.bootstrap === true) {
                bootstrap = discovery_1.getBootstrapNodes;
            }
            else if (Array.isArray(options.bootstrap)) {
                bootstrap = () => {
                    return options.bootstrap;
                };
            }
            else if (typeof options.bootstrap === 'function') {
                bootstrap = options.bootstrap;
            }
            if (bootstrap !== undefined) {
                try {
                    const list = await bootstrap();
                    // Note: this overrides any other peer discover
                    libp2pOpts.modules = Object.assign(libp2pOpts.modules, {
                        peerDiscovery: [libp2p_bootstrap_1.default],
                    });
                    libp2pOpts.config.peerDiscovery = {
                        [libp2p_bootstrap_1.default.tag]: {
                            list,
                            enabled: true,
                        },
                    };
                }
                catch (e) {
                    dbg('Failed to retrieve bootstrap nodes', e);
                }
            }
        }
        // eslint-disable-next-line @typescript-eslint/ban-ts-comment
        // @ts-ignore: modules property is correctly set thanks to voodoo
        const libp2p = await libp2p_1.default.create(libp2pOpts);
        const wakuStore = new waku_store_1.WakuStore(libp2p, {
            pubSubTopic: options === null || options === void 0 ? void 0 : options.pubSubTopic,
        });
        const wakuLightPush = new waku_light_push_1.WakuLightPush(libp2p);
        await libp2p.start();
        return new Waku(options ? options : {}, libp2p, wakuStore, wakuLightPush);
    }
    /**
     * Dials to the provided peer.
     *
     * @param peer The peer to dial
     */
    async dial(peer) {
        return this.libp2p.dialProtocol(peer, [waku_store_1.StoreCodec].concat(waku_relay_1.RelayCodecs));
    }
    /**
     * Add peer to address book, it will be auto-dialed in the background.
     */
    addPeerToAddressBook(peerId, multiaddrs) {
        let peer;
        if (typeof peerId === 'string') {
            peer = peer_id_1.default.createFromB58String(peerId);
        }
        else {
            peer = peerId;
        }
        const addresses = multiaddrs.map((addr) => {
            if (typeof addr === 'string') {
                return multiaddr_1.multiaddr(addr);
            }
            else {
                return addr;
            }
        });
        this.libp2p.peerStore.addressBook.set(peer, addresses);
    }
    async stop() {
        return this.libp2p.stop();
    }
    /**
     * Register a decryption key to attempt decryption of messages received via
     * [[WakuRelay]] and [[WakuStore]]. This can either be a private key for
     * asymmetric encryption or a symmetric key.
     *
     * Strings must be in hex format.
     */
    addDecryptionKey(key) {
        this.relay.addDecryptionKey(key);
        this.store.addDecryptionKey(key);
    }
    /**
     * Delete a decryption key that was used to attempt decryption of messages
     * received via [[WakuRelay]] or [[WakuStore]].
     *
     * Strings must be in hex format.
     */
    deleteDecryptionKey(key) {
        this.relay.deleteDecryptionKey(key);
        this.store.deleteDecryptionKey(key);
    }
    /**
     * Return the local multiaddr with peer id on which libp2p is listening.
     * @throws if libp2p is not listening on localhost
     */
    getLocalMultiaddrWithID() {
        const localMultiaddr = this.libp2p.multiaddrs.find((addr) => addr.toString().match(/127\.0\.0\.1/));
        if (!localMultiaddr || localMultiaddr.toString() === '') {
            throw 'Not listening on localhost';
        }
        return localMultiaddr + '/p2p/' + this.libp2p.peerId.toB58String();
    }
    /**
     * Wait to be connected to a peer. Useful when using the [[CreateOptions.bootstrap]]
     * with [[Waku.create]]. The Promise resolves only once we are connected to a
     * Store peer, Relay peer and Light Push peer.
     */
    async waitForConnectedPeer() {
        const desiredProtocols = [[waku_store_1.StoreCodec], [waku_light_push_1.LightPushCodec], waku_relay_1.RelayCodecs];
        await Promise.all(desiredProtocols.map((desiredProtocolVersions) => {
            const peers = new Array();
            desiredProtocolVersions.forEach((proto) => {
                select_peer_1.getPeersForProtocol(this.libp2p, proto).forEach((peer) => peers.push(peer));
            });
            if (peers.length > 0) {
                return Promise.resolve();
            }
            else {
                // No peer available for this protocol, waiting to connect to one.
                return new Promise((resolve) => {
                    this.libp2p.peerStore.on('change:protocols', ({ protocols: connectedPeerProtocols }) => {
                        desiredProtocolVersions.forEach((desiredProto) => {
                            if (connectedPeerProtocols.includes(desiredProto)) {
                                dbg('Resolving for', desiredProto, connectedPeerProtocols);
                                resolve();
                            }
                        });
                    });
                });
            }
        }));
    }
    startKeepAlive(peerId, pingPeriodSecs, relayPeriodSecs) {
        // Just in case a timer already exist for this peer
        this.stopKeepAlive(peerId);
        const peerIdStr = peerId.toB58String();
        if (pingPeriodSecs !== 0) {
            this.pingKeepAliveTimers[peerIdStr] = setInterval(() => {
                ping_1.default(this.libp2p, peerId);
            }, pingPeriodSecs * 1000);
        }
        if (relayPeriodSecs !== 0) {
            this.relayKeepAliveTimers[peerIdStr] = setInterval(() => {
                waku_message_1.WakuMessage.fromBytes(new Uint8Array(), constants_1.RelayPingContentTopic).then((wakuMsg) => this.relay.send(wakuMsg));
            }, relayPeriodSecs * 1000);
        }
    }
    stopKeepAlive(peerId) {
        const peerIdStr = peerId.toB58String();
        if (this.pingKeepAliveTimers[peerIdStr]) {
            clearInterval(this.pingKeepAliveTimers[peerIdStr]);
            delete this.pingKeepAliveTimers[peerIdStr];
        }
        if (this.relayKeepAliveTimers[peerIdStr]) {
            clearInterval(this.relayKeepAliveTimers[peerIdStr]);
            delete this.relayKeepAliveTimers[peerIdStr];
        }
    }
}
exports.Waku = Waku;


/***/ }),

/***/ "./src/lib/waku_light_push/index.ts":
/*!******************************************!*\
  !*** ./src/lib/waku_light_push/index.ts ***!
  \******************************************/
/***/ (function(__unused_webpack_module, exports, __webpack_require__) {

"use strict";

var __importDefault = (this && this.__importDefault) || function (mod) {
    return (mod && mod.__esModule) ? mod : { "default": mod };
};
Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.WakuLightPush = exports.PushResponse = exports.LightPushCodec = void 0;
const it_concat_1 = __importDefault(__webpack_require__(/*! it-concat */ "./node_modules/it-concat/index.js"));
const it_length_prefixed_1 = __importDefault(__webpack_require__(/*! it-length-prefixed */ "./node_modules/it-length-prefixed/src/index.js"));
const it_pipe_1 = __importDefault(__webpack_require__(/*! it-pipe */ "./node_modules/it-pipe/index.js"));
const light_push_1 = __webpack_require__(/*! ../../proto/waku/v2/light_push */ "./src/proto/waku/v2/light_push.ts");
Object.defineProperty(exports, "PushResponse", ({ enumerable: true, get: function () { return light_push_1.PushResponse; } }));
const select_peer_1 = __webpack_require__(/*! ../select_peer */ "./src/lib/select_peer.ts");
const waku_1 = __webpack_require__(/*! ../waku */ "./src/lib/waku.ts");
const push_rpc_1 = __webpack_require__(/*! ./push_rpc */ "./src/lib/waku_light_push/push_rpc.ts");
exports.LightPushCodec = '/vac/waku/lightpush/2.0.0-beta1';
/**
 * Implements the [Waku v2 Light Push protocol](https://rfc.vac.dev/spec/19/).
 */
class WakuLightPush {
    constructor(libp2p, options) {
        this.libp2p = libp2p;
        if (options === null || options === void 0 ? void 0 : options.pubSubTopic) {
            this.pubSubTopic = options.pubSubTopic;
        }
        else {
            this.pubSubTopic = waku_1.DefaultPubSubTopic;
        }
    }
    async push(message, opts) {
        let peer;
        if (opts === null || opts === void 0 ? void 0 : opts.peerId) {
            peer = this.libp2p.peerStore.get(opts.peerId);
            if (!peer)
                throw 'Peer is unknown';
        }
        else {
            peer = this.randomPeer;
        }
        if (!peer)
            throw 'No peer available';
        if (!peer.protocols.includes(exports.LightPushCodec))
            throw 'Peer does not register waku light push protocol';
        const connection = this.libp2p.connectionManager.get(peer.id);
        if (!connection)
            throw 'Failed to get a connection to the peer';
        const { stream } = await connection.newStream(exports.LightPushCodec);
        try {
            const pubSubTopic = (opts === null || opts === void 0 ? void 0 : opts.pubSubTopic)
                ? opts.pubSubTopic
                : this.pubSubTopic;
            const query = push_rpc_1.PushRPC.createRequest(message, pubSubTopic);
            const res = await it_pipe_1.default([query.encode()], it_length_prefixed_1.default.encode(), stream, it_length_prefixed_1.default.decode(), it_concat_1.default);
            try {
                const response = push_rpc_1.PushRPC.decode(res.slice()).response;
                if (!response) {
                    console.log('No response in PushRPC');
                    return null;
                }
                return response;
            }
            catch (err) {
                console.log('Failed to decode push reply', err);
            }
        }
        catch (err) {
            console.log('Failed to send waku light push request', err);
        }
        return null;
    }
    /**
     * Returns known peers from the address book (`libp2p.peerStore`) that support
     * light push protocol. Waku may or  may not be currently connected to these peers.
     */
    get peers() {
        return select_peer_1.getPeersForProtocol(this.libp2p, exports.LightPushCodec);
    }
    /**
     * Returns a random peer that supports light push protocol from the address
     * book (`libp2p.peerStore`). Waku may or  may not be currently connected to
     * this peer.
     */
    get randomPeer() {
        return select_peer_1.selectRandomPeer(this.peers);
    }
}
exports.WakuLightPush = WakuLightPush;


/***/ }),

/***/ "./src/lib/waku_light_push/push_rpc.ts":
/*!*********************************************!*\
  !*** ./src/lib/waku_light_push/push_rpc.ts ***!
  \*********************************************/
/***/ (function(__unused_webpack_module, exports, __webpack_require__) {

"use strict";

var __createBinding = (this && this.__createBinding) || (Object.create ? (function(o, m, k, k2) {
    if (k2 === undefined) k2 = k;
    Object.defineProperty(o, k2, { enumerable: true, get: function() { return m[k]; } });
}) : (function(o, m, k, k2) {
    if (k2 === undefined) k2 = k;
    o[k2] = m[k];
}));
var __setModuleDefault = (this && this.__setModuleDefault) || (Object.create ? (function(o, v) {
    Object.defineProperty(o, "default", { enumerable: true, value: v });
}) : function(o, v) {
    o["default"] = v;
});
var __importStar = (this && this.__importStar) || function (mod) {
    if (mod && mod.__esModule) return mod;
    var result = {};
    if (mod != null) for (var k in mod) if (k !== "default" && Object.prototype.hasOwnProperty.call(mod, k)) __createBinding(result, mod, k);
    __setModuleDefault(result, mod);
    return result;
};
Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.PushRPC = void 0;
const minimal_1 = __webpack_require__(/*! protobufjs/minimal */ "./node_modules/protobufjs/minimal.js");
const uuid_1 = __webpack_require__(/*! uuid */ "./node_modules/uuid/dist/esm-browser/index.js");
const proto = __importStar(__webpack_require__(/*! ../../proto/waku/v2/light_push */ "./src/proto/waku/v2/light_push.ts"));
class PushRPC {
    constructor(proto) {
        this.proto = proto;
    }
    static createRequest(message, pubSubTopic) {
        return new PushRPC({
            requestId: uuid_1.v4(),
            request: {
                message: message.proto,
                pubSubTopic: pubSubTopic,
            },
            response: undefined,
        });
    }
    static decode(bytes) {
        const res = proto.PushRPC.decode(minimal_1.Reader.create(bytes));
        return new PushRPC(res);
    }
    encode() {
        return proto.PushRPC.encode(this.proto).finish();
    }
    get query() {
        return this.proto.request;
    }
    get response() {
        return this.proto.response;
    }
}
exports.PushRPC = PushRPC;


/***/ }),

/***/ "./src/lib/waku_message/index.ts":
/*!***************************************!*\
  !*** ./src/lib/waku_message/index.ts ***!
  \***************************************/
/***/ (function(__unused_webpack_module, exports, __webpack_require__) {

"use strict";

var __createBinding = (this && this.__createBinding) || (Object.create ? (function(o, m, k, k2) {
    if (k2 === undefined) k2 = k;
    Object.defineProperty(o, k2, { enumerable: true, get: function() { return m[k]; } });
}) : (function(o, m, k, k2) {
    if (k2 === undefined) k2 = k;
    o[k2] = m[k];
}));
var __setModuleDefault = (this && this.__setModuleDefault) || (Object.create ? (function(o, v) {
    Object.defineProperty(o, "default", { enumerable: true, value: v });
}) : function(o, v) {
    o["default"] = v;
});
var __importStar = (this && this.__importStar) || function (mod) {
    if (mod && mod.__esModule) return mod;
    var result = {};
    if (mod != null) for (var k in mod) if (k !== "default" && Object.prototype.hasOwnProperty.call(mod, k)) __createBinding(result, mod, k);
    __setModuleDefault(result, mod);
    return result;
};
var __importDefault = (this && this.__importDefault) || function (mod) {
    return (mod && mod.__esModule) ? mod : { "default": mod };
};
Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.WakuMessage = void 0;
// Ensure that this class matches the proto interface while
const buffer_1 = __webpack_require__(/*! buffer */ "./node_modules/buffer/index.js");
const debug_1 = __importDefault(__webpack_require__(/*! debug */ "./node_modules/debug/src/browser.js"));
const minimal_1 = __webpack_require__(/*! protobufjs/minimal */ "./node_modules/protobufjs/minimal.js");
// Protecting the user from protobuf oddities
const proto = __importStar(__webpack_require__(/*! ../../proto/waku/v2/message */ "./src/proto/waku/v2/message.ts"));
const version_1 = __importStar(__webpack_require__(/*! ./version_1 */ "./src/lib/waku_message/version_1.ts"));
const DefaultVersion = 0;
const dbg = debug_1.default('waku:message');
class WakuMessage {
    constructor(proto, _signaturePublicKey, _signature) {
        this.proto = proto;
        this._signaturePublicKey = _signaturePublicKey;
        this._signature = _signature;
    }
    /**
     * Create Message with a utf-8 string as payload.
     */
    static async fromUtf8String(utf8, contentTopic, opts) {
        const payload = buffer_1.Buffer.from(utf8, 'utf-8');
        return WakuMessage.fromBytes(payload, contentTopic, opts);
    }
    /**
     * Create a Waku Message with the given payload.
     *
     * By default, the payload is kept clear (version 0).
     * If `opts.encPublicKey` is passed, the payload is encrypted using
     * asymmetric encryption (version 1).
     *
     * If `opts.sigPrivKey` is passed and version 1 is used, the payload is signed
     * before encryption.
     *
     * @throws if both `opts.encPublicKey` and `opt.symKey` are passed
     */
    static async fromBytes(payload, contentTopic, opts) {
        const { timestamp, encPublicKey, symKey, sigPrivKey } = Object.assign({ timestamp: new Date() }, opts ? opts : {});
        let _payload = payload;
        let version = DefaultVersion;
        let sig;
        if (encPublicKey && symKey) {
            throw 'Pass either `encPublicKey` or `symKey`, not both.';
        }
        if (encPublicKey) {
            const enc = version_1.clearEncode(_payload, sigPrivKey);
            _payload = await version_1.encryptAsymmetric(enc.payload, encPublicKey);
            sig = enc.sig;
            version = 1;
        }
        else if (symKey) {
            const enc = version_1.clearEncode(_payload, sigPrivKey);
            _payload = await version_1.encryptSymmetric(enc.payload, symKey);
            sig = enc.sig;
            version = 1;
        }
        return new WakuMessage({
            payload: _payload,
            timestamp: timestamp.valueOf() / 1000,
            version,
            contentTopic,
        }, sig === null || sig === void 0 ? void 0 : sig.publicKey, sig === null || sig === void 0 ? void 0 : sig.signature);
    }
    /**
     * Decode a byte array into Waku Message.
     *
     * @params bytes The message encoded using protobuf as defined in [14/WAKU2-MESSAGE](https://rfc.vac.dev/spec/14/).
     * @params decryptionKeys If the payload is encrypted (version = 1), then the
     * keys are used to attempt decryption of the message. The passed key can either
     * be asymmetric private keys or symmetric keys, both method are tried for each
     * key until the message is decrypted or combinations are ran out.
     */
    static async decode(bytes, decryptionKeys) {
        const protoBuf = proto.WakuMessage.decode(minimal_1.Reader.create(bytes));
        return WakuMessage.decodeProto(protoBuf, decryptionKeys);
    }
    /**
     * Decode and decrypt Waku Message Protobuf Object into Waku Message.
     *
     * @params protoBuf The message to decode and decrypt.
     * @params decryptionKeys If the payload is encrypted (version = 1), then the
     * keys are used to attempt decryption of the message. The passed key can either
     * be asymmetric private keys or symmetric keys, both method are tried for each
     * key until the message is decrypted or combinations are ran out.
     */
    static async decodeProto(protoBuf, decryptionKeys) {
        var _a, _b;
        if (protoBuf.payload === undefined) {
            dbg('Payload is undefined');
            return;
        }
        const payload = protoBuf.payload;
        let signaturePublicKey;
        let signature;
        if (protoBuf.version === 1 && protoBuf.payload) {
            if (decryptionKeys === undefined) {
                dbg('Payload is encrypted but no private keys have been provided.');
                return;
            }
            // Returns a bunch of `undefined` and hopefully one decrypted result
            const allResults = await Promise.all(decryptionKeys.map(async (privateKey) => {
                try {
                    return await version_1.decryptSymmetric(payload, privateKey);
                }
                catch (e) {
                    dbg('Failed to decrypt message using symmetric encryption', e);
                    try {
                        return await version_1.decryptAsymmetric(payload, privateKey);
                    }
                    catch (e) {
                        dbg('Failed to decrypt message using asymmetric encryption', e);
                        return;
                    }
                }
            }));
            const isDefined = (dec) => {
                return !!dec;
            };
            const decodedResults = allResults.filter(isDefined);
            if (decodedResults.length === 0) {
                dbg('Failed to decrypt payload.');
                return;
            }
            const dec = decodedResults[0];
            const res = await version_1.clearDecode(dec);
            if (!res) {
                dbg('Failed to decode payload.');
                return;
            }
            Object.assign(protoBuf, { payload: res.payload });
            signaturePublicKey = (_a = res.sig) === null || _a === void 0 ? void 0 : _a.publicKey;
            signature = (_b = res.sig) === null || _b === void 0 ? void 0 : _b.signature;
        }
        return new WakuMessage(protoBuf, signaturePublicKey, signature);
    }
    encode() {
        return proto.WakuMessage.encode(this.proto).finish();
    }
    get payloadAsUtf8() {
        if (!this.proto.payload) {
            return '';
        }
        return buffer_1.Buffer.from(this.proto.payload).toString('utf-8');
    }
    get payload() {
        return this.proto.payload;
    }
    get contentTopic() {
        return this.proto.contentTopic;
    }
    get version() {
        return this.proto.version;
    }
    get timestamp() {
        if (this.proto.timestamp) {
            return new Date(this.proto.timestamp * 1000);
        }
        return;
    }
    /**
     * The public key used to sign the message.
     *
     * MAY be present if the message is version 1.
     */
    get signaturePublicKey() {
        return this._signaturePublicKey;
    }
    /**
     * The signature of the message.
     *
     * MAY be present if the message is version 1.
     */
    get signature() {
        return this._signature;
    }
}
exports.WakuMessage = WakuMessage;


/***/ }),

/***/ "./src/lib/waku_message/symmetric/browser.ts":
/*!***************************************************!*\
  !*** ./src/lib/waku_message/symmetric/browser.ts ***!
  \***************************************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

"use strict";
/* provided dependency */ var Buffer = __webpack_require__(/*! buffer */ "./node_modules/buffer/index.js")["Buffer"];

Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.generateIv = exports.decrypt = exports.encrypt = void 0;
const index_1 = __webpack_require__(/*! ./index */ "./src/lib/waku_message/symmetric/index.ts");
const crypto = window.crypto || window.msCrypto;
const subtle = crypto.subtle || crypto.webkitSubtle;
const Algorithm = { name: 'AES-GCM', length: 128 };
if (subtle === undefined) {
    throw new Error('Failed to load Subtle CryptoAPI');
}
async function encrypt(iv, key, clearText) {
    return subtle
        .importKey('raw', key, Algorithm, false, ['encrypt'])
        .then((cryptoKey) => subtle.encrypt(Object.assign({ iv }, Algorithm), cryptoKey, clearText))
        .then(Buffer.from);
}
exports.encrypt = encrypt;
async function decrypt(iv, key, cipherText) {
    return subtle
        .importKey('raw', key, Algorithm, false, ['decrypt'])
        .then((cryptoKey) => subtle.decrypt(Object.assign({ iv }, Algorithm), cryptoKey, cipherText))
        .then(Buffer.from);
}
exports.decrypt = decrypt;
function generateIv() {
    const iv = new Uint8Array(index_1.IvSize);
    crypto.getRandomValues(iv);
    return iv;
}
exports.generateIv = generateIv;


/***/ }),

/***/ "./src/lib/waku_message/symmetric/index.ts":
/*!*************************************************!*\
  !*** ./src/lib/waku_message/symmetric/index.ts ***!
  \*************************************************/
/***/ (function(__unused_webpack_module, exports, __webpack_require__) {

"use strict";

var __createBinding = (this && this.__createBinding) || (Object.create ? (function(o, m, k, k2) {
    if (k2 === undefined) k2 = k;
    Object.defineProperty(o, k2, { enumerable: true, get: function() { return m[k]; } });
}) : (function(o, m, k, k2) {
    if (k2 === undefined) k2 = k;
    o[k2] = m[k];
}));
var __setModuleDefault = (this && this.__setModuleDefault) || (Object.create ? (function(o, v) {
    Object.defineProperty(o, "default", { enumerable: true, value: v });
}) : function(o, v) {
    o["default"] = v;
});
var __importStar = (this && this.__importStar) || function (mod) {
    if (mod && mod.__esModule) return mod;
    var result = {};
    if (mod != null) for (var k in mod) if (k !== "default" && Object.prototype.hasOwnProperty.call(mod, k)) __createBinding(result, mod, k);
    __setModuleDefault(result, mod);
    return result;
};
Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.symmetric = exports.TagSize = exports.IvSize = exports.SymmetricKeySize = void 0;
exports.SymmetricKeySize = 32;
exports.IvSize = 12;
exports.TagSize = 16;
exports.symmetric = {};
Promise.resolve().then(() => __importStar(__webpack_require__(/*! ./browser */ "./src/lib/waku_message/symmetric/browser.ts"))).then((mod) => {
    exports.symmetric = mod;
})
    .catch((eBrowser) => {
    Promise.resolve().then(() => __importStar(__webpack_require__(/*! ./node */ "./src/lib/waku_message/symmetric/node.ts"))).then((mod) => {
        exports.symmetric = mod;
    })
        .catch((eNode) => {
        throw `Could not load any symmetric crypto modules: ${eBrowser}, ${eNode}`;
    });
});


/***/ }),

/***/ "./src/lib/waku_message/symmetric/node.ts":
/*!************************************************!*\
  !*** ./src/lib/waku_message/symmetric/node.ts ***!
  \************************************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

"use strict";
/* provided dependency */ var Buffer = __webpack_require__(/*! buffer */ "./node_modules/buffer/index.js")["Buffer"];

Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.generateIv = exports.decrypt = exports.encrypt = void 0;
const crypto_1 = __webpack_require__(/*! crypto */ "./node_modules/crypto-browserify/index.js");
const index_1 = __webpack_require__(/*! ./index */ "./src/lib/waku_message/symmetric/index.ts");
const Algorithm = 'aes-256-gcm';
async function encrypt(iv, key, clearText) {
    const cipher = crypto_1.createCipheriv(Algorithm, key, iv);
    const a = cipher.update(clearText);
    const b = cipher.final();
    const tag = cipher.getAuthTag();
    return Buffer.concat([a, b, tag]);
}
exports.encrypt = encrypt;
async function decrypt(iv, key, data) {
    const tagStart = data.length - index_1.TagSize;
    const cipherText = data.slice(0, tagStart);
    const tag = data.slice(tagStart);
    const decipher = crypto_1.createDecipheriv(Algorithm, key, iv);
    decipher.setAuthTag(tag);
    const a = decipher.update(cipherText);
    const b = decipher.final();
    return Buffer.concat([a, b]);
}
exports.decrypt = decrypt;
function generateIv() {
    return crypto_1.randomBytes(index_1.IvSize);
}
exports.generateIv = generateIv;


/***/ }),

/***/ "./src/lib/waku_message/version_1.ts":
/*!*******************************************!*\
  !*** ./src/lib/waku_message/version_1.ts ***!
  \*******************************************/
/***/ (function(__unused_webpack_module, exports, __webpack_require__) {

"use strict";

var __createBinding = (this && this.__createBinding) || (Object.create ? (function(o, m, k, k2) {
    if (k2 === undefined) k2 = k;
    Object.defineProperty(o, k2, { enumerable: true, get: function() { return m[k]; } });
}) : (function(o, m, k, k2) {
    if (k2 === undefined) k2 = k;
    o[k2] = m[k];
}));
var __setModuleDefault = (this && this.__setModuleDefault) || (Object.create ? (function(o, v) {
    Object.defineProperty(o, "default", { enumerable: true, value: v });
}) : function(o, v) {
    o["default"] = v;
});
var __importStar = (this && this.__importStar) || function (mod) {
    if (mod && mod.__esModule) return mod;
    var result = {};
    if (mod != null) for (var k in mod) if (k !== "default" && Object.prototype.hasOwnProperty.call(mod, k)) __createBinding(result, mod, k);
    __setModuleDefault(result, mod);
    return result;
};
Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.getPublicKey = exports.generateSymmetricKey = exports.generatePrivateKey = exports.decryptSymmetric = exports.encryptSymmetric = exports.decryptAsymmetric = exports.encryptAsymmetric = exports.clearDecode = exports.clearEncode = exports.PrivateKeySize = void 0;
const buffer_1 = __webpack_require__(/*! buffer */ "./node_modules/buffer/index.js");
const crypto = __importStar(__webpack_require__(/*! crypto */ "./node_modules/crypto-browserify/index.js"));
const ecies = __importStar(__webpack_require__(/*! ecies-geth */ "./node_modules/ecies-geth/dist/lib/src/typescript/browser.js"));
const js_sha3_1 = __webpack_require__(/*! js-sha3 */ "./node_modules/js-sha3/src/sha3.js");
const secp256k1 = __importStar(__webpack_require__(/*! secp256k1 */ "./node_modules/secp256k1/elliptic.js"));
const utils_1 = __webpack_require__(/*! ../utils */ "./src/lib/utils.ts");
const symmetric_1 = __webpack_require__(/*! ./symmetric */ "./src/lib/waku_message/symmetric/index.ts");
const FlagsLength = 1;
const FlagMask = 3; // 0011
const IsSignedMask = 4; // 0100
const PaddingTarget = 256;
const SignatureLength = 65;
exports.PrivateKeySize = 32;
/**
 * Encode the payload pre-encryption.
 *
 * @internal
 * @param messagePayload: The payload to include in the message
 * @param sigPrivKey: If set, a signature using this private key is added.
 * @returns The encoded payload, ready for encryption using {@link encryptAsymmetric}
 * or {@link encryptSymmetric}.
 */
function clearEncode(messagePayload, sigPrivKey) {
    let envelope = buffer_1.Buffer.from([0]); // No flags
    envelope = addPayloadSizeField(envelope, messagePayload);
    envelope = buffer_1.Buffer.concat([envelope, buffer_1.Buffer.from(messagePayload)]);
    // Calculate padding:
    let rawSize = FlagsLength +
        getSizeOfPayloadSizeField(messagePayload) +
        messagePayload.length;
    if (sigPrivKey) {
        rawSize += SignatureLength;
    }
    const remainder = rawSize % PaddingTarget;
    const paddingSize = PaddingTarget - remainder;
    const pad = buffer_1.Buffer.from(randomBytes(paddingSize));
    if (!validateDataIntegrity(pad, paddingSize)) {
        throw new Error('failed to generate random padding of size ' + paddingSize);
    }
    envelope = buffer_1.Buffer.concat([envelope, pad]);
    let sig;
    if (sigPrivKey) {
        envelope[0] |= IsSignedMask;
        const hash = js_sha3_1.keccak256(envelope);
        const s = secp256k1.ecdsaSign(utils_1.hexToBuf(hash), sigPrivKey);
        envelope = buffer_1.Buffer.concat([envelope, s.signature, buffer_1.Buffer.from([s.recid])]);
        sig = {
            signature: buffer_1.Buffer.from(s.signature),
            publicKey: getPublicKey(sigPrivKey),
        };
    }
    return { payload: envelope, sig };
}
exports.clearEncode = clearEncode;
/**
 * Decode a decrypted payload.
 *
 * @internal
 */
function clearDecode(message) {
    const buf = buffer_1.Buffer.from(message);
    let start = 1;
    let sig;
    const sizeOfPayloadSizeField = buf.readUIntLE(0, 1) & FlagMask;
    if (sizeOfPayloadSizeField === 0)
        return;
    const payloadSize = buf.readUIntLE(start, sizeOfPayloadSizeField);
    start += sizeOfPayloadSizeField;
    const payload = buf.slice(start, start + payloadSize);
    const isSigned = (buf.readUIntLE(0, 1) & IsSignedMask) == IsSignedMask;
    if (isSigned) {
        const signature = getSignature(buf);
        const hash = getHash(buf, isSigned);
        const publicKey = ecRecoverPubKey(hash, signature);
        sig = { signature, publicKey };
    }
    return { payload, sig };
}
exports.clearDecode = clearDecode;
/**
 * Proceed with Asymmetric encryption of the data as per [26/WAKU-PAYLOAD](https://rfc.vac.dev/spec/26/).
 * The data MUST be flags | payload-length | payload | [signature].
 * The returned result can be set to `WakuMessage.payload`.
 *
 * @internal
 */
async function encryptAsymmetric(data, publicKey) {
    return ecies.encrypt(utils_1.hexToBuf(publicKey), buffer_1.Buffer.from(data));
}
exports.encryptAsymmetric = encryptAsymmetric;
/**
 * Proceed with Asymmetric decryption of the data as per [26/WAKU-PAYLOAD](https://rfc.vac.dev/spec/26/).
 * The return data is expect to be flags | payload-length | payload | [signature].
 *
 * @internal
 */
async function decryptAsymmetric(payload, privKey) {
    return ecies.decrypt(buffer_1.Buffer.from(privKey), buffer_1.Buffer.from(payload));
}
exports.decryptAsymmetric = decryptAsymmetric;
/**
 * Proceed with Symmetric encryption of the data as per [26/WAKU-PAYLOAD](https://rfc.vac.dev/spec/26/).
 *
 * @param data The data to encrypt, expected to be `flags | payload-length | payload | [signature]`.
 * @param key The key to use for encryption.
 * @returns The decrypted data, `cipherText | tag | iv` and can be set to `WakuMessage.payload`.
 *
 * @internal
 */
async function encryptSymmetric(data, key) {
    const iv = symmetric_1.symmetric.generateIv();
    // Returns `cipher | tag`
    const cipher = await symmetric_1.symmetric.encrypt(iv, utils_1.hexToBuf(key), buffer_1.Buffer.from(data));
    return buffer_1.Buffer.concat([cipher, buffer_1.Buffer.from(iv)]);
}
exports.encryptSymmetric = encryptSymmetric;
/**
 * Proceed with Symmetric decryption of the data as per [26/WAKU-PAYLOAD](https://rfc.vac.dev/spec/26/).
 *
 * @param payload The cipher data, it is expected to be `cipherText | tag | iv`.
 * @param key The key to use for decryption.
 * @returns The decrypted data, expected to be `flags | payload-length | payload | [signature]`.
 *
 * @internal
 */
async function decryptSymmetric(payload, key) {
    const data = buffer_1.Buffer.from(payload);
    const ivStart = data.length - symmetric_1.IvSize;
    const cipher = data.slice(0, ivStart);
    const iv = data.slice(ivStart);
    return symmetric_1.symmetric.decrypt(iv, utils_1.hexToBuf(key), cipher);
}
exports.decryptSymmetric = decryptSymmetric;
/**
 * Generate a new private key to be used for asymmetric encryption.
 *
 * Use {@link getPublicKey} to get the corresponding Public Key.
 */
function generatePrivateKey() {
    return randomBytes(exports.PrivateKeySize);
}
exports.generatePrivateKey = generatePrivateKey;
/**
 * Generate a new symmetric key to be used for symmetric encryption.
 */
function generateSymmetricKey() {
    return randomBytes(symmetric_1.SymmetricKeySize);
}
exports.generateSymmetricKey = generateSymmetricKey;
/**
 * Return the public key for the given private key, to be used for asymmetric
 * encryption.
 */
function getPublicKey(privateKey) {
    return secp256k1.publicKeyCreate(privateKey, false);
}
exports.getPublicKey = getPublicKey;
/**
 * Computes the flags & auxiliary-field as per [26/WAKU-PAYLOAD](https://rfc.vac.dev/spec/26/).
 */
function addPayloadSizeField(msg, payload) {
    const fieldSize = getSizeOfPayloadSizeField(payload);
    let field = buffer_1.Buffer.alloc(4);
    field.writeUInt32LE(payload.length, 0);
    field = field.slice(0, fieldSize);
    msg = buffer_1.Buffer.concat([msg, field]);
    msg[0] |= fieldSize;
    return msg;
}
/**
 * Returns the size of the auxiliary-field which in turns contains the payload size
 */
function getSizeOfPayloadSizeField(payload) {
    let s = 1;
    for (let i = payload.length; i >= 256; i /= 256) {
        s++;
    }
    return s;
}
function validateDataIntegrity(value, expectedSize) {
    if (value.length !== expectedSize) {
        return false;
    }
    return !(expectedSize > 3 && buffer_1.Buffer.from(value).equals(buffer_1.Buffer.alloc(value.length)));
}
function getSignature(message) {
    return message.slice(message.length - SignatureLength, message.length);
}
function getHash(message, isSigned) {
    if (isSigned) {
        return js_sha3_1.keccak256(message.slice(0, message.length - SignatureLength));
    }
    return js_sha3_1.keccak256(message);
}
function ecRecoverPubKey(messageHash, signature) {
    const recovery = signature.slice(64).readIntBE(0, 1);
    return secp256k1.ecdsaRecover(signature.slice(0, 64), recovery, utils_1.hexToBuf(messageHash), false);
}
function randomBytes(length) {
    if (typeof window !== 'undefined' && window && window.crypto) {
        const array = new Uint8Array(length);
        window.crypto.getRandomValues(array);
        return array;
    }
    else {
        return crypto.randomBytes(length);
    }
}


/***/ }),

/***/ "./src/lib/waku_relay/constants.ts":
/*!*****************************************!*\
  !*** ./src/lib/waku_relay/constants.ts ***!
  \*****************************************/
/***/ ((__unused_webpack_module, exports) => {

"use strict";

Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.RelayMaxIHaveLength = exports.RelayOpportunisticGraftPeers = exports.RelayOpportunisticGraftTicks = exports.RelayFanoutTTL = exports.RelayPruneBackoff = exports.RelayPrunePeers = exports.RelayHeartbeatInterval = exports.RelayHeartbeatInitialDelay = exports.RelayGossipFactor = exports.RelayPingContentTopic = exports.RelayCodecs = exports.minute = exports.second = void 0;
exports.second = 1000;
exports.minute = 60 * exports.second;
/**
 * RelayCodec is the libp2p identifier for the waku relay protocol
 */
exports.RelayCodecs = [
    '/vac/waku/relay/2.0.0-beta2',
    '/vac/waku/relay/2.0.0',
];
exports.RelayPingContentTopic = '/relay-ping/1/ping/null';
/**
 * RelayGossipFactor affects how many peers we will emit gossip to at each heartbeat.
 * We will send gossip to RelayGossipFactor * (total number of non-mesh peers), or
 * RelayDlazy, whichever is greater.
 */
exports.RelayGossipFactor = 0.25;
/**
 * GossipsubHeartbeatInitialDelay is the short delay before the heartbeat timer begins
 * after the router is initialized.
 */
exports.RelayHeartbeatInitialDelay = 100;
/**
 * RelayHeartbeatInterval controls the time between heartbeats.
 */
exports.RelayHeartbeatInterval = exports.second;
/**
 * RelayPrunePeers controls the number of peers to include in prune Peer eXchange.
 * When we prune a peer that's eligible for PX (has a good score, etc), we will try to
 * send them signed peer records for up to RelayPrunePeers other peers that we
 * know of.
 */
exports.RelayPrunePeers = 16;
/**
 * RelayPruneBackoff controls the backoff time for pruned peers. This is how long
 * a peer must wait before attempting to graft into our mesh again after being pruned.
 * When pruning a peer, we send them our value of RelayPruneBackoff so they know
 * the minimum time to wait. Peers running older versions may not send a backoff time,
 * so if we receive a prune message without one, we will wait at least RelayPruneBackoff
 * before attempting to re-graft.
 */
exports.RelayPruneBackoff = exports.minute;
/**
 * RelayFanoutTTL controls how long we keep track of the fanout state. If it's been
 * RelayFanoutTTL since we've published to a topic that we're not subscribed to,
 * we'll delete the fanout map for that topic.
 */
exports.RelayFanoutTTL = exports.minute;
/**
 * RelayOpportunisticGraftTicks is the number of heartbeat ticks for attempting to improve the mesh
 * with opportunistic grafting. Every RelayOpportunisticGraftTicks we will attempt to select some
 * high-scoring mesh peers to replace lower-scoring ones, if the median score of our mesh peers falls
 * below a threshold
 */
exports.RelayOpportunisticGraftTicks = 60;
/**
 * RelayOpportunisticGraftPeers is the number of peers to opportunistically graft.
 */
exports.RelayOpportunisticGraftPeers = 2;
/**
 * RelayMaxIHaveLength is the maximum number of messages to include in an IHAVE message.
 * Also controls the maximum number of IHAVE ids we will accept and request with IWANT from a
 * peer within a heartbeat, to protect from IHAVE floods. You should adjust this value from the
 * default if your system is pushing more than 5000 messages in GossipsubHistoryGossip heartbeats;
 * with the defaults this is 1666 messages/s.
 */
exports.RelayMaxIHaveLength = 5000;


/***/ }),

/***/ "./src/lib/waku_relay/get_relay_peers.ts":
/*!***********************************************!*\
  !*** ./src/lib/waku_relay/get_relay_peers.ts ***!
  \***********************************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

"use strict";

Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.getRelayPeers = void 0;
const utils_1 = __webpack_require__(/*! libp2p-gossipsub/src/utils */ "./node_modules/libp2p-gossipsub/src/utils/index.js");
const index_1 = __webpack_require__(/*! ./index */ "./src/lib/waku_relay/index.ts");
/**
 * Given a topic, returns up to count peers subscribed to that topic
 * that pass an optional filter function
 *
 * @param {Gossipsub} router
 * @param {String} topic
 * @param {Number} count
 * @param {Function} [filter] a function to filter acceptable peers
 * @returns {Set<string>}
 *
 */
function getRelayPeers(router, topic, count, filter = () => true) {
    const peersInTopic = router.topics.get(topic);
    if (!peersInTopic) {
        return new Set();
    }
    // Adds all peers using our protocol
    // that also pass the filter function
    let peers = [];
    peersInTopic.forEach((id) => {
        const peerStreams = router.peers.get(id);
        if (!peerStreams) {
            return;
        }
        if (index_1.RelayCodecs.includes(peerStreams.protocol) && filter(id)) {
            peers.push(id);
        }
    });
    // Pseudo-randomly shuffles peers
    peers = utils_1.shuffle(peers);
    if (count > 0 && peers.length > count) {
        peers = peers.slice(0, count);
    }
    return new Set(peers);
}
exports.getRelayPeers = getRelayPeers;


/***/ }),

/***/ "./src/lib/waku_relay/index.ts":
/*!*************************************!*\
  !*** ./src/lib/waku_relay/index.ts ***!
  \*************************************/
/***/ (function(__unused_webpack_module, exports, __webpack_require__) {

"use strict";
/* provided dependency */ var Buffer = __webpack_require__(/*! buffer */ "./node_modules/buffer/index.js")["Buffer"];

var __createBinding = (this && this.__createBinding) || (Object.create ? (function(o, m, k, k2) {
    if (k2 === undefined) k2 = k;
    Object.defineProperty(o, k2, { enumerable: true, get: function() { return m[k]; } });
}) : (function(o, m, k, k2) {
    if (k2 === undefined) k2 = k;
    o[k2] = m[k];
}));
var __setModuleDefault = (this && this.__setModuleDefault) || (Object.create ? (function(o, v) {
    Object.defineProperty(o, "default", { enumerable: true, value: v });
}) : function(o, v) {
    o["default"] = v;
});
var __importStar = (this && this.__importStar) || function (mod) {
    if (mod && mod.__esModule) return mod;
    var result = {};
    if (mod != null) for (var k in mod) if (k !== "default" && Object.prototype.hasOwnProperty.call(mod, k)) __createBinding(result, mod, k);
    __setModuleDefault(result, mod);
    return result;
};
var __importDefault = (this && this.__importDefault) || function (mod) {
    return (mod && mod.__esModule) ? mod : { "default": mod };
};
Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.WakuRelay = exports.RelayCodecs = void 0;
const debug_1 = __importDefault(__webpack_require__(/*! debug */ "./node_modules/debug/src/browser.js"));
const libp2p_gossipsub_1 = __importDefault(__webpack_require__(/*! libp2p-gossipsub */ "./node_modules/libp2p-gossipsub/src/index.js"));
const utils_1 = __webpack_require__(/*! libp2p-gossipsub/src/utils */ "./node_modules/libp2p-gossipsub/src/utils/index.js");
const signature_policy_1 = __webpack_require__(/*! libp2p-interfaces/src/pubsub/signature-policy */ "./node_modules/libp2p-interfaces/src/pubsub/signature-policy.js");
const peer_id_1 = __importDefault(__webpack_require__(/*! peer-id */ "./node_modules/peer-id/src/index.js"));
const utils_2 = __webpack_require__(/*! ../utils */ "./src/lib/utils.ts");
const waku_1 = __webpack_require__(/*! ../waku */ "./src/lib/waku.ts");
const waku_message_1 = __webpack_require__(/*! ../waku_message */ "./src/lib/waku_message/index.ts");
const constants = __importStar(__webpack_require__(/*! ./constants */ "./src/lib/waku_relay/constants.ts"));
const constants_1 = __webpack_require__(/*! ./constants */ "./src/lib/waku_relay/constants.ts");
Object.defineProperty(exports, "RelayCodecs", ({ enumerable: true, get: function () { return constants_1.RelayCodecs; } }));
const get_relay_peers_1 = __webpack_require__(/*! ./get_relay_peers */ "./src/lib/waku_relay/get_relay_peers.ts");
const relay_heartbeat_1 = __webpack_require__(/*! ./relay_heartbeat */ "./src/lib/waku_relay/relay_heartbeat.ts");
const dbg = debug_1.default('waku:relay');
/**
 * Implements the [Waku v2 Relay protocol]{@link https://rfc.vac.dev/spec/11/}.
 * Must be passed as a `pubsub` module to a {Libp2p} instance.
 *
 * @implements {require('libp2p-interfaces/src/pubsub')}
 * @noInheritDoc
 */
class WakuRelay extends libp2p_gossipsub_1.default {
    constructor(libp2p, options) {
        super(libp2p, Object.assign(options, {
            // Ensure that no signature is included nor expected in the messages.
            globalSignaturePolicy: signature_policy_1.SignaturePolicy.StrictNoSign,
        }));
        this.heartbeat = new relay_heartbeat_1.RelayHeartbeat(this);
        this.observers = {};
        this.decryptionKeys = new Set();
        const multicodecs = constants.RelayCodecs;
        Object.assign(this, { multicodecs });
        this.pubSubTopic = (options === null || options === void 0 ? void 0 : options.pubSubTopic) || waku_1.DefaultPubSubTopic;
    }
    /**
     * Mounts the gossipsub protocol onto the libp2p node
     * and subscribes to the default topic.
     *
     * @override
     * @returns {void}
     */
    start() {
        super.start();
        this.subscribe(this.pubSubTopic);
    }
    /**
     * Send Waku message.
     *
     * @param {WakuMessage} message
     * @returns {Promise<void>}
     */
    async send(message) {
        const msg = message.encode();
        await super.publish(this.pubSubTopic, Buffer.from(msg));
    }
    /**
     * Register a decryption key to attempt decryption of received messages.
     * This can either be a private key for asymmetric encryption or a symmetric
     * key. `WakuRelay` will attempt to decrypt messages using both methods.
     *
     * Strings must be in hex format.
     */
    addDecryptionKey(key) {
        this.decryptionKeys.add(utils_2.hexToBuf(key));
    }
    /**
     * Delete a decryption key that was used to attempt decryption of received
     * messages.
     *
     * Strings must be in hex format.
     */
    deleteDecryptionKey(key) {
        this.decryptionKeys.delete(utils_2.hexToBuf(key));
    }
    /**
     * Register an observer of new messages received via waku relay
     *
     * @param callback called when a new message is received via waku relay
     * @param contentTopics Content Topics for which the callback with be called,
     * all of them if undefined, [] or ["",..] is passed.
     * @returns {void}
     */
    addObserver(callback, contentTopics = []) {
        if (contentTopics.length === 0) {
            if (!this.observers['']) {
                this.observers[''] = new Set();
            }
            this.observers[''].add(callback);
        }
        else {
            contentTopics.forEach((contentTopic) => {
                if (!this.observers[contentTopic]) {
                    this.observers[contentTopic] = new Set();
                }
                this.observers[contentTopic].add(callback);
            });
        }
    }
    /**
     * Remove an observer of new messages received via waku relay.
     * Useful to ensure the same observer is not registered several time
     * (e.g when loading React components)
     */
    deleteObserver(callback, contentTopics = []) {
        if (contentTopics.length === 0) {
            if (this.observers['']) {
                this.observers[''].delete(callback);
            }
        }
        else {
            contentTopics.forEach((contentTopic) => {
                if (this.observers[contentTopic]) {
                    this.observers[contentTopic].delete(callback);
                }
            });
        }
    }
    /**
     * Return the relay peers we are connected to and we would publish a message to
     */
    getPeers() {
        return get_relay_peers_1.getRelayPeers(this, this.pubSubTopic, this._options.D, (id) => {
            // Filter peers we would not publish to
            return (this.score.score(id) >= this._options.scoreThresholds.publishThreshold);
        });
    }
    /**
     * Subscribe to a pubsub topic and start emitting Waku messages to observers.
     *
     * @override
     */
    subscribe(pubSubTopic) {
        this.on(pubSubTopic, (event) => {
            dbg(`Message received on ${pubSubTopic}`);
            waku_message_1.WakuMessage.decode(event.data, Array.from(this.decryptionKeys))
                .then((wakuMsg) => {
                if (!wakuMsg) {
                    dbg('Failed to decode Waku Message');
                    return;
                }
                if (this.observers['']) {
                    this.observers[''].forEach((callbackFn) => {
                        callbackFn(wakuMsg);
                    });
                }
                if (wakuMsg.contentTopic) {
                    if (this.observers[wakuMsg.contentTopic]) {
                        this.observers[wakuMsg.contentTopic].forEach((callbackFn) => {
                            callbackFn(wakuMsg);
                        });
                    }
                }
            })
                .catch((e) => {
                dbg('Failed to decode Waku Message', e);
            });
        });
        super.subscribe(pubSubTopic);
    }
    /**
     * Join pubsub topic.
     * This is present to override the behavior of Gossipsub and should not
     * be used by API Consumers
     *
     * @internal
     * @param {string} topic
     * @returns {void}
     * @override
     */
    join(topic) {
        var _a;
        if (!this.started) {
            throw new Error('WakuRelayPubSub has not started');
        }
        const fanoutPeers = this.fanout.get(topic);
        if (fanoutPeers) {
            // these peers have a score above the publish threshold, which may be negative
            // so drop the ones with a negative score
            fanoutPeers.forEach((id) => {
                if (this.score.score(id) < 0) {
                    fanoutPeers.delete(id);
                }
            });
            if (fanoutPeers.size < this._options.D) {
                // we need more peers; eager, as this would get fixed in the next heartbeat
                get_relay_peers_1.getRelayPeers(this, topic, this._options.D - fanoutPeers.size, (id) => {
                    // filter our current peers, direct peers, and peers with negative scores
                    return (!fanoutPeers.has(id) &&
                        !this.direct.has(id) &&
                        this.score.score(id) >= 0);
                }).forEach((id) => fanoutPeers.add(id));
            }
            this.mesh.set(topic, fanoutPeers);
            this.fanout.delete(topic);
            this.lastpub.delete(topic);
        }
        else {
            const peers = get_relay_peers_1.getRelayPeers(this, topic, this._options.D, (id) => {
                // filter direct peers and peers with negative score
                return !this.direct.has(id) && this.score.score(id) >= 0;
            });
            this.mesh.set(topic, peers);
        }
        (_a = this.mesh.get(topic)) === null || _a === void 0 ? void 0 : _a.forEach((id) => {
            this.log('JOIN: Add mesh link to %s in %s', id, topic);
            this._sendGraft(id, topic);
        });
    }
    /**
     * Publish messages.
     * This is present to override the behavior of Gossipsub and should not
     * be used by API Consumers
     *
     * @ignore
     * @override
     * @param {InMessage} msg
     * @returns {void}
     */
    async _publish(msg) {
        if (msg.receivedFrom !== this.peerId.toB58String()) {
            this.score.deliverMessage(msg);
            this.gossipTracer.deliverMessage(msg);
        }
        const msgID = await this.getMsgId(msg);
        const msgIdStr = utils_1.messageIdToString(msgID);
        // put in seen cache
        this.seenCache.put(msgIdStr);
        this.messageCache.put(msg);
        const toSend = new Set();
        msg.topicIDs.forEach((topic) => {
            const peersInTopic = this.topics.get(topic);
            if (!peersInTopic) {
                return;
            }
            // direct peers
            this.direct.forEach((id) => {
                toSend.add(id);
            });
            let meshPeers = this.mesh.get(topic);
            if (!meshPeers || !meshPeers.size) {
                // We are not in the mesh for topic, use fanout peers
                meshPeers = this.fanout.get(topic);
                if (!meshPeers) {
                    // If we are not in the fanout, then pick peers in topic above the publishThreshold
                    const peers = get_relay_peers_1.getRelayPeers(this, topic, this._options.D, (id) => {
                        return (this.score.score(id) >=
                            this._options.scoreThresholds.publishThreshold);
                    });
                    if (peers.size > 0) {
                        meshPeers = peers;
                        this.fanout.set(topic, peers);
                    }
                    else {
                        meshPeers = new Set();
                    }
                }
                // Store the latest publishing time
                this.lastpub.set(topic, this._now());
            }
            meshPeers === null || meshPeers === void 0 ? void 0 : meshPeers.forEach((peer) => {
                toSend.add(peer);
            });
        });
        // Publish messages to peers
        const rpc = utils_1.createGossipRpc([libp2p_gossipsub_1.default.utils.normalizeOutRpcMessage(msg)]);
        toSend.forEach((id) => {
            if (id === msg.from) {
                return;
            }
            this._sendRpc(id, rpc);
        });
    }
    /**
     * Emits gossip to peers in a particular topic.
     *
     * This is present to override the behavior of Gossipsub and should not
     * be used by API Consumers
     *
     * @ignore
     * @override
     * @param {string} topic
     * @param {Set<string>} exclude peers to exclude
     * @returns {void}
     */
    _emitGossip(topic, exclude) {
        const messageIDs = this.messageCache.getGossipIDs(topic);
        if (!messageIDs.length) {
            return;
        }
        // shuffle to emit in random order
        utils_1.shuffle(messageIDs);
        // if we are emitting more than GossipsubMaxIHaveLength ids, truncate the list
        if (messageIDs.length > constants.RelayMaxIHaveLength) {
            // we do the truncation (with shuffling) per peer below
            this.log('too many messages for gossip; will truncate IHAVE list (%d messages)', messageIDs.length);
        }
        // Send gossip to GossipFactor peers above threshold with a minimum of D_lazy
        // First we collect the peers above gossipThreshold that are not in the exclude set
        // and then randomly select from that set
        // We also exclude direct peers, as there is no reason to emit gossip to them
        const peersToGossip = [];
        const topicPeers = this.topics.get(topic);
        if (!topicPeers) {
            // no topic peers, no gossip
            return;
        }
        topicPeers.forEach((id) => {
            const peerStreams = this.peers.get(id);
            if (!peerStreams) {
                return;
            }
            if (!exclude.has(id) &&
                !this.direct.has(id) &&
                constants.RelayCodecs.includes(peerStreams.protocol) &&
                this.score.score(id) >= this._options.scoreThresholds.gossipThreshold) {
                peersToGossip.push(id);
            }
        });
        let target = this._options.Dlazy;
        const factor = constants.RelayGossipFactor * peersToGossip.length;
        if (factor > target) {
            target = factor;
        }
        if (target > peersToGossip.length) {
            target = peersToGossip.length;
        }
        else {
            utils_1.shuffle(peersToGossip);
        }
        // Emit the IHAVE gossip to the selected peers up to the target
        peersToGossip.slice(0, target).forEach((id) => {
            let peerMessageIDs = messageIDs;
            if (messageIDs.length > constants.RelayMaxIHaveLength) {
                // shuffle and slice message IDs per peer so that we emit a different set for each peer
                // we have enough redundancy in the system that this will significantly increase the message
                // coverage when we do truncate
                peerMessageIDs = utils_1.shuffle(peerMessageIDs.slice()).slice(0, constants.RelayMaxIHaveLength);
            }
            this._pushGossip(id, {
                topicID: topic,
                messageIDs: peerMessageIDs,
            });
        });
    }
    /**
     * Make a PRUNE control message for a peer in a topic.
     * This is present to override the behavior of Gossipsub and should not
     * be used by API Consumers
     *
     * @ignore
     * @override
     * @param {string} id
     * @param {string} topic
     * @param {boolean} doPX
     * @returns {RPC.IControlPrune}
     */
    _makePrune(id, topic, doPX) {
        // backoff is measured in seconds
        // RelayPruneBackoff is measured in milliseconds
        const backoff = constants.RelayPruneBackoff / 1000;
        const px = [];
        if (doPX) {
            // select peers for Peer eXchange
            const peers = get_relay_peers_1.getRelayPeers(this, topic, constants.RelayPrunePeers, (xid) => {
                return xid !== id && this.score.score(xid) >= 0;
            });
            peers.forEach((p) => {
                // see if we have a signed record to send back; if we don't, just send
                // the peer ID and let the pruned peer find them in the DHT -- we can't trust
                // unsigned address records through PX anyways
                // Finding signed records in the DHT is not supported at the time of writing in js-libp2p
                const peerId = peer_id_1.default.createFromB58String(p);
                px.push({
                    peerID: peerId.toBytes(),
                    signedPeerRecord: this._libp2p.peerStore.addressBook.getRawEnvelope(peerId),
                });
            });
        }
        return {
            topicID: topic,
            peers: px,
            backoff: backoff,
        };
    }
}
exports.WakuRelay = WakuRelay;


/***/ }),

/***/ "./src/lib/waku_relay/relay_heartbeat.ts":
/*!***********************************************!*\
  !*** ./src/lib/waku_relay/relay_heartbeat.ts ***!
  \***********************************************/
/***/ (function(__unused_webpack_module, exports, __webpack_require__) {

"use strict";

/**
 * @hidden
 * @module
 */
var __createBinding = (this && this.__createBinding) || (Object.create ? (function(o, m, k, k2) {
    if (k2 === undefined) k2 = k;
    Object.defineProperty(o, k2, { enumerable: true, get: function() { return m[k]; } });
}) : (function(o, m, k, k2) {
    if (k2 === undefined) k2 = k;
    o[k2] = m[k];
}));
var __setModuleDefault = (this && this.__setModuleDefault) || (Object.create ? (function(o, v) {
    Object.defineProperty(o, "default", { enumerable: true, value: v });
}) : function(o, v) {
    o["default"] = v;
});
var __importStar = (this && this.__importStar) || function (mod) {
    if (mod && mod.__esModule) return mod;
    var result = {};
    if (mod != null) for (var k in mod) if (k !== "default" && Object.prototype.hasOwnProperty.call(mod, k)) __createBinding(result, mod, k);
    __setModuleDefault(result, mod);
    return result;
};
Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.RelayHeartbeat = void 0;
const heartbeat_1 = __webpack_require__(/*! libp2p-gossipsub/src/heartbeat */ "./node_modules/libp2p-gossipsub/src/heartbeat.js");
const utils_1 = __webpack_require__(/*! libp2p-gossipsub/src/utils */ "./node_modules/libp2p-gossipsub/src/utils/index.js");
const constants = __importStar(__webpack_require__(/*! ./constants */ "./src/lib/waku_relay/constants.ts"));
const get_relay_peers_1 = __webpack_require__(/*! ./get_relay_peers */ "./src/lib/waku_relay/get_relay_peers.ts");
class RelayHeartbeat extends heartbeat_1.Heartbeat {
    /**
     * @param {Object} gossipsub
     * @constructor
     */
    constructor(gossipsub) {
        super(gossipsub);
    }
    start() {
        if (this._heartbeatTimer) {
            return;
        }
        const heartbeat = this._heartbeat.bind(this);
        const timeout = setTimeout(() => {
            var _a;
            heartbeat();
            (_a = this._heartbeatTimer) === null || _a === void 0 ? void 0 : _a.runPeriodically(heartbeat, constants.RelayHeartbeatInterval);
        }, constants.RelayHeartbeatInitialDelay);
        this._heartbeatTimer = {
            _intervalId: undefined,
            runPeriodically: (fn, period) => {
                // this._heartbeatTimer cannot be null, it is being assigned.
                // eslint-disable-next-line @typescript-eslint/no-non-null-assertion
                this._heartbeatTimer._intervalId = setInterval(fn, period);
            },
            cancel: () => {
                var _a;
                clearTimeout(timeout);
                clearInterval((_a = this._heartbeatTimer) === null || _a === void 0 ? void 0 : _a._intervalId);
            },
        };
    }
    /**
     * Unmounts the gossipsub protocol and shuts down every connection
     * @override
     * @returns {void}
     */
    stop() {
        if (!this._heartbeatTimer) {
            return;
        }
        this._heartbeatTimer.cancel();
        this._heartbeatTimer = null;
    }
    /**
     * Maintains the mesh and fanout maps in gossipsub.
     *
     * @returns {void}
     */
    _heartbeat() {
        const { D, Dlo, Dhi, Dscore, Dout } = this.gossipsub._options;
        this.gossipsub.heartbeatTicks++;
        // cache scores through the heartbeat
        const scores = new Map();
        const getScore = (id) => {
            let s = scores.get(id);
            if (s === undefined) {
                s = this.gossipsub.score.score(id);
                scores.set(id, s);
            }
            return s;
        };
        // peer id => topic[]
        const toGraft = new Map();
        // peer id => topic[]
        const toPrune = new Map();
        // peer id => don't px
        const noPX = new Map();
        // clean up expired backoffs
        this.gossipsub._clearBackoff();
        // clean up peerhave/iasked counters
        this.gossipsub.peerhave.clear();
        this.gossipsub.iasked.clear();
        // apply IWANT request penalties
        this.gossipsub._applyIwantPenalties();
        // ensure direct peers are connected
        this.gossipsub._directConnect();
        // maintain the mesh for topics we have joined
        this.gossipsub.mesh.forEach((peers, topic) => {
            // prune/graft helper functions (defined per topic)
            const prunePeer = (id) => {
                this.gossipsub.log('HEARTBEAT: Remove mesh link to %s in %s', id, topic);
                // update peer score
                this.gossipsub.score.prune(id, topic);
                // add prune backoff record
                this.gossipsub._addBackoff(id, topic);
                // remove peer from mesh
                peers.delete(id);
                // add to toPrune
                const topics = toPrune.get(id);
                if (!topics) {
                    toPrune.set(id, [topic]);
                }
                else {
                    topics.push(topic);
                }
            };
            const graftPeer = (id) => {
                this.gossipsub.log('HEARTBEAT: Add mesh link to %s in %s', id, topic);
                // update peer score
                this.gossipsub.score.graft(id, topic);
                // add peer to mesh
                peers.add(id);
                // add to toGraft
                const topics = toGraft.get(id);
                if (!topics) {
                    toGraft.set(id, [topic]);
                }
                else {
                    topics.push(topic);
                }
            };
            // drop all peers with negative score, without PX
            peers.forEach((id) => {
                const score = getScore(id);
                if (score < 0) {
                    this.gossipsub.log('HEARTBEAT: Prune peer %s with negative score: score=%d, topic=%s', id, score, topic);
                    prunePeer(id);
                    noPX.set(id, true);
                }
            });
            // do we have enough peers?
            if (peers.size < Dlo) {
                const backoff = this.gossipsub.backoff.get(topic);
                const ineed = D - peers.size;
                const peersSet = get_relay_peers_1.getRelayPeers(this.gossipsub, topic, ineed, (id) => {
                    // filter out mesh peers, direct peers, peers we are backing off, peers with negative score
                    return (!peers.has(id) &&
                        !this.gossipsub.direct.has(id) &&
                        (!backoff || !backoff.has(id)) &&
                        getScore(id) >= 0);
                });
                peersSet.forEach(graftPeer);
            }
            // do we have to many peers?
            if (peers.size > Dhi) {
                let peersArray = Array.from(peers);
                // sort by score
                peersArray.sort((a, b) => getScore(b) - getScore(a));
                // We keep the first D_score peers by score and the remaining up to D randomly
                // under the constraint that we keep D_out peers in the mesh (if we have that many)
                peersArray = peersArray
                    .slice(0, Dscore)
                    .concat(utils_1.shuffle(peersArray.slice(Dscore)));
                // count the outbound peers we are keeping
                let outbound = 0;
                peersArray.slice(0, D).forEach((p) => {
                    if (this.gossipsub.outbound.get(p)) {
                        outbound++;
                    }
                });
                // if it's less than D_out, bubble up some outbound peers from the random selection
                if (outbound < Dout) {
                    const rotate = (i) => {
                        // rotate the peersArray to the right and put the ith peer in the front
                        const p = peersArray[i];
                        for (let j = i; j > 0; j--) {
                            peersArray[j] = peersArray[j - 1];
                        }
                        peersArray[0] = p;
                    };
                    // first bubble up all outbound peers already in the selection to the front
                    if (outbound > 0) {
                        let ihave = outbound;
                        for (let i = 1; i < D && ihave > 0; i++) {
                            if (this.gossipsub.outbound.get(peersArray[i])) {
                                rotate(i);
                                ihave--;
                            }
                        }
                    }
                    // now bubble up enough outbound peers outside the selection to the front
                    let ineed = D - outbound;
                    for (let i = D; i < peersArray.length && ineed > 0; i++) {
                        if (this.gossipsub.outbound.get(peersArray[i])) {
                            rotate(i);
                            ineed--;
                        }
                    }
                }
                // prune the excess peers
                peersArray.slice(D).forEach(prunePeer);
            }
            // do we have enough outbound peers?
            if (peers.size >= Dlo) {
                // count the outbound peers we have
                let outbound = 0;
                peers.forEach((p) => {
                    if (this.gossipsub.outbound.get(p)) {
                        outbound++;
                    }
                });
                // if it's less than D_out, select some peers with outbound connections and graft them
                if (outbound < Dout) {
                    const ineed = Dout - outbound;
                    const backoff = this.gossipsub.backoff.get(topic);
                    get_relay_peers_1.getRelayPeers(this.gossipsub, topic, ineed, (id) => {
                        // filter our current mesh peers, direct peers, peers we are backing off, peers with negative score
                        return (!peers.has(id) &&
                            !this.gossipsub.direct.has(id) &&
                            (!backoff || !backoff.has(id)) &&
                            getScore(id) >= 0);
                    }).forEach(graftPeer);
                }
            }
            // should we try to improve the mesh with opportunistic grafting?
            if (this.gossipsub.heartbeatTicks %
                constants.RelayOpportunisticGraftTicks ===
                0 &&
                peers.size > 1) {
                // Opportunistic grafting works as follows: we check the median score of peers in the
                // mesh; if this score is below the opportunisticGraftThreshold, we select a few peers at
                // random with score over the median.
                // The intention is to (slowly) improve an under performing mesh by introducing good
                // scoring peers that may have been gossiping at us. This allows us to get out of sticky
                // situations where we are stuck with poor peers and also recover from churn of good peers.
                // now compute the median peer score in the mesh
                const peersList = Array.from(peers).sort((a, b) => getScore(a) - getScore(b));
                const medianIndex = Math.floor(peers.size / 2);
                const medianScore = getScore(peersList[medianIndex]);
                // if the median score is below the threshold, select a better peer (if any) and GRAFT
                if (medianScore <
                    this.gossipsub._options.scoreThresholds.opportunisticGraftThreshold) {
                    const backoff = this.gossipsub.backoff.get(topic);
                    const peersToGraft = get_relay_peers_1.getRelayPeers(this.gossipsub, topic, constants.RelayOpportunisticGraftPeers, (id) => {
                        // filter out current mesh peers, direct peers, peers we are backing off, peers below or at threshold
                        return (peers.has(id) &&
                            !this.gossipsub.direct.has(id) &&
                            (!backoff || !backoff.has(id)) &&
                            getScore(id) > medianScore);
                    });
                    peersToGraft.forEach((id) => {
                        this.gossipsub.log('HEARTBEAT: Opportunistically graft peer %s on topic %s', id, topic);
                        graftPeer(id);
                    });
                }
            }
            // 2nd arg are mesh peers excluded from gossip. We have already pushed
            // messages to them, so its redundant to gossip IHAVEs.
            this.gossipsub._emitGossip(topic, peers);
        });
        // expire fanout for topics we haven't published to in a while
        const now = this.gossipsub._now();
        this.gossipsub.lastpub.forEach((lastpub, topic) => {
            if (lastpub + constants.RelayFanoutTTL < now) {
                this.gossipsub.fanout.delete(topic);
                this.gossipsub.lastpub.delete(topic);
            }
        });
        // maintain our fanout for topics we are publishing but we have not joined
        this.gossipsub.fanout.forEach((fanoutPeers, topic) => {
            // checks whether our peers are still in the topic and have a score above the publish threshold
            const topicPeers = this.gossipsub.topics.get(topic);
            fanoutPeers.forEach((id) => {
                if (!(topicPeers === null || topicPeers === void 0 ? void 0 : topicPeers.has(id)) ||
                    getScore(id) <
                        this.gossipsub._options.scoreThresholds.publishThreshold) {
                    fanoutPeers.delete(id);
                }
            });
            // do we need more peers?
            if (fanoutPeers.size < D) {
                const ineed = D - fanoutPeers.size;
                const peersSet = get_relay_peers_1.getRelayPeers(this.gossipsub, topic, ineed, (id) => {
                    // filter out existing fanout peers, direct peers, and peers with score above the publish threshold
                    return (!fanoutPeers.has(id) &&
                        !this.gossipsub.direct.has(id) &&
                        getScore(id) >=
                            this.gossipsub._options.scoreThresholds.publishThreshold);
                });
                peersSet.forEach((id) => {
                    fanoutPeers.add(id);
                });
            }
            // 2nd arg are fanout peers excluded from gossip.
            // We have already pushed messages to them, so its redundant to gossip IHAVEs
            this.gossipsub._emitGossip(topic, fanoutPeers);
        });
        // send coalesced GRAFT/PRUNE messages (will piggyback gossip)
        this.gossipsub._sendGraftPrune(toGraft, toPrune, noPX);
        // flush pending gossip that wasn't piggybacked above
        this.gossipsub._flush();
        // advance the message history window
        this.gossipsub.messageCache.shift();
        this.gossipsub.emit('gossipsub:heartbeat');
    }
}
exports.RelayHeartbeat = RelayHeartbeat;


/***/ }),

/***/ "./src/lib/waku_store/history_rpc.ts":
/*!*******************************************!*\
  !*** ./src/lib/waku_store/history_rpc.ts ***!
  \*******************************************/
/***/ (function(__unused_webpack_module, exports, __webpack_require__) {

"use strict";

var __createBinding = (this && this.__createBinding) || (Object.create ? (function(o, m, k, k2) {
    if (k2 === undefined) k2 = k;
    Object.defineProperty(o, k2, { enumerable: true, get: function() { return m[k]; } });
}) : (function(o, m, k, k2) {
    if (k2 === undefined) k2 = k;
    o[k2] = m[k];
}));
var __setModuleDefault = (this && this.__setModuleDefault) || (Object.create ? (function(o, v) {
    Object.defineProperty(o, "default", { enumerable: true, value: v });
}) : function(o, v) {
    o["default"] = v;
});
var __importStar = (this && this.__importStar) || function (mod) {
    if (mod && mod.__esModule) return mod;
    var result = {};
    if (mod != null) for (var k in mod) if (k !== "default" && Object.prototype.hasOwnProperty.call(mod, k)) __createBinding(result, mod, k);
    __setModuleDefault(result, mod);
    return result;
};
Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.HistoryRPC = exports.PageDirection = void 0;
const minimal_1 = __webpack_require__(/*! protobufjs/minimal */ "./node_modules/protobufjs/minimal.js");
const uuid_1 = __webpack_require__(/*! uuid */ "./node_modules/uuid/dist/esm-browser/index.js");
const proto = __importStar(__webpack_require__(/*! ../../proto/waku/v2/store */ "./src/proto/waku/v2/store.ts"));
var PageDirection;
(function (PageDirection) {
    PageDirection["BACKWARD"] = "backward";
    PageDirection["FORWARD"] = "forward";
})(PageDirection = exports.PageDirection || (exports.PageDirection = {}));
class HistoryRPC {
    constructor(proto) {
        this.proto = proto;
    }
    /**
     * Create History Query.
     */
    static createQuery(params) {
        const direction = directionToProto(params.pageDirection);
        const pagingInfo = {
            pageSize: params.pageSize,
            cursor: params.cursor,
            direction,
        };
        const contentFilters = params.contentTopics.map((contentTopic) => {
            return { contentTopic };
        });
        return new HistoryRPC({
            requestId: uuid_1.v4(),
            query: {
                pubSubTopic: params.pubSubTopic,
                contentFilters,
                pagingInfo,
                startTime: params.startTime,
                endTime: params.endTime,
            },
            response: undefined,
        });
    }
    static decode(bytes) {
        const res = proto.HistoryRPC.decode(minimal_1.Reader.create(bytes));
        return new HistoryRPC(res);
    }
    encode() {
        return proto.HistoryRPC.encode(this.proto).finish();
    }
    get query() {
        return this.proto.query;
    }
    get response() {
        return this.proto.response;
    }
}
exports.HistoryRPC = HistoryRPC;
function directionToProto(pageDirection) {
    switch (pageDirection) {
        case PageDirection.BACKWARD:
            return proto.PagingInfo_Direction.DIRECTION_BACKWARD_UNSPECIFIED;
        case PageDirection.FORWARD:
            return proto.PagingInfo_Direction.DIRECTION_FORWARD;
        default:
            return proto.PagingInfo_Direction.DIRECTION_BACKWARD_UNSPECIFIED;
    }
}


/***/ }),

/***/ "./src/lib/waku_store/index.ts":
/*!*************************************!*\
  !*** ./src/lib/waku_store/index.ts ***!
  \*************************************/
/***/ (function(__unused_webpack_module, exports, __webpack_require__) {

"use strict";

var __importDefault = (this && this.__importDefault) || function (mod) {
    return (mod && mod.__esModule) ? mod : { "default": mod };
};
Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.WakuStore = exports.PageDirection = exports.DefaultPageSize = exports.StoreCodec = void 0;
const debug_1 = __importDefault(__webpack_require__(/*! debug */ "./node_modules/debug/src/browser.js"));
const it_concat_1 = __importDefault(__webpack_require__(/*! it-concat */ "./node_modules/it-concat/index.js"));
const it_length_prefixed_1 = __importDefault(__webpack_require__(/*! it-length-prefixed */ "./node_modules/it-length-prefixed/src/index.js"));
const it_pipe_1 = __importDefault(__webpack_require__(/*! it-pipe */ "./node_modules/it-pipe/index.js"));
const store_1 = __webpack_require__(/*! ../../proto/waku/v2/store */ "./src/proto/waku/v2/store.ts");
const select_peer_1 = __webpack_require__(/*! ../select_peer */ "./src/lib/select_peer.ts");
const utils_1 = __webpack_require__(/*! ../utils */ "./src/lib/utils.ts");
const waku_1 = __webpack_require__(/*! ../waku */ "./src/lib/waku.ts");
const waku_message_1 = __webpack_require__(/*! ../waku_message */ "./src/lib/waku_message/index.ts");
const history_rpc_1 = __webpack_require__(/*! ./history_rpc */ "./src/lib/waku_store/history_rpc.ts");
Object.defineProperty(exports, "PageDirection", ({ enumerable: true, get: function () { return history_rpc_1.PageDirection; } }));
const dbg = debug_1.default('waku:store');
exports.StoreCodec = '/vac/waku/store/2.0.0-beta3';
exports.DefaultPageSize = 10;
/**
 * Implements the [Waku v2 Store protocol](https://rfc.vac.dev/spec/13/).
 */
class WakuStore {
    constructor(libp2p, options) {
        this.libp2p = libp2p;
        if (options === null || options === void 0 ? void 0 : options.pubSubTopic) {
            this.pubSubTopic = options.pubSubTopic;
        }
        else {
            this.pubSubTopic = waku_1.DefaultPubSubTopic;
        }
        this.decryptionKeys = new Set();
    }
    /**
     * Do a History Query to a Waku Store.
     *
     * @param contentTopics The content topics to pass to the query, leave empty to
     * retrieve all messages.
     *
     * @throws If not able to reach a Waku Store peer to query
     * or if an error is encountered when processing the reply.
     */
    async queryHistory(contentTopics, options) {
        var _a, _b, _c, _d;
        let startTime, endTime;
        if (options === null || options === void 0 ? void 0 : options.timeFilter) {
            startTime = options.timeFilter.startTime.getTime() / 1000;
            endTime = options.timeFilter.endTime.getTime() / 1000;
        }
        const opts = Object.assign({
            pubSubTopic: this.pubSubTopic,
            pageDirection: history_rpc_1.PageDirection.BACKWARD,
            pageSize: exports.DefaultPageSize,
        }, options, {
            startTime,
            endTime,
        }, { contentTopics });
        dbg('Querying history with the following options', options);
        let peer;
        if (opts.peerId) {
            peer = this.libp2p.peerStore.get(opts.peerId);
            if (!peer)
                throw `Failed to retrieve connection details for provided peer in peer store: ${opts.peerId.toB58String()}`;
        }
        else {
            peer = this.randomPeer;
            if (!peer)
                throw 'Failed to find known peer that registers waku store protocol';
        }
        if (!peer.protocols.includes(exports.StoreCodec))
            throw `Peer does not register waku store protocol: ${peer.id.toB58String()}`;
        const connection = this.libp2p.connectionManager.get(peer.id);
        if (!connection)
            throw 'Failed to get a connection to the peer';
        const decryptionKeys = Array.from(this.decryptionKeys.values());
        if (opts.decryptionKeys) {
            opts.decryptionKeys.forEach((key) => {
                decryptionKeys.push(utils_1.hexToBuf(key));
            });
        }
        const messages = [];
        let cursor = undefined;
        while (true) {
            const { stream } = await connection.newStream(exports.StoreCodec);
            const queryOpts = Object.assign(opts, { cursor });
            const historyRpcQuery = history_rpc_1.HistoryRPC.createQuery(queryOpts);
            dbg('Querying store peer', connection.remoteAddr.toString());
            const res = await it_pipe_1.default([historyRpcQuery.encode()], it_length_prefixed_1.default.encode(), stream, it_length_prefixed_1.default.decode(), it_concat_1.default);
            const reply = history_rpc_1.HistoryRPC.decode(res.slice());
            const response = reply.response;
            if (!response) {
                throw 'History response misses response field';
            }
            if (response.error &&
                response.error === store_1.HistoryResponse_Error.ERROR_INVALID_CURSOR) {
                throw 'History response contains an Error: INVALID CURSOR';
            }
            if (!response.messages || !response.messages.length) {
                // No messages left (or stored)
                console.log('No messages present in HistoryRPC response');
                return messages;
            }
            dbg(`${response.messages.length} messages retrieved for pubsub topic ${opts.pubSubTopic}`);
            const pageMessages = [];
            await Promise.all(response.messages.map(async (protoMsg) => {
                const msg = await waku_message_1.WakuMessage.decodeProto(protoMsg, decryptionKeys);
                if (msg) {
                    messages.push(msg);
                    pageMessages.push(msg);
                }
            }));
            let abort = false;
            if (opts.callback) {
                abort = Boolean(opts.callback(pageMessages));
            }
            const responsePageSize = (_a = response.pagingInfo) === null || _a === void 0 ? void 0 : _a.pageSize;
            const queryPageSize = (_c = (_b = historyRpcQuery.query) === null || _b === void 0 ? void 0 : _b.pagingInfo) === null || _c === void 0 ? void 0 : _c.pageSize;
            if (abort ||
                // Response page size smaller than query, meaning this is the last page
                (responsePageSize && queryPageSize && responsePageSize < queryPageSize)) {
                return messages;
            }
            cursor = (_d = response.pagingInfo) === null || _d === void 0 ? void 0 : _d.cursor;
            if (cursor === undefined) {
                // If the server does not return cursor then there is an issue,
                // Need to abort or we end up in an infinite loop
                console.log('No cursor returned by peer.');
                return messages;
            }
        }
    }
    /**
     * Register a decryption key to attempt decryption of messages received in any
     * subsequent [[queryHistory]] call. This can either be a private key for
     * asymmetric encryption or a symmetric key. [[WakuStore]] will attempt to
     * decrypt messages using both methods.
     *
     * Strings must be in hex format.
     */
    addDecryptionKey(key) {
        this.decryptionKeys.add(utils_1.hexToBuf(key));
    }
    /**
     * Delete a decryption key that was used to attempt decryption of messages
     * received in subsequent [[queryHistory]] calls.
     *
     * Strings must be in hex format.
     */
    deleteDecryptionKey(key) {
        this.decryptionKeys.delete(utils_1.hexToBuf(key));
    }
    /**
     * Returns known peers from the address book (`libp2p.peerStore`) that support
     * store protocol. Waku may or  may not be currently connected to these peers.
     */
    get peers() {
        return select_peer_1.getPeersForProtocol(this.libp2p, exports.StoreCodec);
    }
    /**
     * Returns a random peer that supports store protocol from the address
     * book (`libp2p.peerStore`). Waku may or  may not be currently connected to
     * this peer.
     */
    get randomPeer() {
        return select_peer_1.selectRandomPeer(this.peers);
    }
}
exports.WakuStore = WakuStore;


/***/ }),

/***/ "./src/proto/index.ts":
/*!****************************!*\
  !*** ./src/proto/index.ts ***!
  \****************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

"use strict";

Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.HistoryRPC = exports.HistoryResponse = exports.HistoryQuery = exports.ContentFilter = exports.PagingInfo_Direction = exports.PagingInfo = exports.Index = exports.WakuMessage = void 0;
var message_1 = __webpack_require__(/*! ./waku/v2/message */ "./src/proto/waku/v2/message.ts");
Object.defineProperty(exports, "WakuMessage", ({ enumerable: true, get: function () { return message_1.WakuMessage; } }));
var store_1 = __webpack_require__(/*! ./waku/v2/store */ "./src/proto/waku/v2/store.ts");
Object.defineProperty(exports, "Index", ({ enumerable: true, get: function () { return store_1.Index; } }));
Object.defineProperty(exports, "PagingInfo", ({ enumerable: true, get: function () { return store_1.PagingInfo; } }));
Object.defineProperty(exports, "PagingInfo_Direction", ({ enumerable: true, get: function () { return store_1.PagingInfo_Direction; } }));
Object.defineProperty(exports, "ContentFilter", ({ enumerable: true, get: function () { return store_1.ContentFilter; } }));
Object.defineProperty(exports, "HistoryQuery", ({ enumerable: true, get: function () { return store_1.HistoryQuery; } }));
Object.defineProperty(exports, "HistoryResponse", ({ enumerable: true, get: function () { return store_1.HistoryResponse; } }));
Object.defineProperty(exports, "HistoryRPC", ({ enumerable: true, get: function () { return store_1.HistoryRPC; } }));


/***/ }),

/***/ "./src/proto/waku/v2/light_push.ts":
/*!*****************************************!*\
  !*** ./src/proto/waku/v2/light_push.ts ***!
  \*****************************************/
/***/ (function(__unused_webpack_module, exports, __webpack_require__) {

"use strict";

var __importDefault = (this && this.__importDefault) || function (mod) {
    return (mod && mod.__esModule) ? mod : { "default": mod };
};
Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.PushRPC = exports.PushResponse = exports.PushRequest = exports.protobufPackage = void 0;
/* eslint-disable */
const long_1 = __importDefault(__webpack_require__(/*! long */ "./node_modules/long/src/long.js"));
const minimal_1 = __importDefault(__webpack_require__(/*! protobufjs/minimal */ "./node_modules/protobufjs/minimal.js"));
const message_1 = __webpack_require__(/*! ../../waku/v2/message */ "./src/proto/waku/v2/message.ts");
exports.protobufPackage = 'waku.v2';
const basePushRequest = { pubSubTopic: '' };
exports.PushRequest = {
    encode(message, writer = minimal_1.default.Writer.create()) {
        if (message.pubSubTopic !== '') {
            writer.uint32(10).string(message.pubSubTopic);
        }
        if (message.message !== undefined) {
            message_1.WakuMessage.encode(message.message, writer.uint32(18).fork()).ldelim();
        }
        return writer;
    },
    decode(input, length) {
        const reader = input instanceof minimal_1.default.Reader ? input : new minimal_1.default.Reader(input);
        let end = length === undefined ? reader.len : reader.pos + length;
        const message = Object.assign({}, basePushRequest);
        while (reader.pos < end) {
            const tag = reader.uint32();
            switch (tag >>> 3) {
                case 1:
                    message.pubSubTopic = reader.string();
                    break;
                case 2:
                    message.message = message_1.WakuMessage.decode(reader, reader.uint32());
                    break;
                default:
                    reader.skipType(tag & 7);
                    break;
            }
        }
        return message;
    },
    fromJSON(object) {
        const message = Object.assign({}, basePushRequest);
        if (object.pubSubTopic !== undefined && object.pubSubTopic !== null) {
            message.pubSubTopic = String(object.pubSubTopic);
        }
        else {
            message.pubSubTopic = '';
        }
        if (object.message !== undefined && object.message !== null) {
            message.message = message_1.WakuMessage.fromJSON(object.message);
        }
        else {
            message.message = undefined;
        }
        return message;
    },
    toJSON(message) {
        const obj = {};
        message.pubSubTopic !== undefined &&
            (obj.pubSubTopic = message.pubSubTopic);
        message.message !== undefined &&
            (obj.message = message.message
                ? message_1.WakuMessage.toJSON(message.message)
                : undefined);
        return obj;
    },
    fromPartial(object) {
        const message = Object.assign({}, basePushRequest);
        if (object.pubSubTopic !== undefined && object.pubSubTopic !== null) {
            message.pubSubTopic = object.pubSubTopic;
        }
        else {
            message.pubSubTopic = '';
        }
        if (object.message !== undefined && object.message !== null) {
            message.message = message_1.WakuMessage.fromPartial(object.message);
        }
        else {
            message.message = undefined;
        }
        return message;
    },
};
const basePushResponse = { isSuccess: false, info: '' };
exports.PushResponse = {
    encode(message, writer = minimal_1.default.Writer.create()) {
        if (message.isSuccess === true) {
            writer.uint32(8).bool(message.isSuccess);
        }
        if (message.info !== '') {
            writer.uint32(18).string(message.info);
        }
        return writer;
    },
    decode(input, length) {
        const reader = input instanceof minimal_1.default.Reader ? input : new minimal_1.default.Reader(input);
        let end = length === undefined ? reader.len : reader.pos + length;
        const message = Object.assign({}, basePushResponse);
        while (reader.pos < end) {
            const tag = reader.uint32();
            switch (tag >>> 3) {
                case 1:
                    message.isSuccess = reader.bool();
                    break;
                case 2:
                    message.info = reader.string();
                    break;
                default:
                    reader.skipType(tag & 7);
                    break;
            }
        }
        return message;
    },
    fromJSON(object) {
        const message = Object.assign({}, basePushResponse);
        if (object.isSuccess !== undefined && object.isSuccess !== null) {
            message.isSuccess = Boolean(object.isSuccess);
        }
        else {
            message.isSuccess = false;
        }
        if (object.info !== undefined && object.info !== null) {
            message.info = String(object.info);
        }
        else {
            message.info = '';
        }
        return message;
    },
    toJSON(message) {
        const obj = {};
        message.isSuccess !== undefined && (obj.isSuccess = message.isSuccess);
        message.info !== undefined && (obj.info = message.info);
        return obj;
    },
    fromPartial(object) {
        const message = Object.assign({}, basePushResponse);
        if (object.isSuccess !== undefined && object.isSuccess !== null) {
            message.isSuccess = object.isSuccess;
        }
        else {
            message.isSuccess = false;
        }
        if (object.info !== undefined && object.info !== null) {
            message.info = object.info;
        }
        else {
            message.info = '';
        }
        return message;
    },
};
const basePushRPC = { requestId: '' };
exports.PushRPC = {
    encode(message, writer = minimal_1.default.Writer.create()) {
        if (message.requestId !== '') {
            writer.uint32(10).string(message.requestId);
        }
        if (message.request !== undefined) {
            exports.PushRequest.encode(message.request, writer.uint32(18).fork()).ldelim();
        }
        if (message.response !== undefined) {
            exports.PushResponse.encode(message.response, writer.uint32(26).fork()).ldelim();
        }
        return writer;
    },
    decode(input, length) {
        const reader = input instanceof minimal_1.default.Reader ? input : new minimal_1.default.Reader(input);
        let end = length === undefined ? reader.len : reader.pos + length;
        const message = Object.assign({}, basePushRPC);
        while (reader.pos < end) {
            const tag = reader.uint32();
            switch (tag >>> 3) {
                case 1:
                    message.requestId = reader.string();
                    break;
                case 2:
                    message.request = exports.PushRequest.decode(reader, reader.uint32());
                    break;
                case 3:
                    message.response = exports.PushResponse.decode(reader, reader.uint32());
                    break;
                default:
                    reader.skipType(tag & 7);
                    break;
            }
        }
        return message;
    },
    fromJSON(object) {
        const message = Object.assign({}, basePushRPC);
        if (object.requestId !== undefined && object.requestId !== null) {
            message.requestId = String(object.requestId);
        }
        else {
            message.requestId = '';
        }
        if (object.request !== undefined && object.request !== null) {
            message.request = exports.PushRequest.fromJSON(object.request);
        }
        else {
            message.request = undefined;
        }
        if (object.response !== undefined && object.response !== null) {
            message.response = exports.PushResponse.fromJSON(object.response);
        }
        else {
            message.response = undefined;
        }
        return message;
    },
    toJSON(message) {
        const obj = {};
        message.requestId !== undefined && (obj.requestId = message.requestId);
        message.request !== undefined &&
            (obj.request = message.request
                ? exports.PushRequest.toJSON(message.request)
                : undefined);
        message.response !== undefined &&
            (obj.response = message.response
                ? exports.PushResponse.toJSON(message.response)
                : undefined);
        return obj;
    },
    fromPartial(object) {
        const message = Object.assign({}, basePushRPC);
        if (object.requestId !== undefined && object.requestId !== null) {
            message.requestId = object.requestId;
        }
        else {
            message.requestId = '';
        }
        if (object.request !== undefined && object.request !== null) {
            message.request = exports.PushRequest.fromPartial(object.request);
        }
        else {
            message.request = undefined;
        }
        if (object.response !== undefined && object.response !== null) {
            message.response = exports.PushResponse.fromPartial(object.response);
        }
        else {
            message.response = undefined;
        }
        return message;
    },
};
if (minimal_1.default.util.Long !== long_1.default) {
    minimal_1.default.util.Long = long_1.default;
    minimal_1.default.configure();
}


/***/ }),

/***/ "./src/proto/waku/v2/message.ts":
/*!**************************************!*\
  !*** ./src/proto/waku/v2/message.ts ***!
  \**************************************/
/***/ (function(__unused_webpack_module, exports, __webpack_require__) {

"use strict";

var __importDefault = (this && this.__importDefault) || function (mod) {
    return (mod && mod.__esModule) ? mod : { "default": mod };
};
Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.WakuMessage = exports.protobufPackage = void 0;
/* eslint-disable */
const long_1 = __importDefault(__webpack_require__(/*! long */ "./node_modules/long/src/long.js"));
const minimal_1 = __importDefault(__webpack_require__(/*! protobufjs/minimal */ "./node_modules/protobufjs/minimal.js"));
exports.protobufPackage = 'waku.v2';
const baseWakuMessage = {};
exports.WakuMessage = {
    encode(message, writer = minimal_1.default.Writer.create()) {
        if (message.payload !== undefined) {
            writer.uint32(10).bytes(message.payload);
        }
        if (message.contentTopic !== undefined) {
            writer.uint32(18).string(message.contentTopic);
        }
        if (message.version !== undefined) {
            writer.uint32(24).uint32(message.version);
        }
        if (message.timestamp !== undefined) {
            writer.uint32(33).double(message.timestamp);
        }
        return writer;
    },
    decode(input, length) {
        const reader = input instanceof minimal_1.default.Reader ? input : new minimal_1.default.Reader(input);
        let end = length === undefined ? reader.len : reader.pos + length;
        const message = Object.assign({}, baseWakuMessage);
        while (reader.pos < end) {
            const tag = reader.uint32();
            switch (tag >>> 3) {
                case 1:
                    message.payload = reader.bytes();
                    break;
                case 2:
                    message.contentTopic = reader.string();
                    break;
                case 3:
                    message.version = reader.uint32();
                    break;
                case 4:
                    message.timestamp = reader.double();
                    break;
                default:
                    reader.skipType(tag & 7);
                    break;
            }
        }
        return message;
    },
    fromJSON(object) {
        const message = Object.assign({}, baseWakuMessage);
        if (object.payload !== undefined && object.payload !== null) {
            message.payload = bytesFromBase64(object.payload);
        }
        if (object.contentTopic !== undefined && object.contentTopic !== null) {
            message.contentTopic = String(object.contentTopic);
        }
        else {
            message.contentTopic = undefined;
        }
        if (object.version !== undefined && object.version !== null) {
            message.version = Number(object.version);
        }
        else {
            message.version = undefined;
        }
        if (object.timestamp !== undefined && object.timestamp !== null) {
            message.timestamp = Number(object.timestamp);
        }
        else {
            message.timestamp = undefined;
        }
        return message;
    },
    toJSON(message) {
        const obj = {};
        message.payload !== undefined &&
            (obj.payload =
                message.payload !== undefined
                    ? base64FromBytes(message.payload)
                    : undefined);
        message.contentTopic !== undefined &&
            (obj.contentTopic = message.contentTopic);
        message.version !== undefined && (obj.version = message.version);
        message.timestamp !== undefined && (obj.timestamp = message.timestamp);
        return obj;
    },
    fromPartial(object) {
        const message = Object.assign({}, baseWakuMessage);
        if (object.payload !== undefined && object.payload !== null) {
            message.payload = object.payload;
        }
        else {
            message.payload = undefined;
        }
        if (object.contentTopic !== undefined && object.contentTopic !== null) {
            message.contentTopic = object.contentTopic;
        }
        else {
            message.contentTopic = undefined;
        }
        if (object.version !== undefined && object.version !== null) {
            message.version = object.version;
        }
        else {
            message.version = undefined;
        }
        if (object.timestamp !== undefined && object.timestamp !== null) {
            message.timestamp = object.timestamp;
        }
        else {
            message.timestamp = undefined;
        }
        return message;
    },
};
var globalThis = (() => {
    if (typeof globalThis !== 'undefined')
        return globalThis;
    if (typeof self !== 'undefined')
        return self;
    if (typeof window !== 'undefined')
        return window;
    if (typeof __webpack_require__.g !== 'undefined')
        return __webpack_require__.g;
    throw 'Unable to locate global object';
})();
const atob = globalThis.atob ||
    ((b64) => globalThis.Buffer.from(b64, 'base64').toString('binary'));
function bytesFromBase64(b64) {
    const bin = atob(b64);
    const arr = new Uint8Array(bin.length);
    for (let i = 0; i < bin.length; ++i) {
        arr[i] = bin.charCodeAt(i);
    }
    return arr;
}
const btoa = globalThis.btoa ||
    ((bin) => globalThis.Buffer.from(bin, 'binary').toString('base64'));
function base64FromBytes(arr) {
    const bin = [];
    for (const byte of arr) {
        bin.push(String.fromCharCode(byte));
    }
    return btoa(bin.join(''));
}
if (minimal_1.default.util.Long !== long_1.default) {
    minimal_1.default.util.Long = long_1.default;
    minimal_1.default.configure();
}


/***/ }),

/***/ "./src/proto/waku/v2/store.ts":
/*!************************************!*\
  !*** ./src/proto/waku/v2/store.ts ***!
  \************************************/
/***/ (function(__unused_webpack_module, exports, __webpack_require__) {

"use strict";

var __importDefault = (this && this.__importDefault) || function (mod) {
    return (mod && mod.__esModule) ? mod : { "default": mod };
};
Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.HistoryRPC = exports.HistoryResponse = exports.HistoryQuery = exports.ContentFilter = exports.PagingInfo = exports.Index = exports.historyResponse_ErrorToJSON = exports.historyResponse_ErrorFromJSON = exports.HistoryResponse_Error = exports.pagingInfo_DirectionToJSON = exports.pagingInfo_DirectionFromJSON = exports.PagingInfo_Direction = exports.protobufPackage = void 0;
/* eslint-disable */
const long_1 = __importDefault(__webpack_require__(/*! long */ "./node_modules/long/src/long.js"));
const minimal_1 = __importDefault(__webpack_require__(/*! protobufjs/minimal */ "./node_modules/protobufjs/minimal.js"));
const message_1 = __webpack_require__(/*! ../../waku/v2/message */ "./src/proto/waku/v2/message.ts");
exports.protobufPackage = 'waku.v2';
var PagingInfo_Direction;
(function (PagingInfo_Direction) {
    PagingInfo_Direction[PagingInfo_Direction["DIRECTION_BACKWARD_UNSPECIFIED"] = 0] = "DIRECTION_BACKWARD_UNSPECIFIED";
    PagingInfo_Direction[PagingInfo_Direction["DIRECTION_FORWARD"] = 1] = "DIRECTION_FORWARD";
    PagingInfo_Direction[PagingInfo_Direction["UNRECOGNIZED"] = -1] = "UNRECOGNIZED";
})(PagingInfo_Direction = exports.PagingInfo_Direction || (exports.PagingInfo_Direction = {}));
function pagingInfo_DirectionFromJSON(object) {
    switch (object) {
        case 0:
        case 'DIRECTION_BACKWARD_UNSPECIFIED':
            return PagingInfo_Direction.DIRECTION_BACKWARD_UNSPECIFIED;
        case 1:
        case 'DIRECTION_FORWARD':
            return PagingInfo_Direction.DIRECTION_FORWARD;
        case -1:
        case 'UNRECOGNIZED':
        default:
            return PagingInfo_Direction.UNRECOGNIZED;
    }
}
exports.pagingInfo_DirectionFromJSON = pagingInfo_DirectionFromJSON;
function pagingInfo_DirectionToJSON(object) {
    switch (object) {
        case PagingInfo_Direction.DIRECTION_BACKWARD_UNSPECIFIED:
            return 'DIRECTION_BACKWARD_UNSPECIFIED';
        case PagingInfo_Direction.DIRECTION_FORWARD:
            return 'DIRECTION_FORWARD';
        default:
            return 'UNKNOWN';
    }
}
exports.pagingInfo_DirectionToJSON = pagingInfo_DirectionToJSON;
var HistoryResponse_Error;
(function (HistoryResponse_Error) {
    HistoryResponse_Error[HistoryResponse_Error["ERROR_NONE_UNSPECIFIED"] = 0] = "ERROR_NONE_UNSPECIFIED";
    HistoryResponse_Error[HistoryResponse_Error["ERROR_INVALID_CURSOR"] = 1] = "ERROR_INVALID_CURSOR";
    HistoryResponse_Error[HistoryResponse_Error["UNRECOGNIZED"] = -1] = "UNRECOGNIZED";
})(HistoryResponse_Error = exports.HistoryResponse_Error || (exports.HistoryResponse_Error = {}));
function historyResponse_ErrorFromJSON(object) {
    switch (object) {
        case 0:
        case 'ERROR_NONE_UNSPECIFIED':
            return HistoryResponse_Error.ERROR_NONE_UNSPECIFIED;
        case 1:
        case 'ERROR_INVALID_CURSOR':
            return HistoryResponse_Error.ERROR_INVALID_CURSOR;
        case -1:
        case 'UNRECOGNIZED':
        default:
            return HistoryResponse_Error.UNRECOGNIZED;
    }
}
exports.historyResponse_ErrorFromJSON = historyResponse_ErrorFromJSON;
function historyResponse_ErrorToJSON(object) {
    switch (object) {
        case HistoryResponse_Error.ERROR_NONE_UNSPECIFIED:
            return 'ERROR_NONE_UNSPECIFIED';
        case HistoryResponse_Error.ERROR_INVALID_CURSOR:
            return 'ERROR_INVALID_CURSOR';
        default:
            return 'UNKNOWN';
    }
}
exports.historyResponse_ErrorToJSON = historyResponse_ErrorToJSON;
const baseIndex = { receivedTime: 0, senderTime: 0 };
exports.Index = {
    encode(message, writer = minimal_1.default.Writer.create()) {
        if (message.digest.length !== 0) {
            writer.uint32(10).bytes(message.digest);
        }
        if (message.receivedTime !== 0) {
            writer.uint32(17).double(message.receivedTime);
        }
        if (message.senderTime !== 0) {
            writer.uint32(25).double(message.senderTime);
        }
        return writer;
    },
    decode(input, length) {
        const reader = input instanceof minimal_1.default.Reader ? input : new minimal_1.default.Reader(input);
        let end = length === undefined ? reader.len : reader.pos + length;
        const message = Object.assign({}, baseIndex);
        message.digest = new Uint8Array();
        while (reader.pos < end) {
            const tag = reader.uint32();
            switch (tag >>> 3) {
                case 1:
                    message.digest = reader.bytes();
                    break;
                case 2:
                    message.receivedTime = reader.double();
                    break;
                case 3:
                    message.senderTime = reader.double();
                    break;
                default:
                    reader.skipType(tag & 7);
                    break;
            }
        }
        return message;
    },
    fromJSON(object) {
        const message = Object.assign({}, baseIndex);
        message.digest = new Uint8Array();
        if (object.digest !== undefined && object.digest !== null) {
            message.digest = bytesFromBase64(object.digest);
        }
        if (object.receivedTime !== undefined && object.receivedTime !== null) {
            message.receivedTime = Number(object.receivedTime);
        }
        else {
            message.receivedTime = 0;
        }
        if (object.senderTime !== undefined && object.senderTime !== null) {
            message.senderTime = Number(object.senderTime);
        }
        else {
            message.senderTime = 0;
        }
        return message;
    },
    toJSON(message) {
        const obj = {};
        message.digest !== undefined &&
            (obj.digest = base64FromBytes(message.digest !== undefined ? message.digest : new Uint8Array()));
        message.receivedTime !== undefined &&
            (obj.receivedTime = message.receivedTime);
        message.senderTime !== undefined && (obj.senderTime = message.senderTime);
        return obj;
    },
    fromPartial(object) {
        const message = Object.assign({}, baseIndex);
        if (object.digest !== undefined && object.digest !== null) {
            message.digest = object.digest;
        }
        else {
            message.digest = new Uint8Array();
        }
        if (object.receivedTime !== undefined && object.receivedTime !== null) {
            message.receivedTime = object.receivedTime;
        }
        else {
            message.receivedTime = 0;
        }
        if (object.senderTime !== undefined && object.senderTime !== null) {
            message.senderTime = object.senderTime;
        }
        else {
            message.senderTime = 0;
        }
        return message;
    },
};
const basePagingInfo = { pageSize: 0, direction: 0 };
exports.PagingInfo = {
    encode(message, writer = minimal_1.default.Writer.create()) {
        if (message.pageSize !== 0) {
            writer.uint32(8).uint64(message.pageSize);
        }
        if (message.cursor !== undefined) {
            exports.Index.encode(message.cursor, writer.uint32(18).fork()).ldelim();
        }
        if (message.direction !== 0) {
            writer.uint32(24).int32(message.direction);
        }
        return writer;
    },
    decode(input, length) {
        const reader = input instanceof minimal_1.default.Reader ? input : new minimal_1.default.Reader(input);
        let end = length === undefined ? reader.len : reader.pos + length;
        const message = Object.assign({}, basePagingInfo);
        while (reader.pos < end) {
            const tag = reader.uint32();
            switch (tag >>> 3) {
                case 1:
                    message.pageSize = longToNumber(reader.uint64());
                    break;
                case 2:
                    message.cursor = exports.Index.decode(reader, reader.uint32());
                    break;
                case 3:
                    message.direction = reader.int32();
                    break;
                default:
                    reader.skipType(tag & 7);
                    break;
            }
        }
        return message;
    },
    fromJSON(object) {
        const message = Object.assign({}, basePagingInfo);
        if (object.pageSize !== undefined && object.pageSize !== null) {
            message.pageSize = Number(object.pageSize);
        }
        else {
            message.pageSize = 0;
        }
        if (object.cursor !== undefined && object.cursor !== null) {
            message.cursor = exports.Index.fromJSON(object.cursor);
        }
        else {
            message.cursor = undefined;
        }
        if (object.direction !== undefined && object.direction !== null) {
            message.direction = pagingInfo_DirectionFromJSON(object.direction);
        }
        else {
            message.direction = 0;
        }
        return message;
    },
    toJSON(message) {
        const obj = {};
        message.pageSize !== undefined && (obj.pageSize = message.pageSize);
        message.cursor !== undefined &&
            (obj.cursor = message.cursor ? exports.Index.toJSON(message.cursor) : undefined);
        message.direction !== undefined &&
            (obj.direction = pagingInfo_DirectionToJSON(message.direction));
        return obj;
    },
    fromPartial(object) {
        const message = Object.assign({}, basePagingInfo);
        if (object.pageSize !== undefined && object.pageSize !== null) {
            message.pageSize = object.pageSize;
        }
        else {
            message.pageSize = 0;
        }
        if (object.cursor !== undefined && object.cursor !== null) {
            message.cursor = exports.Index.fromPartial(object.cursor);
        }
        else {
            message.cursor = undefined;
        }
        if (object.direction !== undefined && object.direction !== null) {
            message.direction = object.direction;
        }
        else {
            message.direction = 0;
        }
        return message;
    },
};
const baseContentFilter = { contentTopic: '' };
exports.ContentFilter = {
    encode(message, writer = minimal_1.default.Writer.create()) {
        if (message.contentTopic !== '') {
            writer.uint32(10).string(message.contentTopic);
        }
        return writer;
    },
    decode(input, length) {
        const reader = input instanceof minimal_1.default.Reader ? input : new minimal_1.default.Reader(input);
        let end = length === undefined ? reader.len : reader.pos + length;
        const message = Object.assign({}, baseContentFilter);
        while (reader.pos < end) {
            const tag = reader.uint32();
            switch (tag >>> 3) {
                case 1:
                    message.contentTopic = reader.string();
                    break;
                default:
                    reader.skipType(tag & 7);
                    break;
            }
        }
        return message;
    },
    fromJSON(object) {
        const message = Object.assign({}, baseContentFilter);
        if (object.contentTopic !== undefined && object.contentTopic !== null) {
            message.contentTopic = String(object.contentTopic);
        }
        else {
            message.contentTopic = '';
        }
        return message;
    },
    toJSON(message) {
        const obj = {};
        message.contentTopic !== undefined &&
            (obj.contentTopic = message.contentTopic);
        return obj;
    },
    fromPartial(object) {
        const message = Object.assign({}, baseContentFilter);
        if (object.contentTopic !== undefined && object.contentTopic !== null) {
            message.contentTopic = object.contentTopic;
        }
        else {
            message.contentTopic = '';
        }
        return message;
    },
};
const baseHistoryQuery = {};
exports.HistoryQuery = {
    encode(message, writer = minimal_1.default.Writer.create()) {
        if (message.pubSubTopic !== undefined) {
            writer.uint32(18).string(message.pubSubTopic);
        }
        for (const v of message.contentFilters) {
            exports.ContentFilter.encode(v, writer.uint32(26).fork()).ldelim();
        }
        if (message.pagingInfo !== undefined) {
            exports.PagingInfo.encode(message.pagingInfo, writer.uint32(34).fork()).ldelim();
        }
        if (message.startTime !== undefined) {
            writer.uint32(41).double(message.startTime);
        }
        if (message.endTime !== undefined) {
            writer.uint32(49).double(message.endTime);
        }
        return writer;
    },
    decode(input, length) {
        const reader = input instanceof minimal_1.default.Reader ? input : new minimal_1.default.Reader(input);
        let end = length === undefined ? reader.len : reader.pos + length;
        const message = Object.assign({}, baseHistoryQuery);
        message.contentFilters = [];
        while (reader.pos < end) {
            const tag = reader.uint32();
            switch (tag >>> 3) {
                case 2:
                    message.pubSubTopic = reader.string();
                    break;
                case 3:
                    message.contentFilters.push(exports.ContentFilter.decode(reader, reader.uint32()));
                    break;
                case 4:
                    message.pagingInfo = exports.PagingInfo.decode(reader, reader.uint32());
                    break;
                case 5:
                    message.startTime = reader.double();
                    break;
                case 6:
                    message.endTime = reader.double();
                    break;
                default:
                    reader.skipType(tag & 7);
                    break;
            }
        }
        return message;
    },
    fromJSON(object) {
        const message = Object.assign({}, baseHistoryQuery);
        message.contentFilters = [];
        if (object.pubSubTopic !== undefined && object.pubSubTopic !== null) {
            message.pubSubTopic = String(object.pubSubTopic);
        }
        else {
            message.pubSubTopic = undefined;
        }
        if (object.contentFilters !== undefined && object.contentFilters !== null) {
            for (const e of object.contentFilters) {
                message.contentFilters.push(exports.ContentFilter.fromJSON(e));
            }
        }
        if (object.pagingInfo !== undefined && object.pagingInfo !== null) {
            message.pagingInfo = exports.PagingInfo.fromJSON(object.pagingInfo);
        }
        else {
            message.pagingInfo = undefined;
        }
        if (object.startTime !== undefined && object.startTime !== null) {
            message.startTime = Number(object.startTime);
        }
        else {
            message.startTime = undefined;
        }
        if (object.endTime !== undefined && object.endTime !== null) {
            message.endTime = Number(object.endTime);
        }
        else {
            message.endTime = undefined;
        }
        return message;
    },
    toJSON(message) {
        const obj = {};
        message.pubSubTopic !== undefined &&
            (obj.pubSubTopic = message.pubSubTopic);
        if (message.contentFilters) {
            obj.contentFilters = message.contentFilters.map((e) => e ? exports.ContentFilter.toJSON(e) : undefined);
        }
        else {
            obj.contentFilters = [];
        }
        message.pagingInfo !== undefined &&
            (obj.pagingInfo = message.pagingInfo
                ? exports.PagingInfo.toJSON(message.pagingInfo)
                : undefined);
        message.startTime !== undefined && (obj.startTime = message.startTime);
        message.endTime !== undefined && (obj.endTime = message.endTime);
        return obj;
    },
    fromPartial(object) {
        const message = Object.assign({}, baseHistoryQuery);
        message.contentFilters = [];
        if (object.pubSubTopic !== undefined && object.pubSubTopic !== null) {
            message.pubSubTopic = object.pubSubTopic;
        }
        else {
            message.pubSubTopic = undefined;
        }
        if (object.contentFilters !== undefined && object.contentFilters !== null) {
            for (const e of object.contentFilters) {
                message.contentFilters.push(exports.ContentFilter.fromPartial(e));
            }
        }
        if (object.pagingInfo !== undefined && object.pagingInfo !== null) {
            message.pagingInfo = exports.PagingInfo.fromPartial(object.pagingInfo);
        }
        else {
            message.pagingInfo = undefined;
        }
        if (object.startTime !== undefined && object.startTime !== null) {
            message.startTime = object.startTime;
        }
        else {
            message.startTime = undefined;
        }
        if (object.endTime !== undefined && object.endTime !== null) {
            message.endTime = object.endTime;
        }
        else {
            message.endTime = undefined;
        }
        return message;
    },
};
const baseHistoryResponse = { error: 0 };
exports.HistoryResponse = {
    encode(message, writer = minimal_1.default.Writer.create()) {
        for (const v of message.messages) {
            message_1.WakuMessage.encode(v, writer.uint32(18).fork()).ldelim();
        }
        if (message.pagingInfo !== undefined) {
            exports.PagingInfo.encode(message.pagingInfo, writer.uint32(26).fork()).ldelim();
        }
        if (message.error !== 0) {
            writer.uint32(32).int32(message.error);
        }
        return writer;
    },
    decode(input, length) {
        const reader = input instanceof minimal_1.default.Reader ? input : new minimal_1.default.Reader(input);
        let end = length === undefined ? reader.len : reader.pos + length;
        const message = Object.assign({}, baseHistoryResponse);
        message.messages = [];
        while (reader.pos < end) {
            const tag = reader.uint32();
            switch (tag >>> 3) {
                case 2:
                    message.messages.push(message_1.WakuMessage.decode(reader, reader.uint32()));
                    break;
                case 3:
                    message.pagingInfo = exports.PagingInfo.decode(reader, reader.uint32());
                    break;
                case 4:
                    message.error = reader.int32();
                    break;
                default:
                    reader.skipType(tag & 7);
                    break;
            }
        }
        return message;
    },
    fromJSON(object) {
        const message = Object.assign({}, baseHistoryResponse);
        message.messages = [];
        if (object.messages !== undefined && object.messages !== null) {
            for (const e of object.messages) {
                message.messages.push(message_1.WakuMessage.fromJSON(e));
            }
        }
        if (object.pagingInfo !== undefined && object.pagingInfo !== null) {
            message.pagingInfo = exports.PagingInfo.fromJSON(object.pagingInfo);
        }
        else {
            message.pagingInfo = undefined;
        }
        if (object.error !== undefined && object.error !== null) {
            message.error = historyResponse_ErrorFromJSON(object.error);
        }
        else {
            message.error = 0;
        }
        return message;
    },
    toJSON(message) {
        const obj = {};
        if (message.messages) {
            obj.messages = message.messages.map((e) => e ? message_1.WakuMessage.toJSON(e) : undefined);
        }
        else {
            obj.messages = [];
        }
        message.pagingInfo !== undefined &&
            (obj.pagingInfo = message.pagingInfo
                ? exports.PagingInfo.toJSON(message.pagingInfo)
                : undefined);
        message.error !== undefined &&
            (obj.error = historyResponse_ErrorToJSON(message.error));
        return obj;
    },
    fromPartial(object) {
        const message = Object.assign({}, baseHistoryResponse);
        message.messages = [];
        if (object.messages !== undefined && object.messages !== null) {
            for (const e of object.messages) {
                message.messages.push(message_1.WakuMessage.fromPartial(e));
            }
        }
        if (object.pagingInfo !== undefined && object.pagingInfo !== null) {
            message.pagingInfo = exports.PagingInfo.fromPartial(object.pagingInfo);
        }
        else {
            message.pagingInfo = undefined;
        }
        if (object.error !== undefined && object.error !== null) {
            message.error = object.error;
        }
        else {
            message.error = 0;
        }
        return message;
    },
};
const baseHistoryRPC = { requestId: '' };
exports.HistoryRPC = {
    encode(message, writer = minimal_1.default.Writer.create()) {
        if (message.requestId !== '') {
            writer.uint32(10).string(message.requestId);
        }
        if (message.query !== undefined) {
            exports.HistoryQuery.encode(message.query, writer.uint32(18).fork()).ldelim();
        }
        if (message.response !== undefined) {
            exports.HistoryResponse.encode(message.response, writer.uint32(26).fork()).ldelim();
        }
        return writer;
    },
    decode(input, length) {
        const reader = input instanceof minimal_1.default.Reader ? input : new minimal_1.default.Reader(input);
        let end = length === undefined ? reader.len : reader.pos + length;
        const message = Object.assign({}, baseHistoryRPC);
        while (reader.pos < end) {
            const tag = reader.uint32();
            switch (tag >>> 3) {
                case 1:
                    message.requestId = reader.string();
                    break;
                case 2:
                    message.query = exports.HistoryQuery.decode(reader, reader.uint32());
                    break;
                case 3:
                    message.response = exports.HistoryResponse.decode(reader, reader.uint32());
                    break;
                default:
                    reader.skipType(tag & 7);
                    break;
            }
        }
        return message;
    },
    fromJSON(object) {
        const message = Object.assign({}, baseHistoryRPC);
        if (object.requestId !== undefined && object.requestId !== null) {
            message.requestId = String(object.requestId);
        }
        else {
            message.requestId = '';
        }
        if (object.query !== undefined && object.query !== null) {
            message.query = exports.HistoryQuery.fromJSON(object.query);
        }
        else {
            message.query = undefined;
        }
        if (object.response !== undefined && object.response !== null) {
            message.response = exports.HistoryResponse.fromJSON(object.response);
        }
        else {
            message.response = undefined;
        }
        return message;
    },
    toJSON(message) {
        const obj = {};
        message.requestId !== undefined && (obj.requestId = message.requestId);
        message.query !== undefined &&
            (obj.query = message.query
                ? exports.HistoryQuery.toJSON(message.query)
                : undefined);
        message.response !== undefined &&
            (obj.response = message.response
                ? exports.HistoryResponse.toJSON(message.response)
                : undefined);
        return obj;
    },
    fromPartial(object) {
        const message = Object.assign({}, baseHistoryRPC);
        if (object.requestId !== undefined && object.requestId !== null) {
            message.requestId = object.requestId;
        }
        else {
            message.requestId = '';
        }
        if (object.query !== undefined && object.query !== null) {
            message.query = exports.HistoryQuery.fromPartial(object.query);
        }
        else {
            message.query = undefined;
        }
        if (object.response !== undefined && object.response !== null) {
            message.response = exports.HistoryResponse.fromPartial(object.response);
        }
        else {
            message.response = undefined;
        }
        return message;
    },
};
var globalThis = (() => {
    if (typeof globalThis !== 'undefined')
        return globalThis;
    if (typeof self !== 'undefined')
        return self;
    if (typeof window !== 'undefined')
        return window;
    if (typeof __webpack_require__.g !== 'undefined')
        return __webpack_require__.g;
    throw 'Unable to locate global object';
})();
const atob = globalThis.atob ||
    ((b64) => globalThis.Buffer.from(b64, 'base64').toString('binary'));
function bytesFromBase64(b64) {
    const bin = atob(b64);
    const arr = new Uint8Array(bin.length);
    for (let i = 0; i < bin.length; ++i) {
        arr[i] = bin.charCodeAt(i);
    }
    return arr;
}
const btoa = globalThis.btoa ||
    ((bin) => globalThis.Buffer.from(bin, 'binary').toString('base64'));
function base64FromBytes(arr) {
    const bin = [];
    for (const byte of arr) {
        bin.push(String.fromCharCode(byte));
    }
    return btoa(bin.join(''));
}
function longToNumber(long) {
    if (long.gt(Number.MAX_SAFE_INTEGER)) {
        throw new globalThis.Error('Value is larger than Number.MAX_SAFE_INTEGER');
    }
    return long.toNumber();
}
if (minimal_1.default.util.Long !== long_1.default) {
    minimal_1.default.util.Long = long_1.default;
    minimal_1.default.configure();
}


/***/ }),

/***/ "?25ed":
/*!************************!*\
  !*** crypto (ignored) ***!
  \************************/
/***/ (() => {

/* (ignored) */

/***/ }),

/***/ "?8131":
/*!************************!*\
  !*** buffer (ignored) ***!
  \************************/
/***/ (() => {

/* (ignored) */

/***/ }),

/***/ "?3fc0":
/*!************************!*\
  !*** crypto (ignored) ***!
  \************************/
/***/ (() => {

/* (ignored) */

/***/ }),

/***/ "?f9d4":
/*!************************!*\
  !*** buffer (ignored) ***!
  \************************/
/***/ (() => {

/* (ignored) */

/***/ }),

/***/ "?7a28":
/*!************************!*\
  !*** buffer (ignored) ***!
  \************************/
/***/ (() => {

/* (ignored) */

/***/ }),

/***/ "?e4dd":
/*!********************!*\
  !*** os (ignored) ***!
  \********************/
/***/ (() => {

/* (ignored) */

/***/ }),

/***/ "?887c":
/*!********************!*\
  !*** ws (ignored) ***!
  \********************/
/***/ (() => {

/* (ignored) */

/***/ }),

/***/ "?2961":
/*!*********************************!*\
  !*** @motrix/nat-api (ignored) ***!
  \*********************************/
/***/ (() => {

/* (ignored) */

/***/ }),

/***/ "?7d1a":
/*!************************!*\
  !*** buffer (ignored) ***!
  \************************/
/***/ (() => {

/* (ignored) */

/***/ }),

/***/ "?b254":
/*!************************!*\
  !*** crypto (ignored) ***!
  \************************/
/***/ (() => {

/* (ignored) */

/***/ }),

/***/ "?ed1b":
/*!**********************!*\
  !*** util (ignored) ***!
  \**********************/
/***/ (() => {

/* (ignored) */

/***/ }),

/***/ "?d17e":
/*!**********************!*\
  !*** util (ignored) ***!
  \**********************/
/***/ (() => {

/* (ignored) */

/***/ })

/******/ 	});
/************************************************************************/
/******/ 	// The module cache
/******/ 	var __webpack_module_cache__ = {};
/******/ 	
/******/ 	// The require function
/******/ 	function __webpack_require__(moduleId) {
/******/ 		// Check if module is in cache
/******/ 		var cachedModule = __webpack_module_cache__[moduleId];
/******/ 		if (cachedModule !== undefined) {
/******/ 			return cachedModule.exports;
/******/ 		}
/******/ 		// Create a new module (and put it into the cache)
/******/ 		var module = __webpack_module_cache__[moduleId] = {
/******/ 			id: moduleId,
/******/ 			loaded: false,
/******/ 			exports: {}
/******/ 		};
/******/ 	
/******/ 		// Execute the module function
/******/ 		__webpack_modules__[moduleId].call(module.exports, module, module.exports, __webpack_require__);
/******/ 	
/******/ 		// Flag the module as loaded
/******/ 		module.loaded = true;
/******/ 	
/******/ 		// Return the exports of the module
/******/ 		return module.exports;
/******/ 	}
/******/ 	
/******/ 	// expose the modules object (__webpack_modules__)
/******/ 	__webpack_require__.m = __webpack_modules__;
/******/ 	
/************************************************************************/
/******/ 	/* webpack/runtime/amd options */
/******/ 	(() => {
/******/ 		__webpack_require__.amdO = {};
/******/ 	})();
/******/ 	
/******/ 	/* webpack/runtime/chunk loaded */
/******/ 	(() => {
/******/ 		var deferred = [];
/******/ 		__webpack_require__.O = (result, chunkIds, fn, priority) => {
/******/ 			if(chunkIds) {
/******/ 				priority = priority || 0;
/******/ 				for(var i = deferred.length; i > 0 && deferred[i - 1][2] > priority; i--) deferred[i] = deferred[i - 1];
/******/ 				deferred[i] = [chunkIds, fn, priority];
/******/ 				return;
/******/ 			}
/******/ 			var notFulfilled = Infinity;
/******/ 			for (var i = 0; i < deferred.length; i++) {
/******/ 				var [chunkIds, fn, priority] = deferred[i];
/******/ 				var fulfilled = true;
/******/ 				for (var j = 0; j < chunkIds.length; j++) {
/******/ 					if ((priority & 1 === 0 || notFulfilled >= priority) && Object.keys(__webpack_require__.O).every((key) => (__webpack_require__.O[key](chunkIds[j])))) {
/******/ 						chunkIds.splice(j--, 1);
/******/ 					} else {
/******/ 						fulfilled = false;
/******/ 						if(priority < notFulfilled) notFulfilled = priority;
/******/ 					}
/******/ 				}
/******/ 				if(fulfilled) {
/******/ 					deferred.splice(i--, 1)
/******/ 					var r = fn();
/******/ 					if (r !== undefined) result = r;
/******/ 				}
/******/ 			}
/******/ 			return result;
/******/ 		};
/******/ 	})();
/******/ 	
/******/ 	/* webpack/runtime/define property getters */
/******/ 	(() => {
/******/ 		// define getter functions for harmony exports
/******/ 		__webpack_require__.d = (exports, definition) => {
/******/ 			for(var key in definition) {
/******/ 				if(__webpack_require__.o(definition, key) && !__webpack_require__.o(exports, key)) {
/******/ 					Object.defineProperty(exports, key, { enumerable: true, get: definition[key] });
/******/ 				}
/******/ 			}
/******/ 		};
/******/ 	})();
/******/ 	
/******/ 	/* webpack/runtime/global */
/******/ 	(() => {
/******/ 		__webpack_require__.g = (function() {
/******/ 			if (typeof globalThis === 'object') return globalThis;
/******/ 			try {
/******/ 				return this || new Function('return this')();
/******/ 			} catch (e) {
/******/ 				if (typeof window === 'object') return window;
/******/ 			}
/******/ 		})();
/******/ 	})();
/******/ 	
/******/ 	/* webpack/runtime/hasOwnProperty shorthand */
/******/ 	(() => {
/******/ 		__webpack_require__.o = (obj, prop) => (Object.prototype.hasOwnProperty.call(obj, prop))
/******/ 	})();
/******/ 	
/******/ 	/* webpack/runtime/make namespace object */
/******/ 	(() => {
/******/ 		// define __esModule on exports
/******/ 		__webpack_require__.r = (exports) => {
/******/ 			if(typeof Symbol !== 'undefined' && Symbol.toStringTag) {
/******/ 				Object.defineProperty(exports, Symbol.toStringTag, { value: 'Module' });
/******/ 			}
/******/ 			Object.defineProperty(exports, '__esModule', { value: true });
/******/ 		};
/******/ 	})();
/******/ 	
/******/ 	/* webpack/runtime/node module decorator */
/******/ 	(() => {
/******/ 		__webpack_require__.nmd = (module) => {
/******/ 			module.paths = [];
/******/ 			if (!module.children) module.children = [];
/******/ 			return module;
/******/ 		};
/******/ 	})();
/******/ 	
/******/ 	/* webpack/runtime/jsonp chunk loading */
/******/ 	(() => {
/******/ 		// no baseURI
/******/ 		
/******/ 		// object to store loaded and loading chunks
/******/ 		// undefined = chunk not loaded, null = chunk preloaded/prefetched
/******/ 		// [resolve, reject, Promise] = chunk loading, 0 = chunk loaded
/******/ 		var installedChunks = {
/******/ 			"js-waku": 0
/******/ 		};
/******/ 		
/******/ 		// no chunk on demand loading
/******/ 		
/******/ 		// no prefetching
/******/ 		
/******/ 		// no preloaded
/******/ 		
/******/ 		// no HMR
/******/ 		
/******/ 		// no HMR manifest
/******/ 		
/******/ 		__webpack_require__.O.j = (chunkId) => (installedChunks[chunkId] === 0);
/******/ 		
/******/ 		// install a JSONP callback for chunk loading
/******/ 		var webpackJsonpCallback = (parentChunkLoadingFunction, data) => {
/******/ 			var [chunkIds, moreModules, runtime] = data;
/******/ 			// add "moreModules" to the modules object,
/******/ 			// then flag all "chunkIds" as loaded and fire callback
/******/ 			var moduleId, chunkId, i = 0;
/******/ 			if(chunkIds.some((id) => (installedChunks[id] !== 0))) {
/******/ 				for(moduleId in moreModules) {
/******/ 					if(__webpack_require__.o(moreModules, moduleId)) {
/******/ 						__webpack_require__.m[moduleId] = moreModules[moduleId];
/******/ 					}
/******/ 				}
/******/ 				if(runtime) var result = runtime(__webpack_require__);
/******/ 			}
/******/ 			if(parentChunkLoadingFunction) parentChunkLoadingFunction(data);
/******/ 			for(;i < chunkIds.length; i++) {
/******/ 				chunkId = chunkIds[i];
/******/ 				if(__webpack_require__.o(installedChunks, chunkId) && installedChunks[chunkId]) {
/******/ 					installedChunks[chunkId][0]();
/******/ 				}
/******/ 				installedChunks[chunkIds[i]] = 0;
/******/ 			}
/******/ 			return __webpack_require__.O(result);
/******/ 		}
/******/ 		
/******/ 		var chunkLoadingGlobal = this["webpackChunkjswaku"] = this["webpackChunkjswaku"] || [];
/******/ 		chunkLoadingGlobal.forEach(webpackJsonpCallback.bind(null, 0));
/******/ 		chunkLoadingGlobal.push = webpackJsonpCallback.bind(null, chunkLoadingGlobal.push.bind(chunkLoadingGlobal));
/******/ 	})();
/******/ 	
/************************************************************************/
/******/ 	
/******/ 	// startup
/******/ 	// Load entry module and return exports
/******/ 	// This entry module depends on other loaded chunks and execution need to be delayed
/******/ 	var __webpack_exports__ = __webpack_require__.O(undefined, ["vendors"], () => (__webpack_require__("./src/index.ts")))
/******/ 	__webpack_exports__ = __webpack_require__.O(__webpack_exports__);
/******/ 	
/******/ 	return __webpack_exports__;
/******/ })()
;
});
//# sourceMappingURL=data:application/json;charset=utf-8;base64,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V0FDQSxnREFBZ0QsYUFBYTtXQUM3RDs7Ozs7V0NOQTtXQUNBO1dBQ0E7V0FDQTtXQUNBOzs7OztXQ0pBOztXQUVBO1dBQ0E7V0FDQTtXQUNBO1dBQ0E7V0FDQTs7V0FFQTs7V0FFQTs7V0FFQTs7V0FFQTs7V0FFQTs7V0FFQTs7V0FFQTtXQUNBO1dBQ0E7V0FDQTtXQUNBO1dBQ0E7V0FDQTtXQUNBO1dBQ0E7V0FDQTtXQUNBO1dBQ0E7V0FDQTtXQUNBO1dBQ0E7V0FDQSxNQUFNLHFCQUFxQjtXQUMzQjtXQUNBO1dBQ0E7V0FDQTtXQUNBO1dBQ0E7V0FDQTtXQUNBOztXQUVBO1dBQ0E7V0FDQTs7Ozs7VUVoREE7VUFDQTtVQUNBO1VBQ0E7VUFDQSIsInNvdXJjZXMiOlsid2VicGFjazovL2pzd2FrdS93ZWJwYWNrL3VuaXZlcnNhbE1vZHVsZURlZmluaXRpb24iLCJ3ZWJwYWNrOi8vanN3YWt1Ly4vc3JjL2luZGV4LnRzIiwid2VicGFjazovL2pzd2FrdS8uL3NyYy9saWIvZGlzY292ZXJ5LnRzIiwid2VicGFjazovL2pzd2FrdS8uL3NyYy9saWIvc2VsZWN0X3BlZXIudHMiLCJ3ZWJwYWNrOi8vanN3YWt1Ly4vc3JjL2xpYi91dGlscy50cyIsIndlYnBhY2s6Ly9qc3dha3UvLi9zcmMvbGliL3dha3UudHMiLCJ3ZWJwYWNrOi8vanN3YWt1Ly4vc3JjL2xpYi93YWt1X2xpZ2h0X3B1c2gvaW5kZXgudHMiLCJ3ZWJwYWNrOi8vanN3YWt1Ly4vc3JjL2xpYi93YWt1X2xpZ2h0X3B1c2gvcHVzaF9ycGMudHMiLCJ3ZWJwYWNrOi8vanN3YWt1Ly4vc3JjL2xpYi93YWt1X21lc3NhZ2UvaW5kZXgudHMiLCJ3ZWJwYWNrOi8vanN3YWt1Ly4vc3JjL2xpYi93YWt1X21lc3NhZ2Uvc3ltbWV0cmljL2Jyb3dzZXIudHMiLCJ3ZWJwYWNrOi8vanN3YWt1Ly4vc3JjL2xpYi93YWt1X21lc3NhZ2Uvc3ltbWV0cmljL2luZGV4LnRzIiwid2VicGFjazovL2pzd2FrdS8uL3NyYy9saWIvd2FrdV9tZXNzYWdlL3N5bW1ldHJpYy9ub2RlLnRzIiwid2VicGFjazovL2pzd2FrdS8uL3NyYy9saWIvd2FrdV9tZXNzYWdlL3ZlcnNpb25fMS50cyIsIndlYnBhY2s6Ly9qc3dha3UvLi9zcmMvbGliL3dha3VfcmVsYXkvY29uc3RhbnRzLnRzIiwid2VicGFjazovL2pzd2FrdS8uL3NyYy9saWIvd2FrdV9yZWxheS9nZXRfcmVsYXlfcGVlcnMudHMiLCJ3ZWJwYWNrOi8vanN3YWt1Ly4vc3JjL2xpYi93YWt1X3JlbGF5L2luZGV4LnRzIiwid2VicGFjazovL2pzd2FrdS8uL3NyYy9saWIvd2FrdV9yZWxheS9yZWxheV9oZWFydGJlYXQudHMiLCJ3ZWJwYWNrOi8vanN3YWt1Ly4vc3JjL2xpYi93YWt1X3N0b3JlL2hpc3RvcnlfcnBjLnRzIiwid2VicGFjazovL2pzd2FrdS8uL3NyYy9saWIvd2FrdV9zdG9yZS9pbmRleC50cyIsIndlYnBhY2s6Ly9qc3dha3UvLi9zcmMvcHJvdG8vaW5kZXgudHMiLCJ3ZWJwYWNrOi8vanN3YWt1Ly4vc3JjL3Byb3RvL3dha3UvdjIvbGlnaHRfcHVzaC50cyIsIndlYnBhY2s6Ly9qc3dha3UvLi9zcmMvcHJvdG8vd2FrdS92Mi9tZXNzYWdlLnRzIiwid2VicGFjazovL2pzd2FrdS8uL3NyYy9wcm90by93YWt1L3YyL3N0b3JlLnRzIiwid2VicGFjazovL2pzd2FrdS9pZ25vcmVkfC9ob21lL2Zyb3llci9zcmMvc3RhdHVzLWltL2pzLXdha3Uvbm9kZV9tb2R1bGVzL0BzdGFibGVsaWIvcmFuZG9tL2xpYi9zb3VyY2V8Y3J5cHRvIiwid2VicGFjazovL2pzd2FrdS9pZ25vcmVkfC9ob21lL2Zyb3llci9zcmMvc3RhdHVzLWltL2pzLXdha3Uvbm9kZV9tb2R1bGVzL2JuLmpzL2xpYnxidWZmZXIiLCJ3ZWJwYWNrOi8vanN3YWt1L2lnbm9yZWR8L2hvbWUvZnJveWVyL3NyYy9zdGF0dXMtaW0vanMtd2FrdS9ub2RlX21vZHVsZXMvYnJvcmFuZHxjcnlwdG8iLCJ3ZWJwYWNrOi8vanN3YWt1L2lnbm9yZWR8L2hvbWUvZnJveWVyL3NyYy9zdGF0dXMtaW0vanMtd2FrdS9ub2RlX21vZHVsZXMvYnJvd3NlcmlmeS1yc2Evbm9kZV9tb2R1bGVzL2JuLmpzL2xpYnxidWZmZXIiLCJ3ZWJwYWNrOi8vanN3YWt1L2lnbm9yZWR8L2hvbWUvZnJveWVyL3NyYy9zdGF0dXMtaW0vanMtd2FrdS9ub2RlX21vZHVsZXMvYnJvd3NlcmlmeS1zaWduL25vZGVfbW9kdWxlcy9ibi5qcy9saWJ8YnVmZmVyIiwid2VicGFjazovL2pzd2FrdS9pZ25vcmVkfC9ob21lL2Zyb3llci9zcmMvc3RhdHVzLWltL2pzLXdha3Uvbm9kZV9tb2R1bGVzL2NsZWFuLXN0YWNrfG9zIiwid2VicGFjazovL2pzd2FrdS9pZ25vcmVkfC9ob21lL2Zyb3llci9zcmMvc3RhdHVzLWltL2pzLXdha3Uvbm9kZV9tb2R1bGVzL2l0LXdzfHdzIiwid2VicGFjazovL2pzd2FrdS9pZ25vcmVkfC9ob21lL2Zyb3llci9zcmMvc3RhdHVzLWltL2pzLXdha3Uvbm9kZV9tb2R1bGVzL2xpYnAycC9zcmN8QG1vdHJpeC9uYXQtYXBpIiwid2VicGFjazovL2pzd2FrdS9pZ25vcmVkfC9ob21lL2Zyb3llci9zcmMvc3RhdHVzLWltL2pzLXdha3Uvbm9kZV9tb2R1bGVzL25vZGUtZm9yZ2UvbGlifGJ1ZmZlciIsIndlYnBhY2s6Ly9qc3dha3UvaWdub3JlZHwvaG9tZS9mcm95ZXIvc3JjL3N0YXR1cy1pbS9qcy13YWt1L25vZGVfbW9kdWxlcy9ub2RlLWZvcmdlL2xpYnxjcnlwdG8iLCJ3ZWJwYWNrOi8vanN3YWt1L2lnbm9yZWR8L2hvbWUvZnJveWVyL3NyYy9zdGF0dXMtaW0vanMtd2FrdS9ub2RlX21vZHVsZXMvcmVhZGFibGUtc3RyZWFtL2xpYi9pbnRlcm5hbC9zdHJlYW1zfHV0aWwiLCJ3ZWJwYWNrOi8vanN3YWt1L2lnbm9yZWR8L2hvbWUvZnJveWVyL3NyYy9zdGF0dXMtaW0vanMtd2FrdS9ub2RlX21vZHVsZXMvcmVhZGFibGUtc3RyZWFtL2xpYnx1dGlsIiwid2VicGFjazovL2pzd2FrdS93ZWJwYWNrL2Jvb3RzdHJhcCIsIndlYnBhY2s6Ly9qc3dha3Uvd2VicGFjay9ydW50aW1lL2FtZCBvcHRpb25zIiwid2VicGFjazovL2pzd2FrdS93ZWJwYWNrL3J1bnRpbWUvY2h1bmsgbG9hZGVkIiwid2VicGFjazovL2pzd2FrdS93ZWJwYWNrL3J1bnRpbWUvZGVmaW5lIHByb3BlcnR5IGdldHRlcnMiLCJ3ZWJwYWNrOi8vanN3YWt1L3dlYnBhY2svcnVudGltZS9nbG9iYWwiLCJ3ZWJwYWNrOi8vanN3YWt1L3dlYnBhY2svcnVudGltZS9oYXNPd25Qcm9wZXJ0eSBzaG9ydGhhbmQiLCJ3ZWJwYWNrOi8vanN3YWt1L3dlYnBhY2svcnVudGltZS9tYWtlIG5hbWVzcGFjZSBvYmplY3QiLCJ3ZWJwYWNrOi8vanN3YWt1L3dlYnBhY2svcnVudGltZS9ub2RlIG1vZHVsZSBkZWNvcmF0b3IiLCJ3ZWJwYWNrOi8vanN3YWt1L3dlYnBhY2svcnVudGltZS9qc29ucCBjaHVuayBsb2FkaW5nIiwid2VicGFjazovL2pzd2FrdS93ZWJwYWNrL2JlZm9yZS1zdGFydHVwIiwid2VicGFjazovL2pzd2FrdS93ZWJwYWNrL3N0YXJ0dXAiLCJ3ZWJwYWNrOi8vanN3YWt1L3dlYnBhY2svYWZ0ZXItc3RhcnR1cCJdLCJzb3VyY2VzQ29udGVudCI6WyIoZnVuY3Rpb24gd2VicGFja1VuaXZlcnNhbE1vZHVsZURlZmluaXRpb24ocm9vdCwgZmFjdG9yeSkge1xuXHRpZih0eXBlb2YgZXhwb3J0cyA9PT0gJ29iamVjdCcgJiYgdHlwZW9mIG1vZHVsZSA9PT0gJ29iamVjdCcpXG5cdFx0bW9kdWxlLmV4cG9ydHMgPSBmYWN0b3J5KCk7XG5cdGVsc2UgaWYodHlwZW9mIGRlZmluZSA9PT0gJ2Z1bmN0aW9uJyAmJiBkZWZpbmUuYW1kKVxuXHRcdGRlZmluZShbXSwgZmFjdG9yeSk7XG5cdGVsc2UgaWYodHlwZW9mIGV4cG9ydHMgPT09ICdvYmplY3QnKVxuXHRcdGV4cG9ydHNbXCJqc3dha3VcIl0gPSBmYWN0b3J5KCk7XG5cdGVsc2Vcblx0XHRyb290W1wianN3YWt1XCJdID0gZmFjdG9yeSgpO1xufSkodGhpcywgZnVuY3Rpb24oKSB7XG5yZXR1cm4gIiwiZXhwb3J0IHsgZ2V0Qm9vdHN0cmFwTm9kZXMgfSBmcm9tICcuL2xpYi9kaXNjb3ZlcnknO1xuXG5leHBvcnQgKiBhcyB1dGlscyBmcm9tICcuL2xpYi91dGlscyc7XG5cbmV4cG9ydCB7IFdha3UsIERlZmF1bHRQdWJTdWJUb3BpYyB9IGZyb20gJy4vbGliL3dha3UnO1xuXG5leHBvcnQgeyBXYWt1TWVzc2FnZSB9IGZyb20gJy4vbGliL3dha3VfbWVzc2FnZSc7XG5cbmV4cG9ydCB7XG4gIGdlbmVyYXRlUHJpdmF0ZUtleSxcbiAgZ2VuZXJhdGVTeW1tZXRyaWNLZXksXG4gIGdldFB1YmxpY0tleSxcbn0gZnJvbSAnLi9saWIvd2FrdV9tZXNzYWdlL3ZlcnNpb25fMSc7XG5cbmV4cG9ydCB7XG4gIFdha3VMaWdodFB1c2gsXG4gIExpZ2h0UHVzaENvZGVjLFxuICBQdXNoUmVzcG9uc2UsXG59IGZyb20gJy4vbGliL3dha3VfbGlnaHRfcHVzaCc7XG5cbmV4cG9ydCB7IFdha3VSZWxheSwgUmVsYXlDb2RlY3MgfSBmcm9tICcuL2xpYi93YWt1X3JlbGF5JztcblxuZXhwb3J0IHsgUGFnZURpcmVjdGlvbiwgV2FrdVN0b3JlLCBTdG9yZUNvZGVjIH0gZnJvbSAnLi9saWIvd2FrdV9zdG9yZSc7XG5cbmV4cG9ydCAqIGFzIHByb3RvIGZyb20gJy4vcHJvdG8nO1xuIiwiaW1wb3J0IGF4aW9zIGZyb20gJ2F4aW9zJztcbmltcG9ydCBkZWJ1ZyBmcm9tICdkZWJ1Zyc7XG5pbXBvcnQgeyBzaHVmZmxlIH0gZnJvbSAnbGlicDJwLWdvc3NpcHN1Yi9zcmMvdXRpbHMnO1xuXG5jb25zdCBkYmcgPSBkZWJ1Zygnd2FrdTpkaXNjb3ZlcnknKTtcblxuY29uc3QgRGVmYXVsdFdhbnRlZE51bWJlciA9IDE7XG5cbi8qKlxuICogR0VUIGxpc3Qgb2Ygbm9kZXMgZnJvbSByZW1vdGUgSFRUUCBob3N0LlxuICpcbiAqIERlZmF1bHQgYmVoYXZpb3VyIGlzIHRvIHJldHVybiBub2RlcyBob3N0ZWQgYnkgU3RhdHVzLlxuICpcbiAqIEBwYXJhbSBwYXRoIFRoZSBwcm9wZXJ0eSBwYXRoIHRvIGFjY2VzcyB0aGUgbm9kZSBsaXN0LiBUaGUgcmVzdWx0IHNob3VsZCBiZVxuICogYSBzdHJpbmcsIGEgc3RyaW5nIGFycmF5IG9yIGFuIG9iamVjdC4gSWYgdGhlIHJlc3VsdCBpcyBhbiBvYmplY3QgdGhlbiB0aGVcbiAqIHZhbHVlcyBvZiB0aGUgb2JqZWN0cyBhcmUgdXNlZCBhcyBtdWx0aWFkZHJlc3Nlcy4gRm9yIGV4YW1wbGUsIGlmIHRoZSBHRVRcbiAqIHJlcXVlc3QgcmV0dXJucyBgeyBmb286IHsgYmFyOiBbYWRkcmVzczEsIGFkZHJlc3MyXSB9IH1gIHRoZW4gYHBhdGhgIHNob3VsZCBiZVxuICogYFsgXCJmb29cIiwgXCJiYXJcIiBdYC5cbiAqIEBwYXJhbSB1cmwgUmVtb3RlIGhvc3QgY29udGFpbmluZyBib290c3RyYXAgcGVlcnMgaW4gSlNPTiBmb3JtYXQuXG4gKiBAcGFyYW0gd2FudGVkTnVtYmVyIFRoZSBudW1iZXIgb2YgY29ubmVjdGlvbnMgZGVzaXJlZC4gRGVmYXVsdHMgdG8gW0RlZmF1bHRXYW50ZWROdW1iZXJdLlxuICpcbiAqIEByZXR1cm5zIEFuIGFycmF5IG9mIG11bHRpYWRkcmVzc2VzLlxuICogQHRocm93cyBJZiB0aGUgcmVtb3RlIGhvc3QgaXMgdW5yZWFjaGFibGUgb3IgdGhlIHJlc3BvbnNlIGNhbm5vdCBiZSBwYXJzZWRcbiAqIGFjY29yZGluZyB0byB0aGUgcGFzc2VkIF9wYXRoXy5cbiAqL1xuZXhwb3J0IGFzeW5jIGZ1bmN0aW9uIGdldEJvb3RzdHJhcE5vZGVzKFxuICBwYXRoOiBzdHJpbmdbXSA9IFsnZmxlZXRzJywgJ3dha3V2Mi5wcm9kJywgJ3dha3Utd2Vic29ja2V0J10sXG4gIHVybCA9ICdodHRwczovL2ZsZWV0cy5zdGF0dXMuaW0vJyxcbiAgd2FudGVkTnVtYmVyOiBudW1iZXIgPSBEZWZhdWx0V2FudGVkTnVtYmVyXG4pOiBQcm9taXNlPHN0cmluZ1tdPiB7XG4gIGlmICh3YW50ZWROdW1iZXIgPD0gMCkge1xuICAgIHJldHVybiBbXTtcbiAgfVxuXG4gIGNvbnN0IHJlcyA9IGF3YWl0IGF4aW9zLmdldCh1cmwsIHtcbiAgICBoZWFkZXJzOiB7ICdDb250ZW50LVR5cGUnOiAnYXBwbGljYXRpb24vanNvbicgfSxcbiAgfSk7XG5cbiAgbGV0IG5vZGVzID0gcmVzLmRhdGE7XG5cbiAgZm9yIChjb25zdCBwcm9wIG9mIHBhdGgpIHtcbiAgICBpZiAobm9kZXNbcHJvcF0gPT09IHVuZGVmaW5lZCkge1xuICAgICAgZGJnKFxuICAgICAgICBgRmFpbGVkIHRvIHJldHJpZXZlIGJvb3RzdHJhcCBub2RlczogJHtwcm9wfSBkb2VzIG5vdCBleGlzdCBvbiBgLFxuICAgICAgICBub2Rlc1xuICAgICAgKTtcbiAgICAgIHRocm93IGBGYWlsZWQgdG8gcmV0cmlldmUgYm9vdHN0cmFwIG5vZGVzOiAke3Byb3B9IGRvZXMgbm90IGV4aXN0IG9uICR7SlNPTi5zdHJpbmdpZnkoXG4gICAgICAgIG5vZGVzXG4gICAgICApfWA7XG4gICAgfVxuICAgIG5vZGVzID0gbm9kZXNbcHJvcF07XG4gIH1cblxuICBpZiAoQXJyYXkuaXNBcnJheShub2RlcykpIHtcbiAgICByZXR1cm4gZ2V0UHNldWRvUmFuZG9tU3Vic2V0KG5vZGVzLCB3YW50ZWROdW1iZXIpO1xuICB9XG5cbiAgaWYgKHR5cGVvZiBub2RlcyA9PT0gJ3N0cmluZycpIHtcbiAgICByZXR1cm4gW25vZGVzXTtcbiAgfVxuXG4gIGlmICh0eXBlb2Ygbm9kZXMgPT09ICdvYmplY3QnKSB7XG4gICAgbm9kZXMgPSBPYmplY3QudmFsdWVzKG5vZGVzKTtcbiAgICByZXR1cm4gZ2V0UHNldWRvUmFuZG9tU3Vic2V0KG5vZGVzLCB3YW50ZWROdW1iZXIpO1xuICB9XG5cbiAgdGhyb3cgYEZhaWxlZCB0byByZXRyaWV2ZSBib290c3RyYXAgbm9kZXM6IHJlc3BvbnNlIGZvcm1hdCBpcyBub3Qgc3VwcG9ydGVkOiAke0pTT04uc3RyaW5naWZ5KFxuICAgIG5vZGVzXG4gICl9YDtcbn1cblxuZXhwb3J0IGZ1bmN0aW9uIGdldFBzZXVkb1JhbmRvbVN1YnNldChcbiAgdmFsdWVzOiBzdHJpbmdbXSxcbiAgd2FudGVkTnVtYmVyOiBudW1iZXJcbik6IHN0cmluZ1tdIHtcbiAgaWYgKHZhbHVlcy5sZW5ndGggPD0gd2FudGVkTnVtYmVyKSB7XG4gICAgcmV0dXJuIHZhbHVlcztcbiAgfVxuXG4gIHJldHVybiBzaHVmZmxlKHZhbHVlcykuc2xpY2UoMCwgd2FudGVkTnVtYmVyKTtcbn1cbiIsImltcG9ydCBMaWJwMnAgZnJvbSAnbGlicDJwJztcbmltcG9ydCB7IFBlZXIgfSBmcm9tICdsaWJwMnAvc3JjL3BlZXItc3RvcmUnO1xuXG4vKipcbiAqIFJldHVybnMgYSBwc2V1ZG8tcmFuZG9tIHBlZXIgdGhhdCBzdXBwb3J0cyB0aGUgZ2l2ZW4gcHJvdG9jb2wuXG4gKiBVc2VmdWwgZm9yIHByb3RvY29scyBzdWNoIGFzIHN0b3JlIGFuZCBsaWdodCBwdXNoXG4gKi9cbmV4cG9ydCBmdW5jdGlvbiBzZWxlY3RSYW5kb21QZWVyKHBlZXJzOiBQZWVyW10pOiBQZWVyIHwgdW5kZWZpbmVkIHtcbiAgaWYgKHBlZXJzLmxlbmd0aCA9PT0gMCkgcmV0dXJuO1xuXG4gIGNvbnN0IGluZGV4ID0gTWF0aC5yb3VuZChNYXRoLnJhbmRvbSgpICogKHBlZXJzLmxlbmd0aCAtIDEpKTtcbiAgcmV0dXJuIHBlZXJzW2luZGV4XTtcbn1cblxuLyoqXG4gKiBSZXR1cm5zIHRoZSBsaXN0IG9mIHBlZXJzIHRoYXQgc3VwcG9ydHMgdGhlIGdpdmVuIHByb3RvY29sLlxuICovXG5leHBvcnQgZnVuY3Rpb24gZ2V0UGVlcnNGb3JQcm90b2NvbChsaWJwMnA6IExpYnAycCwgcHJvdG9jb2w6IHN0cmluZyk6IFBlZXJbXSB7XG4gIHJldHVybiBBcnJheS5mcm9tKGxpYnAycC5wZWVyU3RvcmUucGVlcnMudmFsdWVzKCkpLmZpbHRlcigocGVlcikgPT5cbiAgICBwZWVyLnByb3RvY29scy5pbmNsdWRlcyhwcm90b2NvbClcbiAgKTtcbn1cbiIsImV4cG9ydCBmdW5jdGlvbiBoZXhUb0J1ZihoZXg6IHN0cmluZyB8IEJ1ZmZlciB8IFVpbnQ4QXJyYXkpOiBCdWZmZXIge1xuICBpZiAodHlwZW9mIGhleCA9PT0gJ3N0cmluZycpIHtcbiAgICByZXR1cm4gQnVmZmVyLmZyb20oaGV4LnJlcGxhY2UoL14weC9pLCAnJyksICdoZXgnKTtcbiAgfSBlbHNlIHtcbiAgICByZXR1cm4gQnVmZmVyLmZyb20oaGV4KTtcbiAgfVxufVxuXG5leHBvcnQgZnVuY3Rpb24gYnVmVG9IZXgoYnVmOiBVaW50OEFycmF5IHwgQnVmZmVyIHwgQXJyYXlCdWZmZXIpOiBzdHJpbmcge1xuICBjb25zdCBfYnVmID0gQnVmZmVyLmZyb20oYnVmKTtcbiAgcmV0dXJuIF9idWYudG9TdHJpbmcoJ2hleCcpO1xufVxuXG5leHBvcnQgZnVuY3Rpb24gZXF1YWxCeXRlQXJyYXlzKFxuICBhOiBVaW50OEFycmF5IHwgQnVmZmVyIHwgc3RyaW5nLFxuICBiOiBVaW50OEFycmF5IHwgQnVmZmVyIHwgc3RyaW5nXG4pOiBib29sZWFuIHtcbiAgbGV0IGFCdWY6IEJ1ZmZlcjtcbiAgbGV0IGJCdWY6IEJ1ZmZlcjtcbiAgaWYgKHR5cGVvZiBhID09PSAnc3RyaW5nJykge1xuICAgIGFCdWYgPSBoZXhUb0J1ZihhKTtcbiAgfSBlbHNlIHtcbiAgICBhQnVmID0gQnVmZmVyLmZyb20oYSk7XG4gIH1cblxuICBpZiAodHlwZW9mIGIgPT09ICdzdHJpbmcnKSB7XG4gICAgYkJ1ZiA9IGhleFRvQnVmKGIpO1xuICB9IGVsc2Uge1xuICAgIGJCdWYgPSBCdWZmZXIuZnJvbShiKTtcbiAgfVxuXG4gIHJldHVybiBhQnVmLmNvbXBhcmUoYkJ1ZikgPT09IDA7XG59XG4iLCJpbXBvcnQgeyBieXRlcyB9IGZyb20gJ0BjaGFpbnNhZmUvbGlicDJwLW5vaXNlL2Rpc3Qvc3JjL0B0eXBlcy9iYXNpYyc7XG5pbXBvcnQgeyBOb2lzZSB9IGZyb20gJ0BjaGFpbnNhZmUvbGlicDJwLW5vaXNlL2Rpc3Qvc3JjL25vaXNlJztcbmltcG9ydCBkZWJ1ZyBmcm9tICdkZWJ1Zyc7XG5pbXBvcnQgTGlicDJwLCB7IENvbm5lY3Rpb24sIExpYnAycE1vZHVsZXMsIExpYnAycE9wdGlvbnMgfSBmcm9tICdsaWJwMnAnO1xuaW1wb3J0IEJvb3RzdHJhcCBmcm9tICdsaWJwMnAtYm9vdHN0cmFwJztcbmltcG9ydCB7IE11eGVkU3RyZWFtIH0gZnJvbSAnbGlicDJwLWludGVyZmFjZXMvZGlzdC9zcmMvc3RyZWFtLW11eGVyL3R5cGVzJztcbi8vIGVzbGludC1kaXNhYmxlLW5leHQtbGluZSBAdHlwZXNjcmlwdC1lc2xpbnQvYmFuLXRzLWNvbW1lbnRcbi8vIEB0cy1pZ25vcmU6IE5vIHR5cGVzIGF2YWlsYWJsZVxuaW1wb3J0IE1wbGV4IGZyb20gJ2xpYnAycC1tcGxleCc7XG4vLyBlc2xpbnQtZGlzYWJsZS1uZXh0LWxpbmUgQHR5cGVzY3JpcHQtZXNsaW50L2Jhbi10cy1jb21tZW50XG4vLyBAdHMtaWdub3JlOiBObyB0eXBlcyBhdmFpbGFibGVcbmltcG9ydCBXZWJzb2NrZXRzIGZyb20gJ2xpYnAycC13ZWJzb2NrZXRzJztcbi8vIGVzbGludC1kaXNhYmxlLW5leHQtbGluZSBAdHlwZXNjcmlwdC1lc2xpbnQvYmFuLXRzLWNvbW1lbnRcbi8vIEB0cy1pZ25vcmU6IE5vIHR5cGVzIGF2YWlsYWJsZVxuaW1wb3J0IGZpbHRlcnMgZnJvbSAnbGlicDJwLXdlYnNvY2tldHMvc3JjL2ZpbHRlcnMnO1xuaW1wb3J0IHsgUGVlciB9IGZyb20gJ2xpYnAycC9kaXN0L3NyYy9wZWVyLXN0b3JlJztcbmltcG9ydCBQaW5nIGZyb20gJ2xpYnAycC9zcmMvcGluZyc7XG5pbXBvcnQgeyBNdWx0aWFkZHIsIG11bHRpYWRkciB9IGZyb20gJ211bHRpYWRkcic7XG5pbXBvcnQgUGVlcklkIGZyb20gJ3BlZXItaWQnO1xuXG5pbXBvcnQgeyBnZXRCb290c3RyYXBOb2RlcyB9IGZyb20gJy4vZGlzY292ZXJ5JztcbmltcG9ydCB7IGdldFBlZXJzRm9yUHJvdG9jb2wgfSBmcm9tICcuL3NlbGVjdF9wZWVyJztcbmltcG9ydCB7IExpZ2h0UHVzaENvZGVjLCBXYWt1TGlnaHRQdXNoIH0gZnJvbSAnLi93YWt1X2xpZ2h0X3B1c2gnO1xuaW1wb3J0IHsgV2FrdU1lc3NhZ2UgfSBmcm9tICcuL3dha3VfbWVzc2FnZSc7XG5pbXBvcnQgeyBSZWxheUNvZGVjcywgV2FrdVJlbGF5IH0gZnJvbSAnLi93YWt1X3JlbGF5JztcbmltcG9ydCB7IFJlbGF5UGluZ0NvbnRlbnRUb3BpYyB9IGZyb20gJy4vd2FrdV9yZWxheS9jb25zdGFudHMnO1xuaW1wb3J0IHsgU3RvcmVDb2RlYywgV2FrdVN0b3JlIH0gZnJvbSAnLi93YWt1X3N0b3JlJztcblxuY29uc3Qgd2Vic29ja2V0c1RyYW5zcG9ydEtleSA9IFdlYnNvY2tldHMucHJvdG90eXBlW1N5bWJvbC50b1N0cmluZ1RhZ107XG5cbmV4cG9ydCBjb25zdCBEZWZhdWx0UGluZ0tlZXBBbGl2ZVZhbHVlU2VjcyA9IDA7XG5leHBvcnQgY29uc3QgRGVmYXVsdFJlbGF5S2VlcEFsaXZlVmFsdWVTZWNzID0gNSAqIDYwO1xuXG4vKipcbiAqIERlZmF1bHRQdWJTdWJUb3BpYyBpcyB0aGUgZGVmYXVsdCBnb3NzaXBzdWIgdG9waWMgdG8gdXNlIGZvciBXYWt1LlxuICovXG5leHBvcnQgY29uc3QgRGVmYXVsdFB1YlN1YlRvcGljID0gJy93YWt1LzIvZGVmYXVsdC13YWt1L3Byb3RvJztcblxuY29uc3QgZGJnID0gZGVidWcoJ3dha3U6d2FrdScpO1xuXG5leHBvcnQgaW50ZXJmYWNlIENyZWF0ZU9wdGlvbnMge1xuICAvKipcbiAgICogVGhlIFB1YlN1YiBUb3BpYyB0byB1c2UuIERlZmF1bHRzIHRvIHtAbGluayBEZWZhdWx0UHViU3ViVG9waWN9LlxuICAgKlxuICAgKiBPbmUgYW5kIG9ubHkgb25lIHB1YnN1YiB0b3BpYyBpcyB1c2VkIGJ5IFdha3UuIFRoaXMgaXMgdXNlZCBieTpcbiAgICogLSBXYWt1UmVsYXkgdG8gcmVjZWl2ZSwgcm91dGUgYW5kIHNlbmQgbWVzc2FnZXMsXG4gICAqIC0gV2FrdUxpZ2h0UHVzaCB0byBzZW5kIG1lc3NhZ2VzLFxuICAgKiAtIFdha3VTdG9yZSB0byByZXRyaWV2ZSBtZXNzYWdlcy5cbiAgICpcbiAgICogVGhlIHVzYWdlIG9mIHRoZSBkZWZhdWx0IHB1YnN1YiB0b3BpYyBpcyByZWNvbW1lbmRlZC5cbiAgICogU2VlIFtXYWt1IHYyIFRvcGljIFVzYWdlIFJlY29tbWVuZGF0aW9uc10oaHR0cHM6Ly9yZmMudmFjLmRldi9zcGVjLzIzLykgZm9yIGRldGFpbHMuXG4gICAqXG4gICAqIEBkZWZhdWx0IHtAbGluayBEZWZhdWx0UHViU3ViVG9waWN9XG4gICAqL1xuICBwdWJTdWJUb3BpYz86IHN0cmluZztcbiAgLyoqXG4gICAqIFNldCBrZWVwIGFsaXZlIGZyZXF1ZW5jeSBpbiBzZWNvbmRzOiBXYWt1IHdpbGwgc2VuZCBhIGAvaXBmcy9waW5nLzEuMC4wYFxuICAgKiByZXF1ZXN0IHRvIGVhY2ggcGVlciBhZnRlciB0aGUgc2V0IG51bWJlciBvZiBzZWNvbmRzLiBTZXQgdG8gMCB0byBkaXNhYmxlLlxuICAgKlxuICAgKiBAZGVmYXVsdCB7QGxpbmsgRGVmYXVsdFBpbmdLZWVwQWxpdmVWYWx1ZVNlY3N9XG4gICAqL1xuICBwaW5nS2VlcEFsaXZlPzogbnVtYmVyO1xuICAvKipcbiAgICogU2V0IGtlZXAgYWxpdmUgZnJlcXVlbmN5IGluIHNlY29uZHM6IFdha3Ugd2lsbCBzZW5kIGEgcGluZyBtZXNzYWdlIG92ZXJcbiAgICogcmVsYXkgdG8gZWFjaCBwZWVyIGFmdGVyIHRoZSBzZXQgbnVtYmVyIG9mIHNlY29uZHMuIFNldCB0byAwIHRvIGRpc2FibGUuXG4gICAqXG4gICAqIEBkZWZhdWx0IHtAbGluayBEZWZhdWx0UmVsYXlLZWVwQWxpdmVWYWx1ZVNlY3N9XG4gICAqL1xuICByZWxheUtlZXBBbGl2ZT86IG51bWJlcjtcbiAgLyoqXG4gICAqIFlvdSBjYW4gcGFzcyBvcHRpb25zIHRvIHRoZSBgTGlicDJwYCBpbnN0YW5jZSB1c2VkIGJ5IHtAbGluayBXYWt1fSB1c2luZyB0aGUge0BsaW5rIENyZWF0ZU9wdGlvbnMubGlicDJwfSBwcm9wZXJ0eS5cbiAgICogVGhpcyBwcm9wZXJ0eSBpcyB0aGUgc2FtZSB0eXBlIHRoYW4gdGhlIG9uZSBwYXNzZWQgdG8gW2BMaWJwMnAuY3JlYXRlYF0oaHR0cHM6Ly9naXRodWIuY29tL2xpYnAycC9qcy1saWJwMnAvYmxvYi9tYXN0ZXIvZG9jL0FQSS5tZCNjcmVhdGUpXG4gICAqIGFwYXJ0IHRoYXQgd2UgbWFkZSB0aGUgYG1vZHVsZXNgIHByb3BlcnR5IG9wdGlvbmFsIGFuZCBwYXJ0aWFsLFxuICAgKiBhbGxvd2luZyBpdHMgb21pc3Npb24gYW5kIGxldHRpbmcgV2FrdSBzZXQgZ29vZCBkZWZhdWx0cy5cbiAgICogTm90ZXMgdGhhdCBzb21lIHZhbHVlcyBhcmUgb3ZlcnJpZGRlbiBieSB7QGxpbmsgV2FrdX0gdG8gZW5zdXJlIGl0IGltcGxlbWVudHMgdGhlIFdha3UgcHJvdG9jb2wuXG4gICAqL1xuICBsaWJwMnA/OiBPbWl0PExpYnAycE9wdGlvbnMgJiBpbXBvcnQoJ2xpYnAycCcpLkNyZWF0ZU9wdGlvbnMsICdtb2R1bGVzJz4gJiB7XG4gICAgbW9kdWxlcz86IFBhcnRpYWw8TGlicDJwTW9kdWxlcz47XG4gIH07XG4gIC8qKlxuICAgKiBCeXRlIGFycmF5IHVzZWQgYXMga2V5IGZvciB0aGUgbm9pc2UgcHJvdG9jb2wgdXNlZCBmb3IgY29ubmVjdGlvbiBlbmNyeXB0aW9uXG4gICAqIGJ5IFtgTGlicDJwLmNyZWF0ZWBdKGh0dHBzOi8vZ2l0aHViLmNvbS9saWJwMnAvanMtbGlicDJwL2Jsb2IvbWFzdGVyL2RvYy9BUEkubWQjY3JlYXRlKVxuICAgKiBUaGlzIGlzIG9ubHkgdXNlZCBmb3IgdGVzdCBwdXJwb3NlcyB0byBub3QgcnVuIG91dCBvZiBlbnRyb3B5IGR1cmluZyBDSSBydW5zLlxuICAgKi9cbiAgc3RhdGljTm9pc2VLZXk/OiBieXRlcztcbiAgLyoqXG4gICAqIFVzZSBsaWJwMnAtYm9vdHN0cmFwIHRvIGRpc2NvdmVyIGFuZCBjb25uZWN0IHRvIG5ldyBub2Rlcy5cbiAgICpcbiAgICogWW91IGNhbiBwYXNzOlxuICAgKiAtIGB0cnVlYCB0byB1c2Uge0BsaW5rIGdldEJvb3RzdHJhcE5vZGVzfSxcbiAgICogLSBhbiBhcnJheSBvZiBtdWx0aWFkZHJlc3NlcyxcbiAgICogLSBhIGZ1bmN0aW9uIHRoYXQgcmV0dXJucyBhbiBhcnJheSBvZiBtdWx0aWFkZHJlc3NlcyAob3IgUHJvbWlzZSBvZikuXG4gICAqXG4gICAqIE5vdGU6IEl0IG92ZXJyaWRlcyBhbnkgb3RoZXIgcGVlckRpc2NvdmVyeSBtb2R1bGVzIHRoYXQgbWF5IGhhdmUgYmVlbiBzZXQgdmlhXG4gICAqIHtAbGluayBDcmVhdGVPcHRpb25zLmxpYnAycH0uXG4gICAqL1xuICBib290c3RyYXA/OiBib29sZWFuIHwgc3RyaW5nW10gfCAoKCkgPT4gc3RyaW5nW10gfCBQcm9taXNlPHN0cmluZ1tdPik7XG4gIGRlY3J5cHRpb25LZXlzPzogQXJyYXk8VWludDhBcnJheSB8IHN0cmluZz47XG59XG5cbmV4cG9ydCBjbGFzcyBXYWt1IHtcbiAgcHVibGljIGxpYnAycDogTGlicDJwO1xuICBwdWJsaWMgcmVsYXk6IFdha3VSZWxheTtcbiAgcHVibGljIHN0b3JlOiBXYWt1U3RvcmU7XG4gIHB1YmxpYyBsaWdodFB1c2g6IFdha3VMaWdodFB1c2g7XG5cbiAgcHJpdmF0ZSBwaW5nS2VlcEFsaXZlVGltZXJzOiB7XG4gICAgW3BlZXI6IHN0cmluZ106IFJldHVyblR5cGU8dHlwZW9mIHNldEludGVydmFsPjtcbiAgfTtcbiAgcHJpdmF0ZSByZWxheUtlZXBBbGl2ZVRpbWVyczoge1xuICAgIFtwZWVyOiBzdHJpbmddOiBSZXR1cm5UeXBlPHR5cGVvZiBzZXRJbnRlcnZhbD47XG4gIH07XG5cbiAgcHJpdmF0ZSBjb25zdHJ1Y3RvcihcbiAgICBvcHRpb25zOiBDcmVhdGVPcHRpb25zLFxuICAgIGxpYnAycDogTGlicDJwLFxuICAgIHN0b3JlOiBXYWt1U3RvcmUsXG4gICAgbGlnaHRQdXNoOiBXYWt1TGlnaHRQdXNoXG4gICkge1xuICAgIHRoaXMubGlicDJwID0gbGlicDJwO1xuICAgIHRoaXMucmVsYXkgPSBsaWJwMnAucHVic3ViIGFzIHVua25vd24gYXMgV2FrdVJlbGF5O1xuICAgIHRoaXMuc3RvcmUgPSBzdG9yZTtcbiAgICB0aGlzLmxpZ2h0UHVzaCA9IGxpZ2h0UHVzaDtcbiAgICB0aGlzLnBpbmdLZWVwQWxpdmVUaW1lcnMgPSB7fTtcbiAgICB0aGlzLnJlbGF5S2VlcEFsaXZlVGltZXJzID0ge307XG5cbiAgICBjb25zdCBwaW5nS2VlcEFsaXZlID1cbiAgICAgIG9wdGlvbnMucGluZ0tlZXBBbGl2ZSB8fCBEZWZhdWx0UGluZ0tlZXBBbGl2ZVZhbHVlU2VjcztcbiAgICBjb25zdCByZWxheUtlZXBBbGl2ZSA9XG4gICAgICBvcHRpb25zLnJlbGF5S2VlcEFsaXZlIHx8IERlZmF1bHRSZWxheUtlZXBBbGl2ZVZhbHVlU2VjcztcblxuICAgIGxpYnAycC5jb25uZWN0aW9uTWFuYWdlci5vbigncGVlcjpjb25uZWN0JywgKGNvbm5lY3Rpb246IENvbm5lY3Rpb24pID0+IHtcbiAgICAgIHRoaXMuc3RhcnRLZWVwQWxpdmUoY29ubmVjdGlvbi5yZW1vdGVQZWVyLCBwaW5nS2VlcEFsaXZlLCByZWxheUtlZXBBbGl2ZSk7XG4gICAgfSk7XG5cbiAgICBsaWJwMnAuY29ubmVjdGlvbk1hbmFnZXIub24oJ3BlZXI6ZGlzY29ubmVjdCcsIChjb25uZWN0aW9uOiBDb25uZWN0aW9uKSA9PiB7XG4gICAgICB0aGlzLnN0b3BLZWVwQWxpdmUoY29ubmVjdGlvbi5yZW1vdGVQZWVyKTtcbiAgICB9KTtcblxuICAgIG9wdGlvbnM/LmRlY3J5cHRpb25LZXlzPy5mb3JFYWNoKHRoaXMuYWRkRGVjcnlwdGlvbktleSk7XG4gIH1cblxuICAvKipcbiAgICogQ3JlYXRlIG5ldyB3YWt1IG5vZGVcbiAgICpcbiAgICogQHBhcmFtIG9wdGlvbnMgVGFrZXMgdGhlIHNhbWUgb3B0aW9ucyB0aGFuIGBMaWJwMnBgLlxuICAgKi9cbiAgc3RhdGljIGFzeW5jIGNyZWF0ZShvcHRpb25zPzogQ3JlYXRlT3B0aW9ucyk6IFByb21pc2U8V2FrdT4ge1xuICAgIC8vIEdldCBhbiBvYmplY3QgaW4gY2FzZSBvcHRpb25zIG9yIGxpYnAycCBhcmUgdW5kZWZpbmVkXG4gICAgY29uc3QgbGlicDJwT3B0cyA9IE9iamVjdC5hc3NpZ24oe30sIG9wdGlvbnM/LmxpYnAycCk7XG5cbiAgICAvLyBEZWZhdWx0IGZvciBXZWJzb2NrZXQgZmlsdGVyIGlzIGBhbGxgOlxuICAgIC8vIFJldHVybnMgYWxsIFRDUCBhbmQgRE5TIGJhc2VkIGFkZHJlc3NlcywgYm90aCB3aXRoIHdzIG9yIHdzcy5cbiAgICBsaWJwMnBPcHRzLmNvbmZpZyA9IE9iamVjdC5hc3NpZ24oXG4gICAgICB7XG4gICAgICAgIHRyYW5zcG9ydDoge1xuICAgICAgICAgIFt3ZWJzb2NrZXRzVHJhbnNwb3J0S2V5XToge1xuICAgICAgICAgICAgZmlsdGVyOiBmaWx0ZXJzLmFsbCxcbiAgICAgICAgICB9LFxuICAgICAgICB9LFxuICAgICAgfSxcbiAgICAgIG9wdGlvbnM/LmxpYnAycD8uY29uZmlnXG4gICAgKTtcblxuICAgIC8vIFBhc3MgcHVic3ViIHRvcGljIHRvIHJlbGF5XG4gICAgaWYgKG9wdGlvbnM/LnB1YlN1YlRvcGljKSB7XG4gICAgICBsaWJwMnBPcHRzLmNvbmZpZy5wdWJzdWIgPSBPYmplY3QuYXNzaWduKFxuICAgICAgICB7IHB1YlN1YlRvcGljOiBvcHRpb25zLnB1YlN1YlRvcGljIH0sXG4gICAgICAgIGxpYnAycE9wdHMuY29uZmlnLnB1YnN1YlxuICAgICAgKTtcbiAgICB9XG5cbiAgICBsaWJwMnBPcHRzLm1vZHVsZXMgPSBPYmplY3QuYXNzaWduKHt9LCBvcHRpb25zPy5saWJwMnA/Lm1vZHVsZXMpO1xuXG4gICAgLy8gRGVmYXVsdCB0cmFuc3BvcnQgZm9yIGxpYnAycCBpcyBXZWJzb2NrZXRzXG4gICAgbGlicDJwT3B0cy5tb2R1bGVzID0gT2JqZWN0LmFzc2lnbihcbiAgICAgIHtcbiAgICAgICAgdHJhbnNwb3J0OiBbV2Vic29ja2V0c10sXG4gICAgICB9LFxuICAgICAgb3B0aW9ucz8ubGlicDJwPy5tb2R1bGVzXG4gICAgKTtcblxuICAgIC8vIHN0cmVhbU11eGVyLCBjb25uZWN0aW9uIGVuY3J5cHRpb24gYW5kIHB1YnN1YiBhcmUgb3ZlcnJpZGRlblxuICAgIC8vIGFzIHRob3NlIGFyZSB0aGUgb25seSBvbmVzIGN1cnJlbnRseSBzdXBwb3J0ZWQgYnkgV2FrdSBub2Rlcy5cbiAgICBsaWJwMnBPcHRzLm1vZHVsZXMgPSBPYmplY3QuYXNzaWduKGxpYnAycE9wdHMubW9kdWxlcywge1xuICAgICAgc3RyZWFtTXV4ZXI6IFtNcGxleF0sXG4gICAgICBjb25uRW5jcnlwdGlvbjogW25ldyBOb2lzZShvcHRpb25zPy5zdGF0aWNOb2lzZUtleSldLFxuICAgICAgcHVic3ViOiBXYWt1UmVsYXksXG4gICAgfSk7XG5cbiAgICBpZiAob3B0aW9ucz8uYm9vdHN0cmFwKSB7XG4gICAgICBsZXQgYm9vdHN0cmFwOiB1bmRlZmluZWQgfCAoKCkgPT4gc3RyaW5nW10gfCBQcm9taXNlPHN0cmluZ1tdPik7XG5cbiAgICAgIGlmIChvcHRpb25zLmJvb3RzdHJhcCA9PT0gdHJ1ZSkge1xuICAgICAgICBib290c3RyYXAgPSBnZXRCb290c3RyYXBOb2RlcztcbiAgICAgIH0gZWxzZSBpZiAoQXJyYXkuaXNBcnJheShvcHRpb25zLmJvb3RzdHJhcCkpIHtcbiAgICAgICAgYm9vdHN0cmFwID0gKCk6IHN0cmluZ1tdID0+IHtcbiAgICAgICAgICByZXR1cm4gb3B0aW9ucy5ib290c3RyYXAgYXMgc3RyaW5nW107XG4gICAgICAgIH07XG4gICAgICB9IGVsc2UgaWYgKHR5cGVvZiBvcHRpb25zLmJvb3RzdHJhcCA9PT0gJ2Z1bmN0aW9uJykge1xuICAgICAgICBib290c3RyYXAgPSBvcHRpb25zLmJvb3RzdHJhcDtcbiAgICAgIH1cblxuICAgICAgaWYgKGJvb3RzdHJhcCAhPT0gdW5kZWZpbmVkKSB7XG4gICAgICAgIHRyeSB7XG4gICAgICAgICAgY29uc3QgbGlzdCA9IGF3YWl0IGJvb3RzdHJhcCgpO1xuXG4gICAgICAgICAgLy8gTm90ZTogdGhpcyBvdmVycmlkZXMgYW55IG90aGVyIHBlZXIgZGlzY292ZXJcbiAgICAgICAgICBsaWJwMnBPcHRzLm1vZHVsZXMgPSBPYmplY3QuYXNzaWduKGxpYnAycE9wdHMubW9kdWxlcywge1xuICAgICAgICAgICAgcGVlckRpc2NvdmVyeTogW0Jvb3RzdHJhcF0sXG4gICAgICAgICAgfSk7XG5cbiAgICAgICAgICBsaWJwMnBPcHRzLmNvbmZpZy5wZWVyRGlzY292ZXJ5ID0ge1xuICAgICAgICAgICAgW0Jvb3RzdHJhcC50YWddOiB7XG4gICAgICAgICAgICAgIGxpc3QsXG4gICAgICAgICAgICAgIGVuYWJsZWQ6IHRydWUsXG4gICAgICAgICAgICB9LFxuICAgICAgICAgIH07XG4gICAgICAgIH0gY2F0Y2ggKGUpIHtcbiAgICAgICAgICBkYmcoJ0ZhaWxlZCB0byByZXRyaWV2ZSBib290c3RyYXAgbm9kZXMnLCBlKTtcbiAgICAgICAgfVxuICAgICAgfVxuICAgIH1cblxuICAgIC8vIGVzbGludC1kaXNhYmxlLW5leHQtbGluZSBAdHlwZXNjcmlwdC1lc2xpbnQvYmFuLXRzLWNvbW1lbnRcbiAgICAvLyBAdHMtaWdub3JlOiBtb2R1bGVzIHByb3BlcnR5IGlzIGNvcnJlY3RseSBzZXQgdGhhbmtzIHRvIHZvb2Rvb1xuICAgIGNvbnN0IGxpYnAycCA9IGF3YWl0IExpYnAycC5jcmVhdGUobGlicDJwT3B0cyk7XG5cbiAgICBjb25zdCB3YWt1U3RvcmUgPSBuZXcgV2FrdVN0b3JlKGxpYnAycCwge1xuICAgICAgcHViU3ViVG9waWM6IG9wdGlvbnM/LnB1YlN1YlRvcGljLFxuICAgIH0pO1xuICAgIGNvbnN0IHdha3VMaWdodFB1c2ggPSBuZXcgV2FrdUxpZ2h0UHVzaChsaWJwMnApO1xuXG4gICAgYXdhaXQgbGlicDJwLnN0YXJ0KCk7XG5cbiAgICByZXR1cm4gbmV3IFdha3Uob3B0aW9ucyA/IG9wdGlvbnMgOiB7fSwgbGlicDJwLCB3YWt1U3RvcmUsIHdha3VMaWdodFB1c2gpO1xuICB9XG5cbiAgLyoqXG4gICAqIERpYWxzIHRvIHRoZSBwcm92aWRlZCBwZWVyLlxuICAgKlxuICAgKiBAcGFyYW0gcGVlciBUaGUgcGVlciB0byBkaWFsXG4gICAqL1xuICBhc3luYyBkaWFsKHBlZXI6IFBlZXJJZCB8IE11bHRpYWRkciB8IHN0cmluZyk6IFByb21pc2U8e1xuICAgIHN0cmVhbTogTXV4ZWRTdHJlYW07XG4gICAgcHJvdG9jb2w6IHN0cmluZztcbiAgfT4ge1xuICAgIHJldHVybiB0aGlzLmxpYnAycC5kaWFsUHJvdG9jb2wocGVlciwgW1N0b3JlQ29kZWNdLmNvbmNhdChSZWxheUNvZGVjcykpO1xuICB9XG5cbiAgLyoqXG4gICAqIEFkZCBwZWVyIHRvIGFkZHJlc3MgYm9vaywgaXQgd2lsbCBiZSBhdXRvLWRpYWxlZCBpbiB0aGUgYmFja2dyb3VuZC5cbiAgICovXG4gIGFkZFBlZXJUb0FkZHJlc3NCb29rKFxuICAgIHBlZXJJZDogUGVlcklkIHwgc3RyaW5nLFxuICAgIG11bHRpYWRkcnM6IE11bHRpYWRkcltdIHwgc3RyaW5nW11cbiAgKTogdm9pZCB7XG4gICAgbGV0IHBlZXI7XG4gICAgaWYgKHR5cGVvZiBwZWVySWQgPT09ICdzdHJpbmcnKSB7XG4gICAgICBwZWVyID0gUGVlcklkLmNyZWF0ZUZyb21CNThTdHJpbmcocGVlcklkKTtcbiAgICB9IGVsc2Uge1xuICAgICAgcGVlciA9IHBlZXJJZDtcbiAgICB9XG4gICAgY29uc3QgYWRkcmVzc2VzID0gbXVsdGlhZGRycy5tYXAoKGFkZHI6IE11bHRpYWRkciB8IHN0cmluZykgPT4ge1xuICAgICAgaWYgKHR5cGVvZiBhZGRyID09PSAnc3RyaW5nJykge1xuICAgICAgICByZXR1cm4gbXVsdGlhZGRyKGFkZHIpO1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgcmV0dXJuIGFkZHI7XG4gICAgICB9XG4gICAgfSk7XG4gICAgdGhpcy5saWJwMnAucGVlclN0b3JlLmFkZHJlc3NCb29rLnNldChwZWVyLCBhZGRyZXNzZXMpO1xuICB9XG5cbiAgYXN5bmMgc3RvcCgpOiBQcm9taXNlPHZvaWQ+IHtcbiAgICByZXR1cm4gdGhpcy5saWJwMnAuc3RvcCgpO1xuICB9XG5cbiAgLyoqXG4gICAqIFJlZ2lzdGVyIGEgZGVjcnlwdGlvbiBrZXkgdG8gYXR0ZW1wdCBkZWNyeXB0aW9uIG9mIG1lc3NhZ2VzIHJlY2VpdmVkIHZpYVxuICAgKiBbW1dha3VSZWxheV1dIGFuZCBbW1dha3VTdG9yZV1dLiBUaGlzIGNhbiBlaXRoZXIgYmUgYSBwcml2YXRlIGtleSBmb3JcbiAgICogYXN5bW1ldHJpYyBlbmNyeXB0aW9uIG9yIGEgc3ltbWV0cmljIGtleS5cbiAgICpcbiAgICogU3RyaW5ncyBtdXN0IGJlIGluIGhleCBmb3JtYXQuXG4gICAqL1xuICBhZGREZWNyeXB0aW9uS2V5KGtleTogVWludDhBcnJheSB8IHN0cmluZyk6IHZvaWQge1xuICAgIHRoaXMucmVsYXkuYWRkRGVjcnlwdGlvbktleShrZXkpO1xuICAgIHRoaXMuc3RvcmUuYWRkRGVjcnlwdGlvbktleShrZXkpO1xuICB9XG5cbiAgLyoqXG4gICAqIERlbGV0ZSBhIGRlY3J5cHRpb24ga2V5IHRoYXQgd2FzIHVzZWQgdG8gYXR0ZW1wdCBkZWNyeXB0aW9uIG9mIG1lc3NhZ2VzXG4gICAqIHJlY2VpdmVkIHZpYSBbW1dha3VSZWxheV1dIG9yIFtbV2FrdVN0b3JlXV0uXG4gICAqXG4gICAqIFN0cmluZ3MgbXVzdCBiZSBpbiBoZXggZm9ybWF0LlxuICAgKi9cbiAgZGVsZXRlRGVjcnlwdGlvbktleShrZXk6IFVpbnQ4QXJyYXkgfCBzdHJpbmcpOiB2b2lkIHtcbiAgICB0aGlzLnJlbGF5LmRlbGV0ZURlY3J5cHRpb25LZXkoa2V5KTtcbiAgICB0aGlzLnN0b3JlLmRlbGV0ZURlY3J5cHRpb25LZXkoa2V5KTtcbiAgfVxuXG4gIC8qKlxuICAgKiBSZXR1cm4gdGhlIGxvY2FsIG11bHRpYWRkciB3aXRoIHBlZXIgaWQgb24gd2hpY2ggbGlicDJwIGlzIGxpc3RlbmluZy5cbiAgICogQHRocm93cyBpZiBsaWJwMnAgaXMgbm90IGxpc3RlbmluZyBvbiBsb2NhbGhvc3RcbiAgICovXG4gIGdldExvY2FsTXVsdGlhZGRyV2l0aElEKCk6IHN0cmluZyB7XG4gICAgY29uc3QgbG9jYWxNdWx0aWFkZHIgPSB0aGlzLmxpYnAycC5tdWx0aWFkZHJzLmZpbmQoKGFkZHIpID0+XG4gICAgICBhZGRyLnRvU3RyaW5nKCkubWF0Y2goLzEyN1xcLjBcXC4wXFwuMS8pXG4gICAgKTtcbiAgICBpZiAoIWxvY2FsTXVsdGlhZGRyIHx8IGxvY2FsTXVsdGlhZGRyLnRvU3RyaW5nKCkgPT09ICcnKSB7XG4gICAgICB0aHJvdyAnTm90IGxpc3RlbmluZyBvbiBsb2NhbGhvc3QnO1xuICAgIH1cbiAgICByZXR1cm4gbG9jYWxNdWx0aWFkZHIgKyAnL3AycC8nICsgdGhpcy5saWJwMnAucGVlcklkLnRvQjU4U3RyaW5nKCk7XG4gIH1cblxuICAvKipcbiAgICogV2FpdCB0byBiZSBjb25uZWN0ZWQgdG8gYSBwZWVyLiBVc2VmdWwgd2hlbiB1c2luZyB0aGUgW1tDcmVhdGVPcHRpb25zLmJvb3RzdHJhcF1dXG4gICAqIHdpdGggW1tXYWt1LmNyZWF0ZV1dLiBUaGUgUHJvbWlzZSByZXNvbHZlcyBvbmx5IG9uY2Ugd2UgYXJlIGNvbm5lY3RlZCB0byBhXG4gICAqIFN0b3JlIHBlZXIsIFJlbGF5IHBlZXIgYW5kIExpZ2h0IFB1c2ggcGVlci5cbiAgICovXG4gIGFzeW5jIHdhaXRGb3JDb25uZWN0ZWRQZWVyKCk6IFByb21pc2U8dm9pZD4ge1xuICAgIGNvbnN0IGRlc2lyZWRQcm90b2NvbHMgPSBbW1N0b3JlQ29kZWNdLCBbTGlnaHRQdXNoQ29kZWNdLCBSZWxheUNvZGVjc107XG5cbiAgICBhd2FpdCBQcm9taXNlLmFsbChcbiAgICAgIGRlc2lyZWRQcm90b2NvbHMubWFwKChkZXNpcmVkUHJvdG9jb2xWZXJzaW9ucykgPT4ge1xuICAgICAgICBjb25zdCBwZWVycyA9IG5ldyBBcnJheTxQZWVyPigpO1xuICAgICAgICBkZXNpcmVkUHJvdG9jb2xWZXJzaW9ucy5mb3JFYWNoKChwcm90bykgPT4ge1xuICAgICAgICAgIGdldFBlZXJzRm9yUHJvdG9jb2wodGhpcy5saWJwMnAsIHByb3RvKS5mb3JFYWNoKChwZWVyKSA9PlxuICAgICAgICAgICAgcGVlcnMucHVzaChwZWVyKVxuICAgICAgICAgICk7XG4gICAgICAgIH0pO1xuXG4gICAgICAgIGlmIChwZWVycy5sZW5ndGggPiAwKSB7XG4gICAgICAgICAgcmV0dXJuIFByb21pc2UucmVzb2x2ZSgpO1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgIC8vIE5vIHBlZXIgYXZhaWxhYmxlIGZvciB0aGlzIHByb3RvY29sLCB3YWl0aW5nIHRvIGNvbm5lY3QgdG8gb25lLlxuICAgICAgICAgIHJldHVybiBuZXcgUHJvbWlzZTx2b2lkPigocmVzb2x2ZSkgPT4ge1xuICAgICAgICAgICAgdGhpcy5saWJwMnAucGVlclN0b3JlLm9uKFxuICAgICAgICAgICAgICAnY2hhbmdlOnByb3RvY29scycsXG4gICAgICAgICAgICAgICh7IHByb3RvY29sczogY29ubmVjdGVkUGVlclByb3RvY29scyB9KSA9PiB7XG4gICAgICAgICAgICAgICAgZGVzaXJlZFByb3RvY29sVmVyc2lvbnMuZm9yRWFjaCgoZGVzaXJlZFByb3RvKSA9PiB7XG4gICAgICAgICAgICAgICAgICBpZiAoY29ubmVjdGVkUGVlclByb3RvY29scy5pbmNsdWRlcyhkZXNpcmVkUHJvdG8pKSB7XG4gICAgICAgICAgICAgICAgICAgIGRiZygnUmVzb2x2aW5nIGZvcicsIGRlc2lyZWRQcm90bywgY29ubmVjdGVkUGVlclByb3RvY29scyk7XG4gICAgICAgICAgICAgICAgICAgIHJlc29sdmUoKTtcbiAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICB9KTtcbiAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgKTtcbiAgICAgICAgICB9KTtcbiAgICAgICAgfVxuICAgICAgfSlcbiAgICApO1xuICB9XG5cbiAgcHJpdmF0ZSBzdGFydEtlZXBBbGl2ZShcbiAgICBwZWVySWQ6IFBlZXJJZCxcbiAgICBwaW5nUGVyaW9kU2VjczogbnVtYmVyLFxuICAgIHJlbGF5UGVyaW9kU2VjczogbnVtYmVyXG4gICk6IHZvaWQge1xuICAgIC8vIEp1c3QgaW4gY2FzZSBhIHRpbWVyIGFscmVhZHkgZXhpc3QgZm9yIHRoaXMgcGVlclxuICAgIHRoaXMuc3RvcEtlZXBBbGl2ZShwZWVySWQpO1xuXG4gICAgY29uc3QgcGVlcklkU3RyID0gcGVlcklkLnRvQjU4U3RyaW5nKCk7XG5cbiAgICBpZiAocGluZ1BlcmlvZFNlY3MgIT09IDApIHtcbiAgICAgIHRoaXMucGluZ0tlZXBBbGl2ZVRpbWVyc1twZWVySWRTdHJdID0gc2V0SW50ZXJ2YWwoKCkgPT4ge1xuICAgICAgICBQaW5nKHRoaXMubGlicDJwLCBwZWVySWQpO1xuICAgICAgfSwgcGluZ1BlcmlvZFNlY3MgKiAxMDAwKTtcbiAgICB9XG5cbiAgICBpZiAocmVsYXlQZXJpb2RTZWNzICE9PSAwKSB7XG4gICAgICB0aGlzLnJlbGF5S2VlcEFsaXZlVGltZXJzW3BlZXJJZFN0cl0gPSBzZXRJbnRlcnZhbCgoKSA9PiB7XG4gICAgICAgIFdha3VNZXNzYWdlLmZyb21CeXRlcyhuZXcgVWludDhBcnJheSgpLCBSZWxheVBpbmdDb250ZW50VG9waWMpLnRoZW4oXG4gICAgICAgICAgKHdha3VNc2cpID0+IHRoaXMucmVsYXkuc2VuZCh3YWt1TXNnKVxuICAgICAgICApO1xuICAgICAgfSwgcmVsYXlQZXJpb2RTZWNzICogMTAwMCk7XG4gICAgfVxuICB9XG5cbiAgcHJpdmF0ZSBzdG9wS2VlcEFsaXZlKHBlZXJJZDogUGVlcklkKTogdm9pZCB7XG4gICAgY29uc3QgcGVlcklkU3RyID0gcGVlcklkLnRvQjU4U3RyaW5nKCk7XG5cbiAgICBpZiAodGhpcy5waW5nS2VlcEFsaXZlVGltZXJzW3BlZXJJZFN0cl0pIHtcbiAgICAgIGNsZWFySW50ZXJ2YWwodGhpcy5waW5nS2VlcEFsaXZlVGltZXJzW3BlZXJJZFN0cl0pO1xuICAgICAgZGVsZXRlIHRoaXMucGluZ0tlZXBBbGl2ZVRpbWVyc1twZWVySWRTdHJdO1xuICAgIH1cblxuICAgIGlmICh0aGlzLnJlbGF5S2VlcEFsaXZlVGltZXJzW3BlZXJJZFN0cl0pIHtcbiAgICAgIGNsZWFySW50ZXJ2YWwodGhpcy5yZWxheUtlZXBBbGl2ZVRpbWVyc1twZWVySWRTdHJdKTtcbiAgICAgIGRlbGV0ZSB0aGlzLnJlbGF5S2VlcEFsaXZlVGltZXJzW3BlZXJJZFN0cl07XG4gICAgfVxuICB9XG59XG4iLCJpbXBvcnQgY29uY2F0IGZyb20gJ2l0LWNvbmNhdCc7XG5pbXBvcnQgbHAgZnJvbSAnaXQtbGVuZ3RoLXByZWZpeGVkJztcbmltcG9ydCBwaXBlIGZyb20gJ2l0LXBpcGUnO1xuaW1wb3J0IExpYnAycCBmcm9tICdsaWJwMnAnO1xuaW1wb3J0IHsgUGVlciB9IGZyb20gJ2xpYnAycC9zcmMvcGVlci1zdG9yZSc7XG5pbXBvcnQgUGVlcklkIGZyb20gJ3BlZXItaWQnO1xuXG5pbXBvcnQgeyBQdXNoUmVzcG9uc2UgfSBmcm9tICcuLi8uLi9wcm90by93YWt1L3YyL2xpZ2h0X3B1c2gnO1xuaW1wb3J0IHsgZ2V0UGVlcnNGb3JQcm90b2NvbCwgc2VsZWN0UmFuZG9tUGVlciB9IGZyb20gJy4uL3NlbGVjdF9wZWVyJztcbmltcG9ydCB7IERlZmF1bHRQdWJTdWJUb3BpYyB9IGZyb20gJy4uL3dha3UnO1xuaW1wb3J0IHsgV2FrdU1lc3NhZ2UgfSBmcm9tICcuLi93YWt1X21lc3NhZ2UnO1xuXG5pbXBvcnQgeyBQdXNoUlBDIH0gZnJvbSAnLi9wdXNoX3JwYyc7XG5cbmV4cG9ydCBjb25zdCBMaWdodFB1c2hDb2RlYyA9ICcvdmFjL3dha3UvbGlnaHRwdXNoLzIuMC4wLWJldGExJztcbmV4cG9ydCB7IFB1c2hSZXNwb25zZSB9O1xuXG5leHBvcnQgaW50ZXJmYWNlIENyZWF0ZU9wdGlvbnMge1xuICAvKipcbiAgICogVGhlIFB1YlN1YiBUb3BpYyB0byB1c2UuIERlZmF1bHRzIHRvIHtAbGluayBEZWZhdWx0UHViU3ViVG9waWN9LlxuICAgKlxuICAgKiBUaGUgdXNhZ2Ugb2YgdGhlIGRlZmF1bHQgcHVic3ViIHRvcGljIGlzIHJlY29tbWVuZGVkLlxuICAgKiBTZWUgW1dha3UgdjIgVG9waWMgVXNhZ2UgUmVjb21tZW5kYXRpb25zXShodHRwczovL3JmYy52YWMuZGV2L3NwZWMvMjMvKSBmb3IgZGV0YWlscy5cbiAgICpcbiAgICogQGRlZmF1bHQge0BsaW5rIERlZmF1bHRQdWJTdWJUb3BpY31cbiAgICovXG4gIHB1YlN1YlRvcGljPzogc3RyaW5nO1xufVxuXG5leHBvcnQgaW50ZXJmYWNlIFB1c2hPcHRpb25zIHtcbiAgcGVlcklkPzogUGVlcklkO1xuICBwdWJTdWJUb3BpYz86IHN0cmluZztcbn1cblxuLyoqXG4gKiBJbXBsZW1lbnRzIHRoZSBbV2FrdSB2MiBMaWdodCBQdXNoIHByb3RvY29sXShodHRwczovL3JmYy52YWMuZGV2L3NwZWMvMTkvKS5cbiAqL1xuZXhwb3J0IGNsYXNzIFdha3VMaWdodFB1c2gge1xuICBwdWJTdWJUb3BpYzogc3RyaW5nO1xuXG4gIGNvbnN0cnVjdG9yKHB1YmxpYyBsaWJwMnA6IExpYnAycCwgb3B0aW9ucz86IENyZWF0ZU9wdGlvbnMpIHtcbiAgICBpZiAob3B0aW9ucz8ucHViU3ViVG9waWMpIHtcbiAgICAgIHRoaXMucHViU3ViVG9waWMgPSBvcHRpb25zLnB1YlN1YlRvcGljO1xuICAgIH0gZWxzZSB7XG4gICAgICB0aGlzLnB1YlN1YlRvcGljID0gRGVmYXVsdFB1YlN1YlRvcGljO1xuICAgIH1cbiAgfVxuXG4gIGFzeW5jIHB1c2goXG4gICAgbWVzc2FnZTogV2FrdU1lc3NhZ2UsXG4gICAgb3B0cz86IFB1c2hPcHRpb25zXG4gICk6IFByb21pc2U8UHVzaFJlc3BvbnNlIHwgbnVsbD4ge1xuICAgIGxldCBwZWVyO1xuICAgIGlmIChvcHRzPy5wZWVySWQpIHtcbiAgICAgIHBlZXIgPSB0aGlzLmxpYnAycC5wZWVyU3RvcmUuZ2V0KG9wdHMucGVlcklkKTtcbiAgICAgIGlmICghcGVlcikgdGhyb3cgJ1BlZXIgaXMgdW5rbm93bic7XG4gICAgfSBlbHNlIHtcbiAgICAgIHBlZXIgPSB0aGlzLnJhbmRvbVBlZXI7XG4gICAgfVxuICAgIGlmICghcGVlcikgdGhyb3cgJ05vIHBlZXIgYXZhaWxhYmxlJztcbiAgICBpZiAoIXBlZXIucHJvdG9jb2xzLmluY2x1ZGVzKExpZ2h0UHVzaENvZGVjKSlcbiAgICAgIHRocm93ICdQZWVyIGRvZXMgbm90IHJlZ2lzdGVyIHdha3UgbGlnaHQgcHVzaCBwcm90b2NvbCc7XG5cbiAgICBjb25zdCBjb25uZWN0aW9uID0gdGhpcy5saWJwMnAuY29ubmVjdGlvbk1hbmFnZXIuZ2V0KHBlZXIuaWQpO1xuICAgIGlmICghY29ubmVjdGlvbikgdGhyb3cgJ0ZhaWxlZCB0byBnZXQgYSBjb25uZWN0aW9uIHRvIHRoZSBwZWVyJztcblxuICAgIGNvbnN0IHsgc3RyZWFtIH0gPSBhd2FpdCBjb25uZWN0aW9uLm5ld1N0cmVhbShMaWdodFB1c2hDb2RlYyk7XG4gICAgdHJ5IHtcbiAgICAgIGNvbnN0IHB1YlN1YlRvcGljID0gb3B0cz8ucHViU3ViVG9waWNcbiAgICAgICAgPyBvcHRzLnB1YlN1YlRvcGljXG4gICAgICAgIDogdGhpcy5wdWJTdWJUb3BpYztcbiAgICAgIGNvbnN0IHF1ZXJ5ID0gUHVzaFJQQy5jcmVhdGVSZXF1ZXN0KG1lc3NhZ2UsIHB1YlN1YlRvcGljKTtcbiAgICAgIGNvbnN0IHJlcyA9IGF3YWl0IHBpcGUoXG4gICAgICAgIFtxdWVyeS5lbmNvZGUoKV0sXG4gICAgICAgIGxwLmVuY29kZSgpLFxuICAgICAgICBzdHJlYW0sXG4gICAgICAgIGxwLmRlY29kZSgpLFxuICAgICAgICBjb25jYXRcbiAgICAgICk7XG4gICAgICB0cnkge1xuICAgICAgICBjb25zdCByZXNwb25zZSA9IFB1c2hSUEMuZGVjb2RlKHJlcy5zbGljZSgpKS5yZXNwb25zZTtcblxuICAgICAgICBpZiAoIXJlc3BvbnNlKSB7XG4gICAgICAgICAgY29uc29sZS5sb2coJ05vIHJlc3BvbnNlIGluIFB1c2hSUEMnKTtcbiAgICAgICAgICByZXR1cm4gbnVsbDtcbiAgICAgICAgfVxuXG4gICAgICAgIHJldHVybiByZXNwb25zZTtcbiAgICAgIH0gY2F0Y2ggKGVycikge1xuICAgICAgICBjb25zb2xlLmxvZygnRmFpbGVkIHRvIGRlY29kZSBwdXNoIHJlcGx5JywgZXJyKTtcbiAgICAgIH1cbiAgICB9IGNhdGNoIChlcnIpIHtcbiAgICAgIGNvbnNvbGUubG9nKCdGYWlsZWQgdG8gc2VuZCB3YWt1IGxpZ2h0IHB1c2ggcmVxdWVzdCcsIGVycik7XG4gICAgfVxuICAgIHJldHVybiBudWxsO1xuICB9XG5cbiAgLyoqXG4gICAqIFJldHVybnMga25vd24gcGVlcnMgZnJvbSB0aGUgYWRkcmVzcyBib29rIChgbGlicDJwLnBlZXJTdG9yZWApIHRoYXQgc3VwcG9ydFxuICAgKiBsaWdodCBwdXNoIHByb3RvY29sLiBXYWt1IG1heSBvciAgbWF5IG5vdCBiZSBjdXJyZW50bHkgY29ubmVjdGVkIHRvIHRoZXNlIHBlZXJzLlxuICAgKi9cbiAgZ2V0IHBlZXJzKCk6IFBlZXJbXSB7XG4gICAgcmV0dXJuIGdldFBlZXJzRm9yUHJvdG9jb2wodGhpcy5saWJwMnAsIExpZ2h0UHVzaENvZGVjKTtcbiAgfVxuXG4gIC8qKlxuICAgKiBSZXR1cm5zIGEgcmFuZG9tIHBlZXIgdGhhdCBzdXBwb3J0cyBsaWdodCBwdXNoIHByb3RvY29sIGZyb20gdGhlIGFkZHJlc3NcbiAgICogYm9vayAoYGxpYnAycC5wZWVyU3RvcmVgKS4gV2FrdSBtYXkgb3IgIG1heSBub3QgYmUgY3VycmVudGx5IGNvbm5lY3RlZCB0b1xuICAgKiB0aGlzIHBlZXIuXG4gICAqL1xuICBnZXQgcmFuZG9tUGVlcigpOiBQZWVyIHwgdW5kZWZpbmVkIHtcbiAgICByZXR1cm4gc2VsZWN0UmFuZG9tUGVlcih0aGlzLnBlZXJzKTtcbiAgfVxufVxuIiwiaW1wb3J0IHsgUmVhZGVyIH0gZnJvbSAncHJvdG9idWZqcy9taW5pbWFsJztcbmltcG9ydCB7IHY0IGFzIHV1aWQgfSBmcm9tICd1dWlkJztcblxuaW1wb3J0ICogYXMgcHJvdG8gZnJvbSAnLi4vLi4vcHJvdG8vd2FrdS92Mi9saWdodF9wdXNoJztcbmltcG9ydCB7IFdha3VNZXNzYWdlIH0gZnJvbSAnLi4vd2FrdV9tZXNzYWdlJztcblxuZXhwb3J0IGNsYXNzIFB1c2hSUEMge1xuICBwdWJsaWMgY29uc3RydWN0b3IocHVibGljIHByb3RvOiBwcm90by5QdXNoUlBDKSB7fVxuXG4gIHN0YXRpYyBjcmVhdGVSZXF1ZXN0KG1lc3NhZ2U6IFdha3VNZXNzYWdlLCBwdWJTdWJUb3BpYzogc3RyaW5nKTogUHVzaFJQQyB7XG4gICAgcmV0dXJuIG5ldyBQdXNoUlBDKHtcbiAgICAgIHJlcXVlc3RJZDogdXVpZCgpLFxuICAgICAgcmVxdWVzdDoge1xuICAgICAgICBtZXNzYWdlOiBtZXNzYWdlLnByb3RvLFxuICAgICAgICBwdWJTdWJUb3BpYzogcHViU3ViVG9waWMsXG4gICAgICB9LFxuICAgICAgcmVzcG9uc2U6IHVuZGVmaW5lZCxcbiAgICB9KTtcbiAgfVxuXG4gIHN0YXRpYyBkZWNvZGUoYnl0ZXM6IFVpbnQ4QXJyYXkpOiBQdXNoUlBDIHtcbiAgICBjb25zdCByZXMgPSBwcm90by5QdXNoUlBDLmRlY29kZShSZWFkZXIuY3JlYXRlKGJ5dGVzKSk7XG4gICAgcmV0dXJuIG5ldyBQdXNoUlBDKHJlcyk7XG4gIH1cblxuICBlbmNvZGUoKTogVWludDhBcnJheSB7XG4gICAgcmV0dXJuIHByb3RvLlB1c2hSUEMuZW5jb2RlKHRoaXMucHJvdG8pLmZpbmlzaCgpO1xuICB9XG5cbiAgZ2V0IHF1ZXJ5KCk6IHByb3RvLlB1c2hSZXF1ZXN0IHwgdW5kZWZpbmVkIHtcbiAgICByZXR1cm4gdGhpcy5wcm90by5yZXF1ZXN0O1xuICB9XG5cbiAgZ2V0IHJlc3BvbnNlKCk6IHByb3RvLlB1c2hSZXNwb25zZSB8IHVuZGVmaW5lZCB7XG4gICAgcmV0dXJuIHRoaXMucHJvdG8ucmVzcG9uc2U7XG4gIH1cbn1cbiIsIi8vIEVuc3VyZSB0aGF0IHRoaXMgY2xhc3MgbWF0Y2hlcyB0aGUgcHJvdG8gaW50ZXJmYWNlIHdoaWxlXG5pbXBvcnQgeyBCdWZmZXIgfSBmcm9tICdidWZmZXInO1xuXG5pbXBvcnQgZGVidWcgZnJvbSAnZGVidWcnO1xuaW1wb3J0IHsgUmVhZGVyIH0gZnJvbSAncHJvdG9idWZqcy9taW5pbWFsJztcblxuLy8gUHJvdGVjdGluZyB0aGUgdXNlciBmcm9tIHByb3RvYnVmIG9kZGl0aWVzXG5pbXBvcnQgKiBhcyBwcm90byBmcm9tICcuLi8uLi9wcm90by93YWt1L3YyL21lc3NhZ2UnO1xuXG5pbXBvcnQgKiBhcyB2ZXJzaW9uXzEgZnJvbSAnLi92ZXJzaW9uXzEnO1xuXG5jb25zdCBEZWZhdWx0VmVyc2lvbiA9IDA7XG5jb25zdCBkYmcgPSBkZWJ1Zygnd2FrdTptZXNzYWdlJyk7XG5cbmV4cG9ydCBpbnRlcmZhY2UgT3B0aW9ucyB7XG4gIC8qKlxuICAgKiBUaW1lc3RhbXAgdG8gc2V0IG9uIHRoZSBtZXNzYWdlLCBkZWZhdWx0cyB0byBub3cgaWYgbm90IHBhc3NlZC5cbiAgICovXG4gIHRpbWVzdGFtcD86IERhdGU7XG4gIC8qKlxuICAgKiBQdWJsaWMgS2V5IHRvIHVzZSB0byBlbmNyeXB0IHRoZSBtZXNzYWdlcyB1c2luZyBFQ0lFUyAoQXN5bW1ldHJpYyBFbmNyeXB0aW9uKS5cbiAgICpcbiAgICogQHRocm93cyBpZiBib3RoIGBlbmNQdWJsaWNLZXlgIGFuZCBgc3ltS2V5YCBhcmUgcGFzc2VkXG4gICAqL1xuICBlbmNQdWJsaWNLZXk/OiBVaW50OEFycmF5IHwgc3RyaW5nO1xuICAvKipcbiAgICogS2V5IHRvIHVzZSB0byBlbmNyeXB0IHRoZSBtZXNzYWdlcyB1c2luZyBBRVMgKFN5bW1ldHJpYyBFbmNyeXB0aW9uKS5cbiAgICpcbiAgICogQHRocm93cyBpZiBib3RoIGBlbmNQdWJsaWNLZXlgIGFuZCBgc3ltS2V5YCBhcmUgcGFzc2VkXG4gICAqL1xuICBzeW1LZXk/OiBVaW50OEFycmF5IHwgc3RyaW5nO1xuICAvKipcbiAgICogUHJpdmF0ZSBrZXkgdG8gdXNlIHRvIHNpZ24gdGhlIG1lc3NhZ2UsIGVpdGhlciBgZW5jUHVibGljS2V5YCBvciBgc3ltS2V5YCBtdXN0IGJlIHByb3ZpZGVkIGFzIG9ubHlcbiAgICogZW5jcnlwdGVkIG1lc3NhZ2VzIGFyZSBzaWduZWQuXG4gICAqL1xuICBzaWdQcml2S2V5PzogVWludDhBcnJheTtcbn1cblxuZXhwb3J0IGNsYXNzIFdha3VNZXNzYWdlIHtcbiAgcHJpdmF0ZSBjb25zdHJ1Y3RvcihcbiAgICBwdWJsaWMgcHJvdG86IHByb3RvLldha3VNZXNzYWdlLFxuICAgIHByaXZhdGUgX3NpZ25hdHVyZVB1YmxpY0tleT86IFVpbnQ4QXJyYXksXG4gICAgcHJpdmF0ZSBfc2lnbmF0dXJlPzogVWludDhBcnJheVxuICApIHt9XG5cbiAgLyoqXG4gICAqIENyZWF0ZSBNZXNzYWdlIHdpdGggYSB1dGYtOCBzdHJpbmcgYXMgcGF5bG9hZC5cbiAgICovXG4gIHN0YXRpYyBhc3luYyBmcm9tVXRmOFN0cmluZyhcbiAgICB1dGY4OiBzdHJpbmcsXG4gICAgY29udGVudFRvcGljOiBzdHJpbmcsXG4gICAgb3B0cz86IE9wdGlvbnNcbiAgKTogUHJvbWlzZTxXYWt1TWVzc2FnZT4ge1xuICAgIGNvbnN0IHBheWxvYWQgPSBCdWZmZXIuZnJvbSh1dGY4LCAndXRmLTgnKTtcbiAgICByZXR1cm4gV2FrdU1lc3NhZ2UuZnJvbUJ5dGVzKHBheWxvYWQsIGNvbnRlbnRUb3BpYywgb3B0cyk7XG4gIH1cblxuICAvKipcbiAgICogQ3JlYXRlIGEgV2FrdSBNZXNzYWdlIHdpdGggdGhlIGdpdmVuIHBheWxvYWQuXG4gICAqXG4gICAqIEJ5IGRlZmF1bHQsIHRoZSBwYXlsb2FkIGlzIGtlcHQgY2xlYXIgKHZlcnNpb24gMCkuXG4gICAqIElmIGBvcHRzLmVuY1B1YmxpY0tleWAgaXMgcGFzc2VkLCB0aGUgcGF5bG9hZCBpcyBlbmNyeXB0ZWQgdXNpbmdcbiAgICogYXN5bW1ldHJpYyBlbmNyeXB0aW9uICh2ZXJzaW9uIDEpLlxuICAgKlxuICAgKiBJZiBgb3B0cy5zaWdQcml2S2V5YCBpcyBwYXNzZWQgYW5kIHZlcnNpb24gMSBpcyB1c2VkLCB0aGUgcGF5bG9hZCBpcyBzaWduZWRcbiAgICogYmVmb3JlIGVuY3J5cHRpb24uXG4gICAqXG4gICAqIEB0aHJvd3MgaWYgYm90aCBgb3B0cy5lbmNQdWJsaWNLZXlgIGFuZCBgb3B0LnN5bUtleWAgYXJlIHBhc3NlZFxuICAgKi9cbiAgc3RhdGljIGFzeW5jIGZyb21CeXRlcyhcbiAgICBwYXlsb2FkOiBVaW50OEFycmF5LFxuICAgIGNvbnRlbnRUb3BpYzogc3RyaW5nLFxuICAgIG9wdHM/OiBPcHRpb25zXG4gICk6IFByb21pc2U8V2FrdU1lc3NhZ2U+IHtcbiAgICBjb25zdCB7IHRpbWVzdGFtcCwgZW5jUHVibGljS2V5LCBzeW1LZXksIHNpZ1ByaXZLZXkgfSA9IE9iamVjdC5hc3NpZ24oXG4gICAgICB7IHRpbWVzdGFtcDogbmV3IERhdGUoKSB9LFxuICAgICAgb3B0cyA/IG9wdHMgOiB7fVxuICAgICk7XG5cbiAgICBsZXQgX3BheWxvYWQgPSBwYXlsb2FkO1xuICAgIGxldCB2ZXJzaW9uID0gRGVmYXVsdFZlcnNpb247XG4gICAgbGV0IHNpZztcblxuICAgIGlmIChlbmNQdWJsaWNLZXkgJiYgc3ltS2V5KSB7XG4gICAgICB0aHJvdyAnUGFzcyBlaXRoZXIgYGVuY1B1YmxpY0tleWAgb3IgYHN5bUtleWAsIG5vdCBib3RoLic7XG4gICAgfVxuXG4gICAgaWYgKGVuY1B1YmxpY0tleSkge1xuICAgICAgY29uc3QgZW5jID0gdmVyc2lvbl8xLmNsZWFyRW5jb2RlKF9wYXlsb2FkLCBzaWdQcml2S2V5KTtcbiAgICAgIF9wYXlsb2FkID0gYXdhaXQgdmVyc2lvbl8xLmVuY3J5cHRBc3ltbWV0cmljKGVuYy5wYXlsb2FkLCBlbmNQdWJsaWNLZXkpO1xuICAgICAgc2lnID0gZW5jLnNpZztcbiAgICAgIHZlcnNpb24gPSAxO1xuICAgIH0gZWxzZSBpZiAoc3ltS2V5KSB7XG4gICAgICBjb25zdCBlbmMgPSB2ZXJzaW9uXzEuY2xlYXJFbmNvZGUoX3BheWxvYWQsIHNpZ1ByaXZLZXkpO1xuICAgICAgX3BheWxvYWQgPSBhd2FpdCB2ZXJzaW9uXzEuZW5jcnlwdFN5bW1ldHJpYyhlbmMucGF5bG9hZCwgc3ltS2V5KTtcbiAgICAgIHNpZyA9IGVuYy5zaWc7XG4gICAgICB2ZXJzaW9uID0gMTtcbiAgICB9XG5cbiAgICByZXR1cm4gbmV3IFdha3VNZXNzYWdlKFxuICAgICAge1xuICAgICAgICBwYXlsb2FkOiBfcGF5bG9hZCxcbiAgICAgICAgdGltZXN0YW1wOiB0aW1lc3RhbXAudmFsdWVPZigpIC8gMTAwMCxcbiAgICAgICAgdmVyc2lvbixcbiAgICAgICAgY29udGVudFRvcGljLFxuICAgICAgfSxcbiAgICAgIHNpZz8ucHVibGljS2V5LFxuICAgICAgc2lnPy5zaWduYXR1cmVcbiAgICApO1xuICB9XG5cbiAgLyoqXG4gICAqIERlY29kZSBhIGJ5dGUgYXJyYXkgaW50byBXYWt1IE1lc3NhZ2UuXG4gICAqXG4gICAqIEBwYXJhbXMgYnl0ZXMgVGhlIG1lc3NhZ2UgZW5jb2RlZCB1c2luZyBwcm90b2J1ZiBhcyBkZWZpbmVkIGluIFsxNC9XQUtVMi1NRVNTQUdFXShodHRwczovL3JmYy52YWMuZGV2L3NwZWMvMTQvKS5cbiAgICogQHBhcmFtcyBkZWNyeXB0aW9uS2V5cyBJZiB0aGUgcGF5bG9hZCBpcyBlbmNyeXB0ZWQgKHZlcnNpb24gPSAxKSwgdGhlbiB0aGVcbiAgICoga2V5cyBhcmUgdXNlZCB0byBhdHRlbXB0IGRlY3J5cHRpb24gb2YgdGhlIG1lc3NhZ2UuIFRoZSBwYXNzZWQga2V5IGNhbiBlaXRoZXJcbiAgICogYmUgYXN5bW1ldHJpYyBwcml2YXRlIGtleXMgb3Igc3ltbWV0cmljIGtleXMsIGJvdGggbWV0aG9kIGFyZSB0cmllZCBmb3IgZWFjaFxuICAgKiBrZXkgdW50aWwgdGhlIG1lc3NhZ2UgaXMgZGVjcnlwdGVkIG9yIGNvbWJpbmF0aW9ucyBhcmUgcmFuIG91dC5cbiAgICovXG4gIHN0YXRpYyBhc3luYyBkZWNvZGUoXG4gICAgYnl0ZXM6IFVpbnQ4QXJyYXksXG4gICAgZGVjcnlwdGlvbktleXM/OiBVaW50OEFycmF5W11cbiAgKTogUHJvbWlzZTxXYWt1TWVzc2FnZSB8IHVuZGVmaW5lZD4ge1xuICAgIGNvbnN0IHByb3RvQnVmID0gcHJvdG8uV2FrdU1lc3NhZ2UuZGVjb2RlKFJlYWRlci5jcmVhdGUoYnl0ZXMpKTtcblxuICAgIHJldHVybiBXYWt1TWVzc2FnZS5kZWNvZGVQcm90byhwcm90b0J1ZiwgZGVjcnlwdGlvbktleXMpO1xuICB9XG5cbiAgLyoqXG4gICAqIERlY29kZSBhbmQgZGVjcnlwdCBXYWt1IE1lc3NhZ2UgUHJvdG9idWYgT2JqZWN0IGludG8gV2FrdSBNZXNzYWdlLlxuICAgKlxuICAgKiBAcGFyYW1zIHByb3RvQnVmIFRoZSBtZXNzYWdlIHRvIGRlY29kZSBhbmQgZGVjcnlwdC5cbiAgICogQHBhcmFtcyBkZWNyeXB0aW9uS2V5cyBJZiB0aGUgcGF5bG9hZCBpcyBlbmNyeXB0ZWQgKHZlcnNpb24gPSAxKSwgdGhlbiB0aGVcbiAgICoga2V5cyBhcmUgdXNlZCB0byBhdHRlbXB0IGRlY3J5cHRpb24gb2YgdGhlIG1lc3NhZ2UuIFRoZSBwYXNzZWQga2V5IGNhbiBlaXRoZXJcbiAgICogYmUgYXN5bW1ldHJpYyBwcml2YXRlIGtleXMgb3Igc3ltbWV0cmljIGtleXMsIGJvdGggbWV0aG9kIGFyZSB0cmllZCBmb3IgZWFjaFxuICAgKiBrZXkgdW50aWwgdGhlIG1lc3NhZ2UgaXMgZGVjcnlwdGVkIG9yIGNvbWJpbmF0aW9ucyBhcmUgcmFuIG91dC5cbiAgICovXG4gIHN0YXRpYyBhc3luYyBkZWNvZGVQcm90byhcbiAgICBwcm90b0J1ZjogcHJvdG8uV2FrdU1lc3NhZ2UsXG4gICAgZGVjcnlwdGlvbktleXM/OiBVaW50OEFycmF5W11cbiAgKTogUHJvbWlzZTxXYWt1TWVzc2FnZSB8IHVuZGVmaW5lZD4ge1xuICAgIGlmIChwcm90b0J1Zi5wYXlsb2FkID09PSB1bmRlZmluZWQpIHtcbiAgICAgIGRiZygnUGF5bG9hZCBpcyB1bmRlZmluZWQnKTtcbiAgICAgIHJldHVybjtcbiAgICB9XG4gICAgY29uc3QgcGF5bG9hZCA9IHByb3RvQnVmLnBheWxvYWQ7XG5cbiAgICBsZXQgc2lnbmF0dXJlUHVibGljS2V5O1xuICAgIGxldCBzaWduYXR1cmU7XG4gICAgaWYgKHByb3RvQnVmLnZlcnNpb24gPT09IDEgJiYgcHJvdG9CdWYucGF5bG9hZCkge1xuICAgICAgaWYgKGRlY3J5cHRpb25LZXlzID09PSB1bmRlZmluZWQpIHtcbiAgICAgICAgZGJnKCdQYXlsb2FkIGlzIGVuY3J5cHRlZCBidXQgbm8gcHJpdmF0ZSBrZXlzIGhhdmUgYmVlbiBwcm92aWRlZC4nKTtcbiAgICAgICAgcmV0dXJuO1xuICAgICAgfVxuXG4gICAgICAvLyBSZXR1cm5zIGEgYnVuY2ggb2YgYHVuZGVmaW5lZGAgYW5kIGhvcGVmdWxseSBvbmUgZGVjcnlwdGVkIHJlc3VsdFxuICAgICAgY29uc3QgYWxsUmVzdWx0cyA9IGF3YWl0IFByb21pc2UuYWxsKFxuICAgICAgICBkZWNyeXB0aW9uS2V5cy5tYXAoYXN5bmMgKHByaXZhdGVLZXkpID0+IHtcbiAgICAgICAgICB0cnkge1xuICAgICAgICAgICAgcmV0dXJuIGF3YWl0IHZlcnNpb25fMS5kZWNyeXB0U3ltbWV0cmljKHBheWxvYWQsIHByaXZhdGVLZXkpO1xuICAgICAgICAgIH0gY2F0Y2ggKGUpIHtcbiAgICAgICAgICAgIGRiZygnRmFpbGVkIHRvIGRlY3J5cHQgbWVzc2FnZSB1c2luZyBzeW1tZXRyaWMgZW5jcnlwdGlvbicsIGUpO1xuICAgICAgICAgICAgdHJ5IHtcbiAgICAgICAgICAgICAgcmV0dXJuIGF3YWl0IHZlcnNpb25fMS5kZWNyeXB0QXN5bW1ldHJpYyhwYXlsb2FkLCBwcml2YXRlS2V5KTtcbiAgICAgICAgICAgIH0gY2F0Y2ggKGUpIHtcbiAgICAgICAgICAgICAgZGJnKCdGYWlsZWQgdG8gZGVjcnlwdCBtZXNzYWdlIHVzaW5nIGFzeW1tZXRyaWMgZW5jcnlwdGlvbicsIGUpO1xuICAgICAgICAgICAgICByZXR1cm47XG4gICAgICAgICAgICB9XG4gICAgICAgICAgfVxuICAgICAgICB9KVxuICAgICAgKTtcblxuICAgICAgY29uc3QgaXNEZWZpbmVkID0gKGRlYzogVWludDhBcnJheSB8IHVuZGVmaW5lZCk6IGRlYyBpcyBVaW50OEFycmF5ID0+IHtcbiAgICAgICAgcmV0dXJuICEhZGVjO1xuICAgICAgfTtcblxuICAgICAgY29uc3QgZGVjb2RlZFJlc3VsdHMgPSBhbGxSZXN1bHRzLmZpbHRlcihpc0RlZmluZWQpO1xuXG4gICAgICBpZiAoZGVjb2RlZFJlc3VsdHMubGVuZ3RoID09PSAwKSB7XG4gICAgICAgIGRiZygnRmFpbGVkIHRvIGRlY3J5cHQgcGF5bG9hZC4nKTtcbiAgICAgICAgcmV0dXJuO1xuICAgICAgfVxuICAgICAgY29uc3QgZGVjID0gZGVjb2RlZFJlc3VsdHNbMF07XG5cbiAgICAgIGNvbnN0IHJlcyA9IGF3YWl0IHZlcnNpb25fMS5jbGVhckRlY29kZShkZWMpO1xuICAgICAgaWYgKCFyZXMpIHtcbiAgICAgICAgZGJnKCdGYWlsZWQgdG8gZGVjb2RlIHBheWxvYWQuJyk7XG4gICAgICAgIHJldHVybjtcbiAgICAgIH1cbiAgICAgIE9iamVjdC5hc3NpZ24ocHJvdG9CdWYsIHsgcGF5bG9hZDogcmVzLnBheWxvYWQgfSk7XG4gICAgICBzaWduYXR1cmVQdWJsaWNLZXkgPSByZXMuc2lnPy5wdWJsaWNLZXk7XG4gICAgICBzaWduYXR1cmUgPSByZXMuc2lnPy5zaWduYXR1cmU7XG4gICAgfVxuXG4gICAgcmV0dXJuIG5ldyBXYWt1TWVzc2FnZShwcm90b0J1Ziwgc2lnbmF0dXJlUHVibGljS2V5LCBzaWduYXR1cmUpO1xuICB9XG5cbiAgZW5jb2RlKCk6IFVpbnQ4QXJyYXkge1xuICAgIHJldHVybiBwcm90by5XYWt1TWVzc2FnZS5lbmNvZGUodGhpcy5wcm90bykuZmluaXNoKCk7XG4gIH1cblxuICBnZXQgcGF5bG9hZEFzVXRmOCgpOiBzdHJpbmcge1xuICAgIGlmICghdGhpcy5wcm90by5wYXlsb2FkKSB7XG4gICAgICByZXR1cm4gJyc7XG4gICAgfVxuXG4gICAgcmV0dXJuIEJ1ZmZlci5mcm9tKHRoaXMucHJvdG8ucGF5bG9hZCkudG9TdHJpbmcoJ3V0Zi04Jyk7XG4gIH1cblxuICBnZXQgcGF5bG9hZCgpOiBVaW50OEFycmF5IHwgdW5kZWZpbmVkIHtcbiAgICByZXR1cm4gdGhpcy5wcm90by5wYXlsb2FkO1xuICB9XG5cbiAgZ2V0IGNvbnRlbnRUb3BpYygpOiBzdHJpbmcgfCB1bmRlZmluZWQge1xuICAgIHJldHVybiB0aGlzLnByb3RvLmNvbnRlbnRUb3BpYztcbiAgfVxuXG4gIGdldCB2ZXJzaW9uKCk6IG51bWJlciB8IHVuZGVmaW5lZCB7XG4gICAgcmV0dXJuIHRoaXMucHJvdG8udmVyc2lvbjtcbiAgfVxuXG4gIGdldCB0aW1lc3RhbXAoKTogRGF0ZSB8IHVuZGVmaW5lZCB7XG4gICAgaWYgKHRoaXMucHJvdG8udGltZXN0YW1wKSB7XG4gICAgICByZXR1cm4gbmV3IERhdGUodGhpcy5wcm90by50aW1lc3RhbXAgKiAxMDAwKTtcbiAgICB9XG4gICAgcmV0dXJuO1xuICB9XG5cbiAgLyoqXG4gICAqIFRoZSBwdWJsaWMga2V5IHVzZWQgdG8gc2lnbiB0aGUgbWVzc2FnZS5cbiAgICpcbiAgICogTUFZIGJlIHByZXNlbnQgaWYgdGhlIG1lc3NhZ2UgaXMgdmVyc2lvbiAxLlxuICAgKi9cbiAgZ2V0IHNpZ25hdHVyZVB1YmxpY0tleSgpOiBVaW50OEFycmF5IHwgdW5kZWZpbmVkIHtcbiAgICByZXR1cm4gdGhpcy5fc2lnbmF0dXJlUHVibGljS2V5O1xuICB9XG5cbiAgLyoqXG4gICAqIFRoZSBzaWduYXR1cmUgb2YgdGhlIG1lc3NhZ2UuXG4gICAqXG4gICAqIE1BWSBiZSBwcmVzZW50IGlmIHRoZSBtZXNzYWdlIGlzIHZlcnNpb24gMS5cbiAgICovXG4gIGdldCBzaWduYXR1cmUoKTogVWludDhBcnJheSB8IHVuZGVmaW5lZCB7XG4gICAgcmV0dXJuIHRoaXMuX3NpZ25hdHVyZTtcbiAgfVxufVxuIiwiaW1wb3J0IHsgSXZTaXplIH0gZnJvbSAnLi9pbmRleCc7XG5cbmRlY2xhcmUgZ2xvYmFsIHtcbiAgaW50ZXJmYWNlIFdpbmRvdyB7XG4gICAgbXNDcnlwdG8/OiBDcnlwdG87XG4gIH1cbiAgaW50ZXJmYWNlIENyeXB0byB7XG4gICAgd2Via2l0U3VidGxlPzogU3VidGxlQ3J5cHRvO1xuICB9XG59XG5cbmNvbnN0IGNyeXB0byA9IHdpbmRvdy5jcnlwdG8gfHwgd2luZG93Lm1zQ3J5cHRvO1xuY29uc3Qgc3VidGxlOiBTdWJ0bGVDcnlwdG8gPSBjcnlwdG8uc3VidGxlIHx8IGNyeXB0by53ZWJraXRTdWJ0bGU7XG5cbmNvbnN0IEFsZ29yaXRobSA9IHsgbmFtZTogJ0FFUy1HQ00nLCBsZW5ndGg6IDEyOCB9O1xuXG5pZiAoc3VidGxlID09PSB1bmRlZmluZWQpIHtcbiAgdGhyb3cgbmV3IEVycm9yKCdGYWlsZWQgdG8gbG9hZCBTdWJ0bGUgQ3J5cHRvQVBJJyk7XG59XG5cbmV4cG9ydCBhc3luYyBmdW5jdGlvbiBlbmNyeXB0KFxuICBpdjogQnVmZmVyIHwgVWludDhBcnJheSxcbiAga2V5OiBCdWZmZXIsXG4gIGNsZWFyVGV4dDogQnVmZmVyXG4pOiBQcm9taXNlPEJ1ZmZlcj4ge1xuICByZXR1cm4gc3VidGxlXG4gICAgLmltcG9ydEtleSgncmF3Jywga2V5LCBBbGdvcml0aG0sIGZhbHNlLCBbJ2VuY3J5cHQnXSlcbiAgICAudGhlbigoY3J5cHRvS2V5KSA9PlxuICAgICAgc3VidGxlLmVuY3J5cHQoeyBpdiwgLi4uQWxnb3JpdGhtIH0sIGNyeXB0b0tleSwgY2xlYXJUZXh0KVxuICAgIClcbiAgICAudGhlbihCdWZmZXIuZnJvbSk7XG59XG5cbmV4cG9ydCBhc3luYyBmdW5jdGlvbiBkZWNyeXB0KFxuICBpdjogQnVmZmVyLFxuICBrZXk6IEJ1ZmZlcixcbiAgY2lwaGVyVGV4dDogQnVmZmVyXG4pOiBQcm9taXNlPEJ1ZmZlcj4ge1xuICByZXR1cm4gc3VidGxlXG4gICAgLmltcG9ydEtleSgncmF3Jywga2V5LCBBbGdvcml0aG0sIGZhbHNlLCBbJ2RlY3J5cHQnXSlcbiAgICAudGhlbigoY3J5cHRvS2V5KSA9PlxuICAgICAgc3VidGxlLmRlY3J5cHQoeyBpdiwgLi4uQWxnb3JpdGhtIH0sIGNyeXB0b0tleSwgY2lwaGVyVGV4dClcbiAgICApXG4gICAgLnRoZW4oQnVmZmVyLmZyb20pO1xufVxuXG5leHBvcnQgZnVuY3Rpb24gZ2VuZXJhdGVJdigpOiBVaW50OEFycmF5IHtcbiAgY29uc3QgaXYgPSBuZXcgVWludDhBcnJheShJdlNpemUpO1xuICBjcnlwdG8uZ2V0UmFuZG9tVmFsdWVzKGl2KTtcbiAgcmV0dXJuIGl2O1xufVxuIiwiZXhwb3J0IGNvbnN0IFN5bW1ldHJpY0tleVNpemUgPSAzMjtcbmV4cG9ydCBjb25zdCBJdlNpemUgPSAxMjtcbmV4cG9ydCBjb25zdCBUYWdTaXplID0gMTY7XG5cbmV4cG9ydCBpbnRlcmZhY2UgU3ltbWV0cmljIHtcbiAgLyoqXG4gICAqIFByb2NlZWQgd2l0aCBzeW1tZXRyaWMgZW5jcnlwdGlvbiBvZiBgY2xlYXJUZXh0YCB2YWx1ZS5cbiAgICovXG4gIGVuY3J5cHQ6IChcbiAgICBpdjogQnVmZmVyIHwgVWludDhBcnJheSxcbiAgICBrZXk6IEJ1ZmZlcixcbiAgICBjbGVhclRleHQ6IEJ1ZmZlclxuICApID0+IFByb21pc2U8QnVmZmVyPjtcbiAgLyoqXG4gICAqIFByb2NlZWQgd2l0aCBzeW1tZXRyaWMgZGVjcnlwdGlvbiBvZiBgY2lwaGVyVGV4dGAgdmFsdWUuXG4gICAqL1xuICBkZWNyeXB0OiAoaXY6IEJ1ZmZlciwga2V5OiBCdWZmZXIsIGNpcGhlclRleHQ6IEJ1ZmZlcikgPT4gUHJvbWlzZTxCdWZmZXI+O1xuICAvKipcbiAgICogR2VuZXJhdGUgYW4gSW5pdGlhbGl6YXRpb24gVmVjdG9yIChpdikgZm9yIGZvciBTeW1tZXRyaWMgZW5jcnlwdGlvbiBwdXJwb3Nlcy5cbiAgICovXG4gIGdlbmVyYXRlSXY6ICgpID0+IFVpbnQ4QXJyYXk7XG59XG5cbmV4cG9ydCBsZXQgc3ltbWV0cmljOiBTeW1tZXRyaWMgPSB7fSBhcyB1bmtub3duIGFzIFN5bW1ldHJpYztcblxuaW1wb3J0KCcuL2Jyb3dzZXInKVxuICAudGhlbigobW9kKSA9PiB7XG4gICAgc3ltbWV0cmljID0gbW9kO1xuICB9KVxuICAuY2F0Y2goKGVCcm93c2VyKSA9PiB7XG4gICAgaW1wb3J0KCcuL25vZGUnKVxuICAgICAgLnRoZW4oKG1vZCkgPT4ge1xuICAgICAgICBzeW1tZXRyaWMgPSBtb2Q7XG4gICAgICB9KVxuICAgICAgLmNhdGNoKChlTm9kZSkgPT4ge1xuICAgICAgICB0aHJvdyBgQ291bGQgbm90IGxvYWQgYW55IHN5bW1ldHJpYyBjcnlwdG8gbW9kdWxlczogJHtlQnJvd3Nlcn0sICR7ZU5vZGV9YDtcbiAgICAgIH0pO1xuICB9KTtcbiIsImltcG9ydCB7IGNyZWF0ZUNpcGhlcml2LCBjcmVhdGVEZWNpcGhlcml2LCByYW5kb21CeXRlcyB9IGZyb20gJ2NyeXB0byc7XG5cbmltcG9ydCB7IEl2U2l6ZSwgVGFnU2l6ZSB9IGZyb20gJy4vaW5kZXgnO1xuXG5jb25zdCBBbGdvcml0aG0gPSAnYWVzLTI1Ni1nY20nO1xuXG5leHBvcnQgYXN5bmMgZnVuY3Rpb24gZW5jcnlwdChcbiAgaXY6IEJ1ZmZlciB8IFVpbnQ4QXJyYXksXG4gIGtleTogQnVmZmVyLFxuICBjbGVhclRleHQ6IEJ1ZmZlclxuKTogUHJvbWlzZTxCdWZmZXI+IHtcbiAgY29uc3QgY2lwaGVyID0gY3JlYXRlQ2lwaGVyaXYoQWxnb3JpdGhtLCBrZXksIGl2KTtcbiAgY29uc3QgYSA9IGNpcGhlci51cGRhdGUoY2xlYXJUZXh0KTtcbiAgY29uc3QgYiA9IGNpcGhlci5maW5hbCgpO1xuICBjb25zdCB0YWcgPSBjaXBoZXIuZ2V0QXV0aFRhZygpO1xuICByZXR1cm4gQnVmZmVyLmNvbmNhdChbYSwgYiwgdGFnXSk7XG59XG5cbmV4cG9ydCBhc3luYyBmdW5jdGlvbiBkZWNyeXB0KFxuICBpdjogQnVmZmVyLFxuICBrZXk6IEJ1ZmZlcixcbiAgZGF0YTogQnVmZmVyXG4pOiBQcm9taXNlPEJ1ZmZlcj4ge1xuICBjb25zdCB0YWdTdGFydCA9IGRhdGEubGVuZ3RoIC0gVGFnU2l6ZTtcbiAgY29uc3QgY2lwaGVyVGV4dCA9IGRhdGEuc2xpY2UoMCwgdGFnU3RhcnQpO1xuICBjb25zdCB0YWcgPSBkYXRhLnNsaWNlKHRhZ1N0YXJ0KTtcbiAgY29uc3QgZGVjaXBoZXIgPSBjcmVhdGVEZWNpcGhlcml2KEFsZ29yaXRobSwga2V5LCBpdik7XG4gIGRlY2lwaGVyLnNldEF1dGhUYWcodGFnKTtcbiAgY29uc3QgYSA9IGRlY2lwaGVyLnVwZGF0ZShjaXBoZXJUZXh0KTtcbiAgY29uc3QgYiA9IGRlY2lwaGVyLmZpbmFsKCk7XG4gIHJldHVybiBCdWZmZXIuY29uY2F0KFthLCBiXSk7XG59XG5cbmV4cG9ydCBmdW5jdGlvbiBnZW5lcmF0ZUl2KCk6IEJ1ZmZlciB7XG4gIHJldHVybiByYW5kb21CeXRlcyhJdlNpemUpO1xufVxuIiwiaW1wb3J0IHsgQnVmZmVyIH0gZnJvbSAnYnVmZmVyJztcbmltcG9ydCAqIGFzIGNyeXB0byBmcm9tICdjcnlwdG8nO1xuXG5pbXBvcnQgKiBhcyBlY2llcyBmcm9tICdlY2llcy1nZXRoJztcbmltcG9ydCB7IGtlY2NhazI1NiB9IGZyb20gJ2pzLXNoYTMnO1xuaW1wb3J0ICogYXMgc2VjcDI1NmsxIGZyb20gJ3NlY3AyNTZrMSc7XG5cbmltcG9ydCB7IGhleFRvQnVmIH0gZnJvbSAnLi4vdXRpbHMnO1xuXG5pbXBvcnQgeyBJdlNpemUsIHN5bW1ldHJpYywgU3ltbWV0cmljS2V5U2l6ZSB9IGZyb20gJy4vc3ltbWV0cmljJztcblxuY29uc3QgRmxhZ3NMZW5ndGggPSAxO1xuY29uc3QgRmxhZ01hc2sgPSAzOyAvLyAwMDExXG5jb25zdCBJc1NpZ25lZE1hc2sgPSA0OyAvLyAwMTAwXG5jb25zdCBQYWRkaW5nVGFyZ2V0ID0gMjU2O1xuY29uc3QgU2lnbmF0dXJlTGVuZ3RoID0gNjU7XG5cbmV4cG9ydCBjb25zdCBQcml2YXRlS2V5U2l6ZSA9IDMyO1xuXG4vKipcbiAqIEVuY29kZSB0aGUgcGF5bG9hZCBwcmUtZW5jcnlwdGlvbi5cbiAqXG4gKiBAaW50ZXJuYWxcbiAqIEBwYXJhbSBtZXNzYWdlUGF5bG9hZDogVGhlIHBheWxvYWQgdG8gaW5jbHVkZSBpbiB0aGUgbWVzc2FnZVxuICogQHBhcmFtIHNpZ1ByaXZLZXk6IElmIHNldCwgYSBzaWduYXR1cmUgdXNpbmcgdGhpcyBwcml2YXRlIGtleSBpcyBhZGRlZC5cbiAqIEByZXR1cm5zIFRoZSBlbmNvZGVkIHBheWxvYWQsIHJlYWR5IGZvciBlbmNyeXB0aW9uIHVzaW5nIHtAbGluayBlbmNyeXB0QXN5bW1ldHJpY31cbiAqIG9yIHtAbGluayBlbmNyeXB0U3ltbWV0cmljfS5cbiAqL1xuZXhwb3J0IGZ1bmN0aW9uIGNsZWFyRW5jb2RlKFxuICBtZXNzYWdlUGF5bG9hZDogVWludDhBcnJheSxcbiAgc2lnUHJpdktleT86IFVpbnQ4QXJyYXlcbik6IHsgcGF5bG9hZDogVWludDhBcnJheTsgc2lnPzogU2lnbmF0dXJlIH0ge1xuICBsZXQgZW52ZWxvcGUgPSBCdWZmZXIuZnJvbShbMF0pOyAvLyBObyBmbGFnc1xuICBlbnZlbG9wZSA9IGFkZFBheWxvYWRTaXplRmllbGQoZW52ZWxvcGUsIG1lc3NhZ2VQYXlsb2FkKTtcbiAgZW52ZWxvcGUgPSBCdWZmZXIuY29uY2F0KFtlbnZlbG9wZSwgQnVmZmVyLmZyb20obWVzc2FnZVBheWxvYWQpXSk7XG5cbiAgLy8gQ2FsY3VsYXRlIHBhZGRpbmc6XG4gIGxldCByYXdTaXplID1cbiAgICBGbGFnc0xlbmd0aCArXG4gICAgZ2V0U2l6ZU9mUGF5bG9hZFNpemVGaWVsZChtZXNzYWdlUGF5bG9hZCkgK1xuICAgIG1lc3NhZ2VQYXlsb2FkLmxlbmd0aDtcblxuICBpZiAoc2lnUHJpdktleSkge1xuICAgIHJhd1NpemUgKz0gU2lnbmF0dXJlTGVuZ3RoO1xuICB9XG5cbiAgY29uc3QgcmVtYWluZGVyID0gcmF3U2l6ZSAlIFBhZGRpbmdUYXJnZXQ7XG4gIGNvbnN0IHBhZGRpbmdTaXplID0gUGFkZGluZ1RhcmdldCAtIHJlbWFpbmRlcjtcbiAgY29uc3QgcGFkID0gQnVmZmVyLmZyb20ocmFuZG9tQnl0ZXMocGFkZGluZ1NpemUpKTtcblxuICBpZiAoIXZhbGlkYXRlRGF0YUludGVncml0eShwYWQsIHBhZGRpbmdTaXplKSkge1xuICAgIHRocm93IG5ldyBFcnJvcignZmFpbGVkIHRvIGdlbmVyYXRlIHJhbmRvbSBwYWRkaW5nIG9mIHNpemUgJyArIHBhZGRpbmdTaXplKTtcbiAgfVxuXG4gIGVudmVsb3BlID0gQnVmZmVyLmNvbmNhdChbZW52ZWxvcGUsIHBhZF0pO1xuXG4gIGxldCBzaWc7XG4gIGlmIChzaWdQcml2S2V5KSB7XG4gICAgZW52ZWxvcGVbMF0gfD0gSXNTaWduZWRNYXNrO1xuICAgIGNvbnN0IGhhc2ggPSBrZWNjYWsyNTYoZW52ZWxvcGUpO1xuICAgIGNvbnN0IHMgPSBzZWNwMjU2azEuZWNkc2FTaWduKGhleFRvQnVmKGhhc2gpLCBzaWdQcml2S2V5KTtcbiAgICBlbnZlbG9wZSA9IEJ1ZmZlci5jb25jYXQoW2VudmVsb3BlLCBzLnNpZ25hdHVyZSwgQnVmZmVyLmZyb20oW3MucmVjaWRdKV0pO1xuICAgIHNpZyA9IHtcbiAgICAgIHNpZ25hdHVyZTogQnVmZmVyLmZyb20ocy5zaWduYXR1cmUpLFxuICAgICAgcHVibGljS2V5OiBnZXRQdWJsaWNLZXkoc2lnUHJpdktleSksXG4gICAgfTtcbiAgfVxuXG4gIHJldHVybiB7IHBheWxvYWQ6IGVudmVsb3BlLCBzaWcgfTtcbn1cblxuZXhwb3J0IHR5cGUgU2lnbmF0dXJlID0ge1xuICBzaWduYXR1cmU6IFVpbnQ4QXJyYXk7XG4gIHB1YmxpY0tleTogVWludDhBcnJheTtcbn07XG5cbi8qKlxuICogRGVjb2RlIGEgZGVjcnlwdGVkIHBheWxvYWQuXG4gKlxuICogQGludGVybmFsXG4gKi9cbmV4cG9ydCBmdW5jdGlvbiBjbGVhckRlY29kZShcbiAgbWVzc2FnZTogVWludDhBcnJheSB8IEJ1ZmZlclxuKTogeyBwYXlsb2FkOiBVaW50OEFycmF5OyBzaWc/OiBTaWduYXR1cmUgfSB8IHVuZGVmaW5lZCB7XG4gIGNvbnN0IGJ1ZiA9IEJ1ZmZlci5mcm9tKG1lc3NhZ2UpO1xuICBsZXQgc3RhcnQgPSAxO1xuICBsZXQgc2lnO1xuXG4gIGNvbnN0IHNpemVPZlBheWxvYWRTaXplRmllbGQgPSBidWYucmVhZFVJbnRMRSgwLCAxKSAmIEZsYWdNYXNrO1xuXG4gIGlmIChzaXplT2ZQYXlsb2FkU2l6ZUZpZWxkID09PSAwKSByZXR1cm47XG5cbiAgY29uc3QgcGF5bG9hZFNpemUgPSBidWYucmVhZFVJbnRMRShzdGFydCwgc2l6ZU9mUGF5bG9hZFNpemVGaWVsZCk7XG4gIHN0YXJ0ICs9IHNpemVPZlBheWxvYWRTaXplRmllbGQ7XG4gIGNvbnN0IHBheWxvYWQgPSBidWYuc2xpY2Uoc3RhcnQsIHN0YXJ0ICsgcGF5bG9hZFNpemUpO1xuXG4gIGNvbnN0IGlzU2lnbmVkID0gKGJ1Zi5yZWFkVUludExFKDAsIDEpICYgSXNTaWduZWRNYXNrKSA9PSBJc1NpZ25lZE1hc2s7XG4gIGlmIChpc1NpZ25lZCkge1xuICAgIGNvbnN0IHNpZ25hdHVyZSA9IGdldFNpZ25hdHVyZShidWYpO1xuICAgIGNvbnN0IGhhc2ggPSBnZXRIYXNoKGJ1ZiwgaXNTaWduZWQpO1xuICAgIGNvbnN0IHB1YmxpY0tleSA9IGVjUmVjb3ZlclB1YktleShoYXNoLCBzaWduYXR1cmUpO1xuICAgIHNpZyA9IHsgc2lnbmF0dXJlLCBwdWJsaWNLZXkgfTtcbiAgfVxuXG4gIHJldHVybiB7IHBheWxvYWQsIHNpZyB9O1xufVxuXG4vKipcbiAqIFByb2NlZWQgd2l0aCBBc3ltbWV0cmljIGVuY3J5cHRpb24gb2YgdGhlIGRhdGEgYXMgcGVyIFsyNi9XQUtVLVBBWUxPQURdKGh0dHBzOi8vcmZjLnZhYy5kZXYvc3BlYy8yNi8pLlxuICogVGhlIGRhdGEgTVVTVCBiZSBmbGFncyB8IHBheWxvYWQtbGVuZ3RoIHwgcGF5bG9hZCB8IFtzaWduYXR1cmVdLlxuICogVGhlIHJldHVybmVkIHJlc3VsdCBjYW4gYmUgc2V0IHRvIGBXYWt1TWVzc2FnZS5wYXlsb2FkYC5cbiAqXG4gKiBAaW50ZXJuYWxcbiAqL1xuZXhwb3J0IGFzeW5jIGZ1bmN0aW9uIGVuY3J5cHRBc3ltbWV0cmljKFxuICBkYXRhOiBVaW50OEFycmF5IHwgQnVmZmVyLFxuICBwdWJsaWNLZXk6IFVpbnQ4QXJyYXkgfCBCdWZmZXIgfCBzdHJpbmdcbik6IFByb21pc2U8VWludDhBcnJheT4ge1xuICByZXR1cm4gZWNpZXMuZW5jcnlwdChoZXhUb0J1ZihwdWJsaWNLZXkpLCBCdWZmZXIuZnJvbShkYXRhKSk7XG59XG5cbi8qKlxuICogUHJvY2VlZCB3aXRoIEFzeW1tZXRyaWMgZGVjcnlwdGlvbiBvZiB0aGUgZGF0YSBhcyBwZXIgWzI2L1dBS1UtUEFZTE9BRF0oaHR0cHM6Ly9yZmMudmFjLmRldi9zcGVjLzI2LykuXG4gKiBUaGUgcmV0dXJuIGRhdGEgaXMgZXhwZWN0IHRvIGJlIGZsYWdzIHwgcGF5bG9hZC1sZW5ndGggfCBwYXlsb2FkIHwgW3NpZ25hdHVyZV0uXG4gKlxuICogQGludGVybmFsXG4gKi9cbmV4cG9ydCBhc3luYyBmdW5jdGlvbiBkZWNyeXB0QXN5bW1ldHJpYyhcbiAgcGF5bG9hZDogVWludDhBcnJheSB8IEJ1ZmZlcixcbiAgcHJpdktleTogVWludDhBcnJheSB8IEJ1ZmZlclxuKTogUHJvbWlzZTxVaW50OEFycmF5PiB7XG4gIHJldHVybiBlY2llcy5kZWNyeXB0KEJ1ZmZlci5mcm9tKHByaXZLZXkpLCBCdWZmZXIuZnJvbShwYXlsb2FkKSk7XG59XG5cbi8qKlxuICogUHJvY2VlZCB3aXRoIFN5bW1ldHJpYyBlbmNyeXB0aW9uIG9mIHRoZSBkYXRhIGFzIHBlciBbMjYvV0FLVS1QQVlMT0FEXShodHRwczovL3JmYy52YWMuZGV2L3NwZWMvMjYvKS5cbiAqXG4gKiBAcGFyYW0gZGF0YSBUaGUgZGF0YSB0byBlbmNyeXB0LCBleHBlY3RlZCB0byBiZSBgZmxhZ3MgfCBwYXlsb2FkLWxlbmd0aCB8IHBheWxvYWQgfCBbc2lnbmF0dXJlXWAuXG4gKiBAcGFyYW0ga2V5IFRoZSBrZXkgdG8gdXNlIGZvciBlbmNyeXB0aW9uLlxuICogQHJldHVybnMgVGhlIGRlY3J5cHRlZCBkYXRhLCBgY2lwaGVyVGV4dCB8IHRhZyB8IGl2YCBhbmQgY2FuIGJlIHNldCB0byBgV2FrdU1lc3NhZ2UucGF5bG9hZGAuXG4gKlxuICogQGludGVybmFsXG4gKi9cbmV4cG9ydCBhc3luYyBmdW5jdGlvbiBlbmNyeXB0U3ltbWV0cmljKFxuICBkYXRhOiBVaW50OEFycmF5IHwgQnVmZmVyLFxuICBrZXk6IFVpbnQ4QXJyYXkgfCBCdWZmZXIgfCBzdHJpbmdcbik6IFByb21pc2U8VWludDhBcnJheT4ge1xuICBjb25zdCBpdiA9IHN5bW1ldHJpYy5nZW5lcmF0ZUl2KCk7XG5cbiAgLy8gUmV0dXJucyBgY2lwaGVyIHwgdGFnYFxuICBjb25zdCBjaXBoZXIgPSBhd2FpdCBzeW1tZXRyaWMuZW5jcnlwdChpdiwgaGV4VG9CdWYoa2V5KSwgQnVmZmVyLmZyb20oZGF0YSkpO1xuICByZXR1cm4gQnVmZmVyLmNvbmNhdChbY2lwaGVyLCBCdWZmZXIuZnJvbShpdildKTtcbn1cblxuLyoqXG4gKiBQcm9jZWVkIHdpdGggU3ltbWV0cmljIGRlY3J5cHRpb24gb2YgdGhlIGRhdGEgYXMgcGVyIFsyNi9XQUtVLVBBWUxPQURdKGh0dHBzOi8vcmZjLnZhYy5kZXYvc3BlYy8yNi8pLlxuICpcbiAqIEBwYXJhbSBwYXlsb2FkIFRoZSBjaXBoZXIgZGF0YSwgaXQgaXMgZXhwZWN0ZWQgdG8gYmUgYGNpcGhlclRleHQgfCB0YWcgfCBpdmAuXG4gKiBAcGFyYW0ga2V5IFRoZSBrZXkgdG8gdXNlIGZvciBkZWNyeXB0aW9uLlxuICogQHJldHVybnMgVGhlIGRlY3J5cHRlZCBkYXRhLCBleHBlY3RlZCB0byBiZSBgZmxhZ3MgfCBwYXlsb2FkLWxlbmd0aCB8IHBheWxvYWQgfCBbc2lnbmF0dXJlXWAuXG4gKlxuICogQGludGVybmFsXG4gKi9cbmV4cG9ydCBhc3luYyBmdW5jdGlvbiBkZWNyeXB0U3ltbWV0cmljKFxuICBwYXlsb2FkOiBVaW50OEFycmF5IHwgQnVmZmVyLFxuICBrZXk6IFVpbnQ4QXJyYXkgfCBCdWZmZXIgfCBzdHJpbmdcbik6IFByb21pc2U8VWludDhBcnJheT4ge1xuICBjb25zdCBkYXRhID0gQnVmZmVyLmZyb20ocGF5bG9hZCk7XG4gIGNvbnN0IGl2U3RhcnQgPSBkYXRhLmxlbmd0aCAtIEl2U2l6ZTtcbiAgY29uc3QgY2lwaGVyID0gZGF0YS5zbGljZSgwLCBpdlN0YXJ0KTtcbiAgY29uc3QgaXYgPSBkYXRhLnNsaWNlKGl2U3RhcnQpO1xuXG4gIHJldHVybiBzeW1tZXRyaWMuZGVjcnlwdChpdiwgaGV4VG9CdWYoa2V5KSwgY2lwaGVyKTtcbn1cblxuLyoqXG4gKiBHZW5lcmF0ZSBhIG5ldyBwcml2YXRlIGtleSB0byBiZSB1c2VkIGZvciBhc3ltbWV0cmljIGVuY3J5cHRpb24uXG4gKlxuICogVXNlIHtAbGluayBnZXRQdWJsaWNLZXl9IHRvIGdldCB0aGUgY29ycmVzcG9uZGluZyBQdWJsaWMgS2V5LlxuICovXG5leHBvcnQgZnVuY3Rpb24gZ2VuZXJhdGVQcml2YXRlS2V5KCk6IFVpbnQ4QXJyYXkge1xuICByZXR1cm4gcmFuZG9tQnl0ZXMoUHJpdmF0ZUtleVNpemUpO1xufVxuXG4vKipcbiAqIEdlbmVyYXRlIGEgbmV3IHN5bW1ldHJpYyBrZXkgdG8gYmUgdXNlZCBmb3Igc3ltbWV0cmljIGVuY3J5cHRpb24uXG4gKi9cbmV4cG9ydCBmdW5jdGlvbiBnZW5lcmF0ZVN5bW1ldHJpY0tleSgpOiBVaW50OEFycmF5IHtcbiAgcmV0dXJuIHJhbmRvbUJ5dGVzKFN5bW1ldHJpY0tleVNpemUpO1xufVxuXG4vKipcbiAqIFJldHVybiB0aGUgcHVibGljIGtleSBmb3IgdGhlIGdpdmVuIHByaXZhdGUga2V5LCB0byBiZSB1c2VkIGZvciBhc3ltbWV0cmljXG4gKiBlbmNyeXB0aW9uLlxuICovXG5leHBvcnQgZnVuY3Rpb24gZ2V0UHVibGljS2V5KHByaXZhdGVLZXk6IFVpbnQ4QXJyYXkgfCBCdWZmZXIpOiBVaW50OEFycmF5IHtcbiAgcmV0dXJuIHNlY3AyNTZrMS5wdWJsaWNLZXlDcmVhdGUocHJpdmF0ZUtleSwgZmFsc2UpO1xufVxuXG4vKipcbiAqIENvbXB1dGVzIHRoZSBmbGFncyAmIGF1eGlsaWFyeS1maWVsZCBhcyBwZXIgWzI2L1dBS1UtUEFZTE9BRF0oaHR0cHM6Ly9yZmMudmFjLmRldi9zcGVjLzI2LykuXG4gKi9cbmZ1bmN0aW9uIGFkZFBheWxvYWRTaXplRmllbGQobXNnOiBCdWZmZXIsIHBheWxvYWQ6IFVpbnQ4QXJyYXkpOiBCdWZmZXIge1xuICBjb25zdCBmaWVsZFNpemUgPSBnZXRTaXplT2ZQYXlsb2FkU2l6ZUZpZWxkKHBheWxvYWQpO1xuICBsZXQgZmllbGQgPSBCdWZmZXIuYWxsb2MoNCk7XG4gIGZpZWxkLndyaXRlVUludDMyTEUocGF5bG9hZC5sZW5ndGgsIDApO1xuICBmaWVsZCA9IGZpZWxkLnNsaWNlKDAsIGZpZWxkU2l6ZSk7XG4gIG1zZyA9IEJ1ZmZlci5jb25jYXQoW21zZywgZmllbGRdKTtcbiAgbXNnWzBdIHw9IGZpZWxkU2l6ZTtcbiAgcmV0dXJuIG1zZztcbn1cblxuLyoqXG4gKiBSZXR1cm5zIHRoZSBzaXplIG9mIHRoZSBhdXhpbGlhcnktZmllbGQgd2hpY2ggaW4gdHVybnMgY29udGFpbnMgdGhlIHBheWxvYWQgc2l6ZVxuICovXG5mdW5jdGlvbiBnZXRTaXplT2ZQYXlsb2FkU2l6ZUZpZWxkKHBheWxvYWQ6IFVpbnQ4QXJyYXkpOiBudW1iZXIge1xuICBsZXQgcyA9IDE7XG4gIGZvciAobGV0IGkgPSBwYXlsb2FkLmxlbmd0aDsgaSA+PSAyNTY7IGkgLz0gMjU2KSB7XG4gICAgcysrO1xuICB9XG4gIHJldHVybiBzO1xufVxuXG5mdW5jdGlvbiB2YWxpZGF0ZURhdGFJbnRlZ3JpdHkoXG4gIHZhbHVlOiBVaW50OEFycmF5LFxuICBleHBlY3RlZFNpemU6IG51bWJlclxuKTogYm9vbGVhbiB7XG4gIGlmICh2YWx1ZS5sZW5ndGggIT09IGV4cGVjdGVkU2l6ZSkge1xuICAgIHJldHVybiBmYWxzZTtcbiAgfVxuXG4gIHJldHVybiAhKFxuICAgIGV4cGVjdGVkU2l6ZSA+IDMgJiYgQnVmZmVyLmZyb20odmFsdWUpLmVxdWFscyhCdWZmZXIuYWxsb2ModmFsdWUubGVuZ3RoKSlcbiAgKTtcbn1cblxuZnVuY3Rpb24gZ2V0U2lnbmF0dXJlKG1lc3NhZ2U6IEJ1ZmZlcik6IEJ1ZmZlciB7XG4gIHJldHVybiBtZXNzYWdlLnNsaWNlKG1lc3NhZ2UubGVuZ3RoIC0gU2lnbmF0dXJlTGVuZ3RoLCBtZXNzYWdlLmxlbmd0aCk7XG59XG5cbmZ1bmN0aW9uIGdldEhhc2gobWVzc2FnZTogQnVmZmVyLCBpc1NpZ25lZDogYm9vbGVhbik6IHN0cmluZyB7XG4gIGlmIChpc1NpZ25lZCkge1xuICAgIHJldHVybiBrZWNjYWsyNTYobWVzc2FnZS5zbGljZSgwLCBtZXNzYWdlLmxlbmd0aCAtIFNpZ25hdHVyZUxlbmd0aCkpO1xuICB9XG4gIHJldHVybiBrZWNjYWsyNTYobWVzc2FnZSk7XG59XG5cbmZ1bmN0aW9uIGVjUmVjb3ZlclB1YktleShtZXNzYWdlSGFzaDogc3RyaW5nLCBzaWduYXR1cmU6IEJ1ZmZlcik6IFVpbnQ4QXJyYXkge1xuICBjb25zdCByZWNvdmVyeSA9IHNpZ25hdHVyZS5zbGljZSg2NCkucmVhZEludEJFKDAsIDEpO1xuICByZXR1cm4gc2VjcDI1NmsxLmVjZHNhUmVjb3ZlcihcbiAgICBzaWduYXR1cmUuc2xpY2UoMCwgNjQpLFxuICAgIHJlY292ZXJ5LFxuICAgIGhleFRvQnVmKG1lc3NhZ2VIYXNoKSxcbiAgICBmYWxzZVxuICApO1xufVxuXG5mdW5jdGlvbiByYW5kb21CeXRlcyhsZW5ndGg6IG51bWJlcik6IFVpbnQ4QXJyYXkge1xuICBpZiAodHlwZW9mIHdpbmRvdyAhPT0gJ3VuZGVmaW5lZCcgJiYgd2luZG93ICYmIHdpbmRvdy5jcnlwdG8pIHtcbiAgICBjb25zdCBhcnJheSA9IG5ldyBVaW50OEFycmF5KGxlbmd0aCk7XG4gICAgd2luZG93LmNyeXB0by5nZXRSYW5kb21WYWx1ZXMoYXJyYXkpO1xuICAgIHJldHVybiBhcnJheTtcbiAgfSBlbHNlIHtcbiAgICByZXR1cm4gY3J5cHRvLnJhbmRvbUJ5dGVzKGxlbmd0aCk7XG4gIH1cbn1cbiIsImV4cG9ydCBjb25zdCBzZWNvbmQgPSAxMDAwO1xuZXhwb3J0IGNvbnN0IG1pbnV0ZSA9IDYwICogc2Vjb25kO1xuXG4vKipcbiAqIFJlbGF5Q29kZWMgaXMgdGhlIGxpYnAycCBpZGVudGlmaWVyIGZvciB0aGUgd2FrdSByZWxheSBwcm90b2NvbFxuICovXG5leHBvcnQgY29uc3QgUmVsYXlDb2RlY3MgPSBbXG4gICcvdmFjL3dha3UvcmVsYXkvMi4wLjAtYmV0YTInLFxuICAnL3ZhYy93YWt1L3JlbGF5LzIuMC4wJyxcbl07XG5cbmV4cG9ydCBjb25zdCBSZWxheVBpbmdDb250ZW50VG9waWMgPSAnL3JlbGF5LXBpbmcvMS9waW5nL251bGwnO1xuXG4vKipcbiAqIFJlbGF5R29zc2lwRmFjdG9yIGFmZmVjdHMgaG93IG1hbnkgcGVlcnMgd2Ugd2lsbCBlbWl0IGdvc3NpcCB0byBhdCBlYWNoIGhlYXJ0YmVhdC5cbiAqIFdlIHdpbGwgc2VuZCBnb3NzaXAgdG8gUmVsYXlHb3NzaXBGYWN0b3IgKiAodG90YWwgbnVtYmVyIG9mIG5vbi1tZXNoIHBlZXJzKSwgb3JcbiAqIFJlbGF5RGxhenksIHdoaWNoZXZlciBpcyBncmVhdGVyLlxuICovXG5leHBvcnQgY29uc3QgUmVsYXlHb3NzaXBGYWN0b3IgPSAwLjI1O1xuXG4vKipcbiAqIEdvc3NpcHN1YkhlYXJ0YmVhdEluaXRpYWxEZWxheSBpcyB0aGUgc2hvcnQgZGVsYXkgYmVmb3JlIHRoZSBoZWFydGJlYXQgdGltZXIgYmVnaW5zXG4gKiBhZnRlciB0aGUgcm91dGVyIGlzIGluaXRpYWxpemVkLlxuICovXG5leHBvcnQgY29uc3QgUmVsYXlIZWFydGJlYXRJbml0aWFsRGVsYXkgPSAxMDA7XG5cbi8qKlxuICogUmVsYXlIZWFydGJlYXRJbnRlcnZhbCBjb250cm9scyB0aGUgdGltZSBiZXR3ZWVuIGhlYXJ0YmVhdHMuXG4gKi9cbmV4cG9ydCBjb25zdCBSZWxheUhlYXJ0YmVhdEludGVydmFsID0gc2Vjb25kO1xuXG4vKipcbiAqIFJlbGF5UHJ1bmVQZWVycyBjb250cm9scyB0aGUgbnVtYmVyIG9mIHBlZXJzIHRvIGluY2x1ZGUgaW4gcHJ1bmUgUGVlciBlWGNoYW5nZS5cbiAqIFdoZW4gd2UgcHJ1bmUgYSBwZWVyIHRoYXQncyBlbGlnaWJsZSBmb3IgUFggKGhhcyBhIGdvb2Qgc2NvcmUsIGV0YyksIHdlIHdpbGwgdHJ5IHRvXG4gKiBzZW5kIHRoZW0gc2lnbmVkIHBlZXIgcmVjb3JkcyBmb3IgdXAgdG8gUmVsYXlQcnVuZVBlZXJzIG90aGVyIHBlZXJzIHRoYXQgd2VcbiAqIGtub3cgb2YuXG4gKi9cbmV4cG9ydCBjb25zdCBSZWxheVBydW5lUGVlcnMgPSAxNjtcblxuLyoqXG4gKiBSZWxheVBydW5lQmFja29mZiBjb250cm9scyB0aGUgYmFja29mZiB0aW1lIGZvciBwcnVuZWQgcGVlcnMuIFRoaXMgaXMgaG93IGxvbmdcbiAqIGEgcGVlciBtdXN0IHdhaXQgYmVmb3JlIGF0dGVtcHRpbmcgdG8gZ3JhZnQgaW50byBvdXIgbWVzaCBhZ2FpbiBhZnRlciBiZWluZyBwcnVuZWQuXG4gKiBXaGVuIHBydW5pbmcgYSBwZWVyLCB3ZSBzZW5kIHRoZW0gb3VyIHZhbHVlIG9mIFJlbGF5UHJ1bmVCYWNrb2ZmIHNvIHRoZXkga25vd1xuICogdGhlIG1pbmltdW0gdGltZSB0byB3YWl0LiBQZWVycyBydW5uaW5nIG9sZGVyIHZlcnNpb25zIG1heSBub3Qgc2VuZCBhIGJhY2tvZmYgdGltZSxcbiAqIHNvIGlmIHdlIHJlY2VpdmUgYSBwcnVuZSBtZXNzYWdlIHdpdGhvdXQgb25lLCB3ZSB3aWxsIHdhaXQgYXQgbGVhc3QgUmVsYXlQcnVuZUJhY2tvZmZcbiAqIGJlZm9yZSBhdHRlbXB0aW5nIHRvIHJlLWdyYWZ0LlxuICovXG5leHBvcnQgY29uc3QgUmVsYXlQcnVuZUJhY2tvZmYgPSBtaW51dGU7XG5cbi8qKlxuICogUmVsYXlGYW5vdXRUVEwgY29udHJvbHMgaG93IGxvbmcgd2Uga2VlcCB0cmFjayBvZiB0aGUgZmFub3V0IHN0YXRlLiBJZiBpdCdzIGJlZW5cbiAqIFJlbGF5RmFub3V0VFRMIHNpbmNlIHdlJ3ZlIHB1Ymxpc2hlZCB0byBhIHRvcGljIHRoYXQgd2UncmUgbm90IHN1YnNjcmliZWQgdG8sXG4gKiB3ZSdsbCBkZWxldGUgdGhlIGZhbm91dCBtYXAgZm9yIHRoYXQgdG9waWMuXG4gKi9cbmV4cG9ydCBjb25zdCBSZWxheUZhbm91dFRUTCA9IG1pbnV0ZTtcblxuLyoqXG4gKiBSZWxheU9wcG9ydHVuaXN0aWNHcmFmdFRpY2tzIGlzIHRoZSBudW1iZXIgb2YgaGVhcnRiZWF0IHRpY2tzIGZvciBhdHRlbXB0aW5nIHRvIGltcHJvdmUgdGhlIG1lc2hcbiAqIHdpdGggb3Bwb3J0dW5pc3RpYyBncmFmdGluZy4gRXZlcnkgUmVsYXlPcHBvcnR1bmlzdGljR3JhZnRUaWNrcyB3ZSB3aWxsIGF0dGVtcHQgdG8gc2VsZWN0IHNvbWVcbiAqIGhpZ2gtc2NvcmluZyBtZXNoIHBlZXJzIHRvIHJlcGxhY2UgbG93ZXItc2NvcmluZyBvbmVzLCBpZiB0aGUgbWVkaWFuIHNjb3JlIG9mIG91ciBtZXNoIHBlZXJzIGZhbGxzXG4gKiBiZWxvdyBhIHRocmVzaG9sZFxuICovXG5leHBvcnQgY29uc3QgUmVsYXlPcHBvcnR1bmlzdGljR3JhZnRUaWNrcyA9IDYwO1xuXG4vKipcbiAqIFJlbGF5T3Bwb3J0dW5pc3RpY0dyYWZ0UGVlcnMgaXMgdGhlIG51bWJlciBvZiBwZWVycyB0byBvcHBvcnR1bmlzdGljYWxseSBncmFmdC5cbiAqL1xuZXhwb3J0IGNvbnN0IFJlbGF5T3Bwb3J0dW5pc3RpY0dyYWZ0UGVlcnMgPSAyO1xuXG4vKipcbiAqIFJlbGF5TWF4SUhhdmVMZW5ndGggaXMgdGhlIG1heGltdW0gbnVtYmVyIG9mIG1lc3NhZ2VzIHRvIGluY2x1ZGUgaW4gYW4gSUhBVkUgbWVzc2FnZS5cbiAqIEFsc28gY29udHJvbHMgdGhlIG1heGltdW0gbnVtYmVyIG9mIElIQVZFIGlkcyB3ZSB3aWxsIGFjY2VwdCBhbmQgcmVxdWVzdCB3aXRoIElXQU5UIGZyb20gYVxuICogcGVlciB3aXRoaW4gYSBoZWFydGJlYXQsIHRvIHByb3RlY3QgZnJvbSBJSEFWRSBmbG9vZHMuIFlvdSBzaG91bGQgYWRqdXN0IHRoaXMgdmFsdWUgZnJvbSB0aGVcbiAqIGRlZmF1bHQgaWYgeW91ciBzeXN0ZW0gaXMgcHVzaGluZyBtb3JlIHRoYW4gNTAwMCBtZXNzYWdlcyBpbiBHb3NzaXBzdWJIaXN0b3J5R29zc2lwIGhlYXJ0YmVhdHM7XG4gKiB3aXRoIHRoZSBkZWZhdWx0cyB0aGlzIGlzIDE2NjYgbWVzc2FnZXMvcy5cbiAqL1xuZXhwb3J0IGNvbnN0IFJlbGF5TWF4SUhhdmVMZW5ndGggPSA1MDAwO1xuIiwiaW1wb3J0IEdvc3NpcHN1YiBmcm9tICdsaWJwMnAtZ29zc2lwc3ViJztcbmltcG9ydCB7IHNodWZmbGUgfSBmcm9tICdsaWJwMnAtZ29zc2lwc3ViL3NyYy91dGlscyc7XG5cbmltcG9ydCB7IFJlbGF5Q29kZWNzIH0gZnJvbSAnLi9pbmRleCc7XG5cbi8qKlxuICogR2l2ZW4gYSB0b3BpYywgcmV0dXJucyB1cCB0byBjb3VudCBwZWVycyBzdWJzY3JpYmVkIHRvIHRoYXQgdG9waWNcbiAqIHRoYXQgcGFzcyBhbiBvcHRpb25hbCBmaWx0ZXIgZnVuY3Rpb25cbiAqXG4gKiBAcGFyYW0ge0dvc3NpcHN1Yn0gcm91dGVyXG4gKiBAcGFyYW0ge1N0cmluZ30gdG9waWNcbiAqIEBwYXJhbSB7TnVtYmVyfSBjb3VudFxuICogQHBhcmFtIHtGdW5jdGlvbn0gW2ZpbHRlcl0gYSBmdW5jdGlvbiB0byBmaWx0ZXIgYWNjZXB0YWJsZSBwZWVyc1xuICogQHJldHVybnMge1NldDxzdHJpbmc+fVxuICpcbiAqL1xuZXhwb3J0IGZ1bmN0aW9uIGdldFJlbGF5UGVlcnMoXG4gIHJvdXRlcjogR29zc2lwc3ViLFxuICB0b3BpYzogc3RyaW5nLFxuICBjb3VudDogbnVtYmVyLFxuICBmaWx0ZXI6IChpZDogc3RyaW5nKSA9PiBib29sZWFuID0gKCk6IGJvb2xlYW4gPT4gdHJ1ZVxuKTogU2V0PHN0cmluZz4ge1xuICBjb25zdCBwZWVyc0luVG9waWMgPSByb3V0ZXIudG9waWNzLmdldCh0b3BpYyk7XG4gIGlmICghcGVlcnNJblRvcGljKSB7XG4gICAgcmV0dXJuIG5ldyBTZXQoKTtcbiAgfVxuXG4gIC8vIEFkZHMgYWxsIHBlZXJzIHVzaW5nIG91ciBwcm90b2NvbFxuICAvLyB0aGF0IGFsc28gcGFzcyB0aGUgZmlsdGVyIGZ1bmN0aW9uXG4gIGxldCBwZWVyczogc3RyaW5nW10gPSBbXTtcbiAgcGVlcnNJblRvcGljLmZvckVhY2goKGlkOiBzdHJpbmcpID0+IHtcbiAgICBjb25zdCBwZWVyU3RyZWFtcyA9IHJvdXRlci5wZWVycy5nZXQoaWQpO1xuICAgIGlmICghcGVlclN0cmVhbXMpIHtcbiAgICAgIHJldHVybjtcbiAgICB9XG4gICAgaWYgKFJlbGF5Q29kZWNzLmluY2x1ZGVzKHBlZXJTdHJlYW1zLnByb3RvY29sKSAmJiBmaWx0ZXIoaWQpKSB7XG4gICAgICBwZWVycy5wdXNoKGlkKTtcbiAgICB9XG4gIH0pO1xuXG4gIC8vIFBzZXVkby1yYW5kb21seSBzaHVmZmxlcyBwZWVyc1xuICBwZWVycyA9IHNodWZmbGUocGVlcnMpO1xuICBpZiAoY291bnQgPiAwICYmIHBlZXJzLmxlbmd0aCA+IGNvdW50KSB7XG4gICAgcGVlcnMgPSBwZWVycy5zbGljZSgwLCBjb3VudCk7XG4gIH1cblxuICByZXR1cm4gbmV3IFNldChwZWVycyk7XG59XG4iLCJpbXBvcnQgZGVidWcgZnJvbSAnZGVidWcnO1xuaW1wb3J0IExpYnAycCBmcm9tICdsaWJwMnAnO1xuaW1wb3J0IEdvc3NpcHN1YiBmcm9tICdsaWJwMnAtZ29zc2lwc3ViJztcbmltcG9ydCB7IEFkZHJJbmZvLCBNZXNzYWdlSWRGdW5jdGlvbiB9IGZyb20gJ2xpYnAycC1nb3NzaXBzdWIvc3JjL2ludGVyZmFjZXMnO1xuaW1wb3J0IHsgTWVzc2FnZUNhY2hlIH0gZnJvbSAnbGlicDJwLWdvc3NpcHN1Yi9zcmMvbWVzc2FnZS1jYWNoZSc7XG5pbXBvcnQgeyBSUEMgfSBmcm9tICdsaWJwMnAtZ29zc2lwc3ViL3NyYy9tZXNzYWdlL3JwYyc7XG5pbXBvcnQge1xuICBQZWVyU2NvcmVQYXJhbXMsXG4gIFBlZXJTY29yZVRocmVzaG9sZHMsXG59IGZyb20gJ2xpYnAycC1nb3NzaXBzdWIvc3JjL3Njb3JlJztcbmltcG9ydCB7XG4gIGNyZWF0ZUdvc3NpcFJwYyxcbiAgbWVzc2FnZUlkVG9TdHJpbmcsXG4gIHNodWZmbGUsXG59IGZyb20gJ2xpYnAycC1nb3NzaXBzdWIvc3JjL3V0aWxzJztcbmltcG9ydCB7IEluTWVzc2FnZSB9IGZyb20gJ2xpYnAycC1pbnRlcmZhY2VzL3NyYy9wdWJzdWInO1xuaW1wb3J0IHsgU2lnbmF0dXJlUG9saWN5IH0gZnJvbSAnbGlicDJwLWludGVyZmFjZXMvc3JjL3B1YnN1Yi9zaWduYXR1cmUtcG9saWN5JztcbmltcG9ydCBQZWVySWQgZnJvbSAncGVlci1pZCc7XG5cbmltcG9ydCB7IGhleFRvQnVmIH0gZnJvbSAnLi4vdXRpbHMnO1xuaW1wb3J0IHsgQ3JlYXRlT3B0aW9ucywgRGVmYXVsdFB1YlN1YlRvcGljIH0gZnJvbSAnLi4vd2FrdSc7XG5pbXBvcnQgeyBXYWt1TWVzc2FnZSB9IGZyb20gJy4uL3dha3VfbWVzc2FnZSc7XG5cbmltcG9ydCAqIGFzIGNvbnN0YW50cyBmcm9tICcuL2NvbnN0YW50cyc7XG5pbXBvcnQgeyBSZWxheUNvZGVjcyB9IGZyb20gJy4vY29uc3RhbnRzJztcbmltcG9ydCB7IGdldFJlbGF5UGVlcnMgfSBmcm9tICcuL2dldF9yZWxheV9wZWVycyc7XG5pbXBvcnQgeyBSZWxheUhlYXJ0YmVhdCB9IGZyb20gJy4vcmVsYXlfaGVhcnRiZWF0JztcblxuY29uc3QgZGJnID0gZGVidWcoJ3dha3U6cmVsYXknKTtcblxuZXhwb3J0IHsgUmVsYXlDb2RlY3MgfTtcblxuLyoqXG4gKiBTZWUgY29uc3RydWN0b3IgbGlicDJwLWdvc3NpcHN1YiBbQVBJXShodHRwczovL2dpdGh1Yi5jb20vQ2hhaW5TYWZlL2pzLWxpYnAycC1nb3NzaXBzdWIjYXBpKS5cbiAqL1xuZXhwb3J0IGludGVyZmFjZSBHb3NzaXBPcHRpb25zIHtcbiAgZW1pdFNlbGY6IGJvb2xlYW47XG4gIGdvc3NpcEluY29taW5nOiBib29sZWFuO1xuICBmYWxsYmFja1RvRmxvb2RzdWI6IGJvb2xlYW47XG4gIGZsb29kUHVibGlzaDogYm9vbGVhbjtcbiAgZG9QWDogYm9vbGVhbjtcbiAgbXNnSWRGbjogTWVzc2FnZUlkRnVuY3Rpb247XG4gIG1lc3NhZ2VDYWNoZTogTWVzc2FnZUNhY2hlO1xuICAvLyBUaGlzIG9wdGlvbiBpcyBhbHdheXMgb3ZlcnJpZGRlblxuICAvLyBnbG9iYWxTaWduYXR1cmVQb2xpY3k6IHN0cmluZztcbiAgc2NvcmVQYXJhbXM6IFBhcnRpYWw8UGVlclNjb3JlUGFyYW1zPjtcbiAgc2NvcmVUaHJlc2hvbGRzOiBQYXJ0aWFsPFBlZXJTY29yZVRocmVzaG9sZHM+O1xuICBkaXJlY3RQZWVyczogQWRkckluZm9bXTtcbiAgRDogbnVtYmVyO1xuICBEbG86IG51bWJlcjtcbiAgRGhpOiBudW1iZXI7XG4gIERzY29yZTogbnVtYmVyO1xuICBEb3V0OiBudW1iZXI7XG4gIERsYXp5OiBudW1iZXI7XG59XG5cbi8qKlxuICogSW1wbGVtZW50cyB0aGUgW1dha3UgdjIgUmVsYXkgcHJvdG9jb2xde0BsaW5rIGh0dHBzOi8vcmZjLnZhYy5kZXYvc3BlYy8xMS99LlxuICogTXVzdCBiZSBwYXNzZWQgYXMgYSBgcHVic3ViYCBtb2R1bGUgdG8gYSB7TGlicDJwfSBpbnN0YW5jZS5cbiAqXG4gKiBAaW1wbGVtZW50cyB7cmVxdWlyZSgnbGlicDJwLWludGVyZmFjZXMvc3JjL3B1YnN1YicpfVxuICogQG5vSW5oZXJpdERvY1xuICovXG5leHBvcnQgY2xhc3MgV2FrdVJlbGF5IGV4dGVuZHMgR29zc2lwc3ViIHtcbiAgaGVhcnRiZWF0OiBSZWxheUhlYXJ0YmVhdDtcbiAgcHViU3ViVG9waWM6IHN0cmluZztcblxuICBwdWJsaWMgZGVjcnlwdGlvbktleXM6IFNldDxVaW50OEFycmF5PjtcblxuICAvKipcbiAgICogb2JzZXJ2ZXJzIGNhbGxlZCB3aGVuIHJlY2VpdmluZyBuZXcgbWVzc2FnZS5cbiAgICogT2JzZXJ2ZXJzIHVuZGVyIGtleSBgXCJcImAgYXJlIGFsd2F5cyBjYWxsZWQuXG4gICAqL1xuICBwdWJsaWMgb2JzZXJ2ZXJzOiB7XG4gICAgW2NvbnRlbnRUb3BpYzogc3RyaW5nXTogU2V0PChtZXNzYWdlOiBXYWt1TWVzc2FnZSkgPT4gdm9pZD47XG4gIH07XG5cbiAgY29uc3RydWN0b3IoXG4gICAgbGlicDJwOiBMaWJwMnAsXG4gICAgb3B0aW9ucz86IFBhcnRpYWw8Q3JlYXRlT3B0aW9ucyAmIEdvc3NpcE9wdGlvbnM+XG4gICkge1xuICAgIHN1cGVyKFxuICAgICAgbGlicDJwLFxuICAgICAgT2JqZWN0LmFzc2lnbihvcHRpb25zLCB7XG4gICAgICAgIC8vIEVuc3VyZSB0aGF0IG5vIHNpZ25hdHVyZSBpcyBpbmNsdWRlZCBub3IgZXhwZWN0ZWQgaW4gdGhlIG1lc3NhZ2VzLlxuICAgICAgICBnbG9iYWxTaWduYXR1cmVQb2xpY3k6IFNpZ25hdHVyZVBvbGljeS5TdHJpY3ROb1NpZ24sXG4gICAgICB9KVxuICAgICk7XG5cbiAgICB0aGlzLmhlYXJ0YmVhdCA9IG5ldyBSZWxheUhlYXJ0YmVhdCh0aGlzKTtcbiAgICB0aGlzLm9ic2VydmVycyA9IHt9O1xuICAgIHRoaXMuZGVjcnlwdGlvbktleXMgPSBuZXcgU2V0KCk7XG5cbiAgICBjb25zdCBtdWx0aWNvZGVjcyA9IGNvbnN0YW50cy5SZWxheUNvZGVjcztcblxuICAgIE9iamVjdC5hc3NpZ24odGhpcywgeyBtdWx0aWNvZGVjcyB9KTtcblxuICAgIHRoaXMucHViU3ViVG9waWMgPSBvcHRpb25zPy5wdWJTdWJUb3BpYyB8fCBEZWZhdWx0UHViU3ViVG9waWM7XG4gIH1cblxuICAvKipcbiAgICogTW91bnRzIHRoZSBnb3NzaXBzdWIgcHJvdG9jb2wgb250byB0aGUgbGlicDJwIG5vZGVcbiAgICogYW5kIHN1YnNjcmliZXMgdG8gdGhlIGRlZmF1bHQgdG9waWMuXG4gICAqXG4gICAqIEBvdmVycmlkZVxuICAgKiBAcmV0dXJucyB7dm9pZH1cbiAgICovXG4gIHB1YmxpYyBzdGFydCgpOiB2b2lkIHtcbiAgICBzdXBlci5zdGFydCgpO1xuICAgIHRoaXMuc3Vic2NyaWJlKHRoaXMucHViU3ViVG9waWMpO1xuICB9XG5cbiAgLyoqXG4gICAqIFNlbmQgV2FrdSBtZXNzYWdlLlxuICAgKlxuICAgKiBAcGFyYW0ge1dha3VNZXNzYWdlfSBtZXNzYWdlXG4gICAqIEByZXR1cm5zIHtQcm9taXNlPHZvaWQ+fVxuICAgKi9cbiAgcHVibGljIGFzeW5jIHNlbmQobWVzc2FnZTogV2FrdU1lc3NhZ2UpOiBQcm9taXNlPHZvaWQ+IHtcbiAgICBjb25zdCBtc2cgPSBtZXNzYWdlLmVuY29kZSgpO1xuICAgIGF3YWl0IHN1cGVyLnB1Ymxpc2godGhpcy5wdWJTdWJUb3BpYywgQnVmZmVyLmZyb20obXNnKSk7XG4gIH1cblxuICAvKipcbiAgICogUmVnaXN0ZXIgYSBkZWNyeXB0aW9uIGtleSB0byBhdHRlbXB0IGRlY3J5cHRpb24gb2YgcmVjZWl2ZWQgbWVzc2FnZXMuXG4gICAqIFRoaXMgY2FuIGVpdGhlciBiZSBhIHByaXZhdGUga2V5IGZvciBhc3ltbWV0cmljIGVuY3J5cHRpb24gb3IgYSBzeW1tZXRyaWNcbiAgICoga2V5LiBgV2FrdVJlbGF5YCB3aWxsIGF0dGVtcHQgdG8gZGVjcnlwdCBtZXNzYWdlcyB1c2luZyBib3RoIG1ldGhvZHMuXG4gICAqXG4gICAqIFN0cmluZ3MgbXVzdCBiZSBpbiBoZXggZm9ybWF0LlxuICAgKi9cbiAgYWRkRGVjcnlwdGlvbktleShrZXk6IFVpbnQ4QXJyYXkgfCBzdHJpbmcpOiB2b2lkIHtcbiAgICB0aGlzLmRlY3J5cHRpb25LZXlzLmFkZChoZXhUb0J1ZihrZXkpKTtcbiAgfVxuXG4gIC8qKlxuICAgKiBEZWxldGUgYSBkZWNyeXB0aW9uIGtleSB0aGF0IHdhcyB1c2VkIHRvIGF0dGVtcHQgZGVjcnlwdGlvbiBvZiByZWNlaXZlZFxuICAgKiBtZXNzYWdlcy5cbiAgICpcbiAgICogU3RyaW5ncyBtdXN0IGJlIGluIGhleCBmb3JtYXQuXG4gICAqL1xuICBkZWxldGVEZWNyeXB0aW9uS2V5KGtleTogVWludDhBcnJheSB8IHN0cmluZyk6IHZvaWQge1xuICAgIHRoaXMuZGVjcnlwdGlvbktleXMuZGVsZXRlKGhleFRvQnVmKGtleSkpO1xuICB9XG5cbiAgLyoqXG4gICAqIFJlZ2lzdGVyIGFuIG9ic2VydmVyIG9mIG5ldyBtZXNzYWdlcyByZWNlaXZlZCB2aWEgd2FrdSByZWxheVxuICAgKlxuICAgKiBAcGFyYW0gY2FsbGJhY2sgY2FsbGVkIHdoZW4gYSBuZXcgbWVzc2FnZSBpcyByZWNlaXZlZCB2aWEgd2FrdSByZWxheVxuICAgKiBAcGFyYW0gY29udGVudFRvcGljcyBDb250ZW50IFRvcGljcyBmb3Igd2hpY2ggdGhlIGNhbGxiYWNrIHdpdGggYmUgY2FsbGVkLFxuICAgKiBhbGwgb2YgdGhlbSBpZiB1bmRlZmluZWQsIFtdIG9yIFtcIlwiLC4uXSBpcyBwYXNzZWQuXG4gICAqIEByZXR1cm5zIHt2b2lkfVxuICAgKi9cbiAgYWRkT2JzZXJ2ZXIoXG4gICAgY2FsbGJhY2s6IChtZXNzYWdlOiBXYWt1TWVzc2FnZSkgPT4gdm9pZCxcbiAgICBjb250ZW50VG9waWNzOiBzdHJpbmdbXSA9IFtdXG4gICk6IHZvaWQge1xuICAgIGlmIChjb250ZW50VG9waWNzLmxlbmd0aCA9PT0gMCkge1xuICAgICAgaWYgKCF0aGlzLm9ic2VydmVyc1snJ10pIHtcbiAgICAgICAgdGhpcy5vYnNlcnZlcnNbJyddID0gbmV3IFNldCgpO1xuICAgICAgfVxuICAgICAgdGhpcy5vYnNlcnZlcnNbJyddLmFkZChjYWxsYmFjayk7XG4gICAgfSBlbHNlIHtcbiAgICAgIGNvbnRlbnRUb3BpY3MuZm9yRWFjaCgoY29udGVudFRvcGljKSA9PiB7XG4gICAgICAgIGlmICghdGhpcy5vYnNlcnZlcnNbY29udGVudFRvcGljXSkge1xuICAgICAgICAgIHRoaXMub2JzZXJ2ZXJzW2NvbnRlbnRUb3BpY10gPSBuZXcgU2V0KCk7XG4gICAgICAgIH1cbiAgICAgICAgdGhpcy5vYnNlcnZlcnNbY29udGVudFRvcGljXS5hZGQoY2FsbGJhY2spO1xuICAgICAgfSk7XG4gICAgfVxuICB9XG5cbiAgLyoqXG4gICAqIFJlbW92ZSBhbiBvYnNlcnZlciBvZiBuZXcgbWVzc2FnZXMgcmVjZWl2ZWQgdmlhIHdha3UgcmVsYXkuXG4gICAqIFVzZWZ1bCB0byBlbnN1cmUgdGhlIHNhbWUgb2JzZXJ2ZXIgaXMgbm90IHJlZ2lzdGVyZWQgc2V2ZXJhbCB0aW1lXG4gICAqIChlLmcgd2hlbiBsb2FkaW5nIFJlYWN0IGNvbXBvbmVudHMpXG4gICAqL1xuICBkZWxldGVPYnNlcnZlcihcbiAgICBjYWxsYmFjazogKG1lc3NhZ2U6IFdha3VNZXNzYWdlKSA9PiB2b2lkLFxuICAgIGNvbnRlbnRUb3BpY3M6IHN0cmluZ1tdID0gW11cbiAgKTogdm9pZCB7XG4gICAgaWYgKGNvbnRlbnRUb3BpY3MubGVuZ3RoID09PSAwKSB7XG4gICAgICBpZiAodGhpcy5vYnNlcnZlcnNbJyddKSB7XG4gICAgICAgIHRoaXMub2JzZXJ2ZXJzWycnXS5kZWxldGUoY2FsbGJhY2spO1xuICAgICAgfVxuICAgIH0gZWxzZSB7XG4gICAgICBjb250ZW50VG9waWNzLmZvckVhY2goKGNvbnRlbnRUb3BpYykgPT4ge1xuICAgICAgICBpZiAodGhpcy5vYnNlcnZlcnNbY29udGVudFRvcGljXSkge1xuICAgICAgICAgIHRoaXMub2JzZXJ2ZXJzW2NvbnRlbnRUb3BpY10uZGVsZXRlKGNhbGxiYWNrKTtcbiAgICAgICAgfVxuICAgICAgfSk7XG4gICAgfVxuICB9XG5cbiAgLyoqXG4gICAqIFJldHVybiB0aGUgcmVsYXkgcGVlcnMgd2UgYXJlIGNvbm5lY3RlZCB0byBhbmQgd2Ugd291bGQgcHVibGlzaCBhIG1lc3NhZ2UgdG9cbiAgICovXG4gIGdldFBlZXJzKCk6IFNldDxzdHJpbmc+IHtcbiAgICByZXR1cm4gZ2V0UmVsYXlQZWVycyh0aGlzLCB0aGlzLnB1YlN1YlRvcGljLCB0aGlzLl9vcHRpb25zLkQsIChpZCkgPT4ge1xuICAgICAgLy8gRmlsdGVyIHBlZXJzIHdlIHdvdWxkIG5vdCBwdWJsaXNoIHRvXG4gICAgICByZXR1cm4gKFxuICAgICAgICB0aGlzLnNjb3JlLnNjb3JlKGlkKSA+PSB0aGlzLl9vcHRpb25zLnNjb3JlVGhyZXNob2xkcy5wdWJsaXNoVGhyZXNob2xkXG4gICAgICApO1xuICAgIH0pO1xuICB9XG5cbiAgLyoqXG4gICAqIFN1YnNjcmliZSB0byBhIHB1YnN1YiB0b3BpYyBhbmQgc3RhcnQgZW1pdHRpbmcgV2FrdSBtZXNzYWdlcyB0byBvYnNlcnZlcnMuXG4gICAqXG4gICAqIEBvdmVycmlkZVxuICAgKi9cbiAgc3Vic2NyaWJlKHB1YlN1YlRvcGljOiBzdHJpbmcpOiB2b2lkIHtcbiAgICB0aGlzLm9uKHB1YlN1YlRvcGljLCAoZXZlbnQpID0+IHtcbiAgICAgIGRiZyhgTWVzc2FnZSByZWNlaXZlZCBvbiAke3B1YlN1YlRvcGljfWApO1xuICAgICAgV2FrdU1lc3NhZ2UuZGVjb2RlKGV2ZW50LmRhdGEsIEFycmF5LmZyb20odGhpcy5kZWNyeXB0aW9uS2V5cykpXG4gICAgICAgIC50aGVuKCh3YWt1TXNnKSA9PiB7XG4gICAgICAgICAgaWYgKCF3YWt1TXNnKSB7XG4gICAgICAgICAgICBkYmcoJ0ZhaWxlZCB0byBkZWNvZGUgV2FrdSBNZXNzYWdlJyk7XG4gICAgICAgICAgICByZXR1cm47XG4gICAgICAgICAgfVxuXG4gICAgICAgICAgaWYgKHRoaXMub2JzZXJ2ZXJzWycnXSkge1xuICAgICAgICAgICAgdGhpcy5vYnNlcnZlcnNbJyddLmZvckVhY2goKGNhbGxiYWNrRm4pID0+IHtcbiAgICAgICAgICAgICAgY2FsbGJhY2tGbih3YWt1TXNnKTtcbiAgICAgICAgICAgIH0pO1xuICAgICAgICAgIH1cbiAgICAgICAgICBpZiAod2FrdU1zZy5jb250ZW50VG9waWMpIHtcbiAgICAgICAgICAgIGlmICh0aGlzLm9ic2VydmVyc1t3YWt1TXNnLmNvbnRlbnRUb3BpY10pIHtcbiAgICAgICAgICAgICAgdGhpcy5vYnNlcnZlcnNbd2FrdU1zZy5jb250ZW50VG9waWNdLmZvckVhY2goKGNhbGxiYWNrRm4pID0+IHtcbiAgICAgICAgICAgICAgICBjYWxsYmFja0ZuKHdha3VNc2cpO1xuICAgICAgICAgICAgICB9KTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICB9XG4gICAgICAgIH0pXG4gICAgICAgIC5jYXRjaCgoZSkgPT4ge1xuICAgICAgICAgIGRiZygnRmFpbGVkIHRvIGRlY29kZSBXYWt1IE1lc3NhZ2UnLCBlKTtcbiAgICAgICAgfSk7XG4gICAgfSk7XG5cbiAgICBzdXBlci5zdWJzY3JpYmUocHViU3ViVG9waWMpO1xuICB9XG5cbiAgLyoqXG4gICAqIEpvaW4gcHVic3ViIHRvcGljLlxuICAgKiBUaGlzIGlzIHByZXNlbnQgdG8gb3ZlcnJpZGUgdGhlIGJlaGF2aW9yIG9mIEdvc3NpcHN1YiBhbmQgc2hvdWxkIG5vdFxuICAgKiBiZSB1c2VkIGJ5IEFQSSBDb25zdW1lcnNcbiAgICpcbiAgICogQGludGVybmFsXG4gICAqIEBwYXJhbSB7c3RyaW5nfSB0b3BpY1xuICAgKiBAcmV0dXJucyB7dm9pZH1cbiAgICogQG92ZXJyaWRlXG4gICAqL1xuICBqb2luKHRvcGljOiBzdHJpbmcpOiB2b2lkIHtcbiAgICBpZiAoIXRoaXMuc3RhcnRlZCkge1xuICAgICAgdGhyb3cgbmV3IEVycm9yKCdXYWt1UmVsYXlQdWJTdWIgaGFzIG5vdCBzdGFydGVkJyk7XG4gICAgfVxuXG4gICAgY29uc3QgZmFub3V0UGVlcnMgPSB0aGlzLmZhbm91dC5nZXQodG9waWMpO1xuICAgIGlmIChmYW5vdXRQZWVycykge1xuICAgICAgLy8gdGhlc2UgcGVlcnMgaGF2ZSBhIHNjb3JlIGFib3ZlIHRoZSBwdWJsaXNoIHRocmVzaG9sZCwgd2hpY2ggbWF5IGJlIG5lZ2F0aXZlXG4gICAgICAvLyBzbyBkcm9wIHRoZSBvbmVzIHdpdGggYSBuZWdhdGl2ZSBzY29yZVxuICAgICAgZmFub3V0UGVlcnMuZm9yRWFjaCgoaWQpID0+IHtcbiAgICAgICAgaWYgKHRoaXMuc2NvcmUuc2NvcmUoaWQpIDwgMCkge1xuICAgICAgICAgIGZhbm91dFBlZXJzLmRlbGV0ZShpZCk7XG4gICAgICAgIH1cbiAgICAgIH0pO1xuICAgICAgaWYgKGZhbm91dFBlZXJzLnNpemUgPCB0aGlzLl9vcHRpb25zLkQpIHtcbiAgICAgICAgLy8gd2UgbmVlZCBtb3JlIHBlZXJzOyBlYWdlciwgYXMgdGhpcyB3b3VsZCBnZXQgZml4ZWQgaW4gdGhlIG5leHQgaGVhcnRiZWF0XG4gICAgICAgIGdldFJlbGF5UGVlcnMoXG4gICAgICAgICAgdGhpcyxcbiAgICAgICAgICB0b3BpYyxcbiAgICAgICAgICB0aGlzLl9vcHRpb25zLkQgLSBmYW5vdXRQZWVycy5zaXplLFxuICAgICAgICAgIChpZDogc3RyaW5nKTogYm9vbGVhbiA9PiB7XG4gICAgICAgICAgICAvLyBmaWx0ZXIgb3VyIGN1cnJlbnQgcGVlcnMsIGRpcmVjdCBwZWVycywgYW5kIHBlZXJzIHdpdGggbmVnYXRpdmUgc2NvcmVzXG4gICAgICAgICAgICByZXR1cm4gKFxuICAgICAgICAgICAgICAhZmFub3V0UGVlcnMuaGFzKGlkKSAmJlxuICAgICAgICAgICAgICAhdGhpcy5kaXJlY3QuaGFzKGlkKSAmJlxuICAgICAgICAgICAgICB0aGlzLnNjb3JlLnNjb3JlKGlkKSA+PSAwXG4gICAgICAgICAgICApO1xuICAgICAgICAgIH1cbiAgICAgICAgKS5mb3JFYWNoKChpZCkgPT4gZmFub3V0UGVlcnMuYWRkKGlkKSk7XG4gICAgICB9XG4gICAgICB0aGlzLm1lc2guc2V0KHRvcGljLCBmYW5vdXRQZWVycyk7XG4gICAgICB0aGlzLmZhbm91dC5kZWxldGUodG9waWMpO1xuICAgICAgdGhpcy5sYXN0cHViLmRlbGV0ZSh0b3BpYyk7XG4gICAgfSBlbHNlIHtcbiAgICAgIGNvbnN0IHBlZXJzID0gZ2V0UmVsYXlQZWVycyhcbiAgICAgICAgdGhpcyxcbiAgICAgICAgdG9waWMsXG4gICAgICAgIHRoaXMuX29wdGlvbnMuRCxcbiAgICAgICAgKGlkOiBzdHJpbmcpOiBib29sZWFuID0+IHtcbiAgICAgICAgICAvLyBmaWx0ZXIgZGlyZWN0IHBlZXJzIGFuZCBwZWVycyB3aXRoIG5lZ2F0aXZlIHNjb3JlXG4gICAgICAgICAgcmV0dXJuICF0aGlzLmRpcmVjdC5oYXMoaWQpICYmIHRoaXMuc2NvcmUuc2NvcmUoaWQpID49IDA7XG4gICAgICAgIH1cbiAgICAgICk7XG4gICAgICB0aGlzLm1lc2guc2V0KHRvcGljLCBwZWVycyk7XG4gICAgfVxuICAgIHRoaXMubWVzaC5nZXQodG9waWMpPy5mb3JFYWNoKChpZCkgPT4ge1xuICAgICAgdGhpcy5sb2coJ0pPSU46IEFkZCBtZXNoIGxpbmsgdG8gJXMgaW4gJXMnLCBpZCwgdG9waWMpO1xuICAgICAgdGhpcy5fc2VuZEdyYWZ0KGlkLCB0b3BpYyk7XG4gICAgfSk7XG4gIH1cblxuICAvKipcbiAgICogUHVibGlzaCBtZXNzYWdlcy5cbiAgICogVGhpcyBpcyBwcmVzZW50IHRvIG92ZXJyaWRlIHRoZSBiZWhhdmlvciBvZiBHb3NzaXBzdWIgYW5kIHNob3VsZCBub3RcbiAgICogYmUgdXNlZCBieSBBUEkgQ29uc3VtZXJzXG4gICAqXG4gICAqIEBpZ25vcmVcbiAgICogQG92ZXJyaWRlXG4gICAqIEBwYXJhbSB7SW5NZXNzYWdlfSBtc2dcbiAgICogQHJldHVybnMge3ZvaWR9XG4gICAqL1xuICBhc3luYyBfcHVibGlzaChtc2c6IEluTWVzc2FnZSk6IFByb21pc2U8dm9pZD4ge1xuICAgIGlmIChtc2cucmVjZWl2ZWRGcm9tICE9PSB0aGlzLnBlZXJJZC50b0I1OFN0cmluZygpKSB7XG4gICAgICB0aGlzLnNjb3JlLmRlbGl2ZXJNZXNzYWdlKG1zZyk7XG4gICAgICB0aGlzLmdvc3NpcFRyYWNlci5kZWxpdmVyTWVzc2FnZShtc2cpO1xuICAgIH1cblxuICAgIGNvbnN0IG1zZ0lEID0gYXdhaXQgdGhpcy5nZXRNc2dJZChtc2cpO1xuICAgIGNvbnN0IG1zZ0lkU3RyID0gbWVzc2FnZUlkVG9TdHJpbmcobXNnSUQpO1xuICAgIC8vIHB1dCBpbiBzZWVuIGNhY2hlXG4gICAgdGhpcy5zZWVuQ2FjaGUucHV0KG1zZ0lkU3RyKTtcblxuICAgIHRoaXMubWVzc2FnZUNhY2hlLnB1dChtc2cpO1xuXG4gICAgY29uc3QgdG9TZW5kID0gbmV3IFNldDxzdHJpbmc+KCk7XG4gICAgbXNnLnRvcGljSURzLmZvckVhY2goKHRvcGljKSA9PiB7XG4gICAgICBjb25zdCBwZWVyc0luVG9waWMgPSB0aGlzLnRvcGljcy5nZXQodG9waWMpO1xuICAgICAgaWYgKCFwZWVyc0luVG9waWMpIHtcbiAgICAgICAgcmV0dXJuO1xuICAgICAgfVxuXG4gICAgICAvLyBkaXJlY3QgcGVlcnNcbiAgICAgIHRoaXMuZGlyZWN0LmZvckVhY2goKGlkKSA9PiB7XG4gICAgICAgIHRvU2VuZC5hZGQoaWQpO1xuICAgICAgfSk7XG5cbiAgICAgIGxldCBtZXNoUGVlcnMgPSB0aGlzLm1lc2guZ2V0KHRvcGljKTtcbiAgICAgIGlmICghbWVzaFBlZXJzIHx8ICFtZXNoUGVlcnMuc2l6ZSkge1xuICAgICAgICAvLyBXZSBhcmUgbm90IGluIHRoZSBtZXNoIGZvciB0b3BpYywgdXNlIGZhbm91dCBwZWVyc1xuICAgICAgICBtZXNoUGVlcnMgPSB0aGlzLmZhbm91dC5nZXQodG9waWMpO1xuICAgICAgICBpZiAoIW1lc2hQZWVycykge1xuICAgICAgICAgIC8vIElmIHdlIGFyZSBub3QgaW4gdGhlIGZhbm91dCwgdGhlbiBwaWNrIHBlZXJzIGluIHRvcGljIGFib3ZlIHRoZSBwdWJsaXNoVGhyZXNob2xkXG4gICAgICAgICAgY29uc3QgcGVlcnMgPSBnZXRSZWxheVBlZXJzKHRoaXMsIHRvcGljLCB0aGlzLl9vcHRpb25zLkQsIChpZCkgPT4ge1xuICAgICAgICAgICAgcmV0dXJuIChcbiAgICAgICAgICAgICAgdGhpcy5zY29yZS5zY29yZShpZCkgPj1cbiAgICAgICAgICAgICAgdGhpcy5fb3B0aW9ucy5zY29yZVRocmVzaG9sZHMucHVibGlzaFRocmVzaG9sZFxuICAgICAgICAgICAgKTtcbiAgICAgICAgICB9KTtcblxuICAgICAgICAgIGlmIChwZWVycy5zaXplID4gMCkge1xuICAgICAgICAgICAgbWVzaFBlZXJzID0gcGVlcnM7XG4gICAgICAgICAgICB0aGlzLmZhbm91dC5zZXQodG9waWMsIHBlZXJzKTtcbiAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgbWVzaFBlZXJzID0gbmV3IFNldCgpO1xuICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICAvLyBTdG9yZSB0aGUgbGF0ZXN0IHB1Ymxpc2hpbmcgdGltZVxuICAgICAgICB0aGlzLmxhc3RwdWIuc2V0KHRvcGljLCB0aGlzLl9ub3coKSk7XG4gICAgICB9XG5cbiAgICAgIG1lc2hQZWVycz8uZm9yRWFjaCgocGVlcikgPT4ge1xuICAgICAgICB0b1NlbmQuYWRkKHBlZXIpO1xuICAgICAgfSk7XG4gICAgfSk7XG4gICAgLy8gUHVibGlzaCBtZXNzYWdlcyB0byBwZWVyc1xuICAgIGNvbnN0IHJwYyA9IGNyZWF0ZUdvc3NpcFJwYyhbR29zc2lwc3ViLnV0aWxzLm5vcm1hbGl6ZU91dFJwY01lc3NhZ2UobXNnKV0pO1xuICAgIHRvU2VuZC5mb3JFYWNoKChpZCkgPT4ge1xuICAgICAgaWYgKGlkID09PSBtc2cuZnJvbSkge1xuICAgICAgICByZXR1cm47XG4gICAgICB9XG4gICAgICB0aGlzLl9zZW5kUnBjKGlkLCBycGMpO1xuICAgIH0pO1xuICB9XG5cbiAgLyoqXG4gICAqIEVtaXRzIGdvc3NpcCB0byBwZWVycyBpbiBhIHBhcnRpY3VsYXIgdG9waWMuXG4gICAqXG4gICAqIFRoaXMgaXMgcHJlc2VudCB0byBvdmVycmlkZSB0aGUgYmVoYXZpb3Igb2YgR29zc2lwc3ViIGFuZCBzaG91bGQgbm90XG4gICAqIGJlIHVzZWQgYnkgQVBJIENvbnN1bWVyc1xuICAgKlxuICAgKiBAaWdub3JlXG4gICAqIEBvdmVycmlkZVxuICAgKiBAcGFyYW0ge3N0cmluZ30gdG9waWNcbiAgICogQHBhcmFtIHtTZXQ8c3RyaW5nPn0gZXhjbHVkZSBwZWVycyB0byBleGNsdWRlXG4gICAqIEByZXR1cm5zIHt2b2lkfVxuICAgKi9cbiAgX2VtaXRHb3NzaXAodG9waWM6IHN0cmluZywgZXhjbHVkZTogU2V0PHN0cmluZz4pOiB2b2lkIHtcbiAgICBjb25zdCBtZXNzYWdlSURzID0gdGhpcy5tZXNzYWdlQ2FjaGUuZ2V0R29zc2lwSURzKHRvcGljKTtcbiAgICBpZiAoIW1lc3NhZ2VJRHMubGVuZ3RoKSB7XG4gICAgICByZXR1cm47XG4gICAgfVxuXG4gICAgLy8gc2h1ZmZsZSB0byBlbWl0IGluIHJhbmRvbSBvcmRlclxuICAgIHNodWZmbGUobWVzc2FnZUlEcyk7XG5cbiAgICAvLyBpZiB3ZSBhcmUgZW1pdHRpbmcgbW9yZSB0aGFuIEdvc3NpcHN1Yk1heElIYXZlTGVuZ3RoIGlkcywgdHJ1bmNhdGUgdGhlIGxpc3RcbiAgICBpZiAobWVzc2FnZUlEcy5sZW5ndGggPiBjb25zdGFudHMuUmVsYXlNYXhJSGF2ZUxlbmd0aCkge1xuICAgICAgLy8gd2UgZG8gdGhlIHRydW5jYXRpb24gKHdpdGggc2h1ZmZsaW5nKSBwZXIgcGVlciBiZWxvd1xuICAgICAgdGhpcy5sb2coXG4gICAgICAgICd0b28gbWFueSBtZXNzYWdlcyBmb3IgZ29zc2lwOyB3aWxsIHRydW5jYXRlIElIQVZFIGxpc3QgKCVkIG1lc3NhZ2VzKScsXG4gICAgICAgIG1lc3NhZ2VJRHMubGVuZ3RoXG4gICAgICApO1xuICAgIH1cblxuICAgIC8vIFNlbmQgZ29zc2lwIHRvIEdvc3NpcEZhY3RvciBwZWVycyBhYm92ZSB0aHJlc2hvbGQgd2l0aCBhIG1pbmltdW0gb2YgRF9sYXp5XG4gICAgLy8gRmlyc3Qgd2UgY29sbGVjdCB0aGUgcGVlcnMgYWJvdmUgZ29zc2lwVGhyZXNob2xkIHRoYXQgYXJlIG5vdCBpbiB0aGUgZXhjbHVkZSBzZXRcbiAgICAvLyBhbmQgdGhlbiByYW5kb21seSBzZWxlY3QgZnJvbSB0aGF0IHNldFxuICAgIC8vIFdlIGFsc28gZXhjbHVkZSBkaXJlY3QgcGVlcnMsIGFzIHRoZXJlIGlzIG5vIHJlYXNvbiB0byBlbWl0IGdvc3NpcCB0byB0aGVtXG4gICAgY29uc3QgcGVlcnNUb0dvc3NpcDogc3RyaW5nW10gPSBbXTtcbiAgICBjb25zdCB0b3BpY1BlZXJzID0gdGhpcy50b3BpY3MuZ2V0KHRvcGljKTtcbiAgICBpZiAoIXRvcGljUGVlcnMpIHtcbiAgICAgIC8vIG5vIHRvcGljIHBlZXJzLCBubyBnb3NzaXBcbiAgICAgIHJldHVybjtcbiAgICB9XG4gICAgdG9waWNQZWVycy5mb3JFYWNoKChpZCkgPT4ge1xuICAgICAgY29uc3QgcGVlclN0cmVhbXMgPSB0aGlzLnBlZXJzLmdldChpZCk7XG4gICAgICBpZiAoIXBlZXJTdHJlYW1zKSB7XG4gICAgICAgIHJldHVybjtcbiAgICAgIH1cbiAgICAgIGlmIChcbiAgICAgICAgIWV4Y2x1ZGUuaGFzKGlkKSAmJlxuICAgICAgICAhdGhpcy5kaXJlY3QuaGFzKGlkKSAmJlxuICAgICAgICBjb25zdGFudHMuUmVsYXlDb2RlY3MuaW5jbHVkZXMocGVlclN0cmVhbXMucHJvdG9jb2wpICYmXG4gICAgICAgIHRoaXMuc2NvcmUuc2NvcmUoaWQpID49IHRoaXMuX29wdGlvbnMuc2NvcmVUaHJlc2hvbGRzLmdvc3NpcFRocmVzaG9sZFxuICAgICAgKSB7XG4gICAgICAgIHBlZXJzVG9Hb3NzaXAucHVzaChpZCk7XG4gICAgICB9XG4gICAgfSk7XG5cbiAgICBsZXQgdGFyZ2V0ID0gdGhpcy5fb3B0aW9ucy5EbGF6eTtcbiAgICBjb25zdCBmYWN0b3IgPSBjb25zdGFudHMuUmVsYXlHb3NzaXBGYWN0b3IgKiBwZWVyc1RvR29zc2lwLmxlbmd0aDtcbiAgICBpZiAoZmFjdG9yID4gdGFyZ2V0KSB7XG4gICAgICB0YXJnZXQgPSBmYWN0b3I7XG4gICAgfVxuICAgIGlmICh0YXJnZXQgPiBwZWVyc1RvR29zc2lwLmxlbmd0aCkge1xuICAgICAgdGFyZ2V0ID0gcGVlcnNUb0dvc3NpcC5sZW5ndGg7XG4gICAgfSBlbHNlIHtcbiAgICAgIHNodWZmbGUocGVlcnNUb0dvc3NpcCk7XG4gICAgfVxuICAgIC8vIEVtaXQgdGhlIElIQVZFIGdvc3NpcCB0byB0aGUgc2VsZWN0ZWQgcGVlcnMgdXAgdG8gdGhlIHRhcmdldFxuICAgIHBlZXJzVG9Hb3NzaXAuc2xpY2UoMCwgdGFyZ2V0KS5mb3JFYWNoKChpZCkgPT4ge1xuICAgICAgbGV0IHBlZXJNZXNzYWdlSURzID0gbWVzc2FnZUlEcztcbiAgICAgIGlmIChtZXNzYWdlSURzLmxlbmd0aCA+IGNvbnN0YW50cy5SZWxheU1heElIYXZlTGVuZ3RoKSB7XG4gICAgICAgIC8vIHNodWZmbGUgYW5kIHNsaWNlIG1lc3NhZ2UgSURzIHBlciBwZWVyIHNvIHRoYXQgd2UgZW1pdCBhIGRpZmZlcmVudCBzZXQgZm9yIGVhY2ggcGVlclxuICAgICAgICAvLyB3ZSBoYXZlIGVub3VnaCByZWR1bmRhbmN5IGluIHRoZSBzeXN0ZW0gdGhhdCB0aGlzIHdpbGwgc2lnbmlmaWNhbnRseSBpbmNyZWFzZSB0aGUgbWVzc2FnZVxuICAgICAgICAvLyBjb3ZlcmFnZSB3aGVuIHdlIGRvIHRydW5jYXRlXG4gICAgICAgIHBlZXJNZXNzYWdlSURzID0gc2h1ZmZsZShwZWVyTWVzc2FnZUlEcy5zbGljZSgpKS5zbGljZShcbiAgICAgICAgICAwLFxuICAgICAgICAgIGNvbnN0YW50cy5SZWxheU1heElIYXZlTGVuZ3RoXG4gICAgICAgICk7XG4gICAgICB9XG4gICAgICB0aGlzLl9wdXNoR29zc2lwKGlkLCB7XG4gICAgICAgIHRvcGljSUQ6IHRvcGljLFxuICAgICAgICBtZXNzYWdlSURzOiBwZWVyTWVzc2FnZUlEcyxcbiAgICAgIH0pO1xuICAgIH0pO1xuICB9XG5cbiAgLyoqXG4gICAqIE1ha2UgYSBQUlVORSBjb250cm9sIG1lc3NhZ2UgZm9yIGEgcGVlciBpbiBhIHRvcGljLlxuICAgKiBUaGlzIGlzIHByZXNlbnQgdG8gb3ZlcnJpZGUgdGhlIGJlaGF2aW9yIG9mIEdvc3NpcHN1YiBhbmQgc2hvdWxkIG5vdFxuICAgKiBiZSB1c2VkIGJ5IEFQSSBDb25zdW1lcnNcbiAgICpcbiAgICogQGlnbm9yZVxuICAgKiBAb3ZlcnJpZGVcbiAgICogQHBhcmFtIHtzdHJpbmd9IGlkXG4gICAqIEBwYXJhbSB7c3RyaW5nfSB0b3BpY1xuICAgKiBAcGFyYW0ge2Jvb2xlYW59IGRvUFhcbiAgICogQHJldHVybnMge1JQQy5JQ29udHJvbFBydW5lfVxuICAgKi9cbiAgX21ha2VQcnVuZShpZDogc3RyaW5nLCB0b3BpYzogc3RyaW5nLCBkb1BYOiBib29sZWFuKTogUlBDLklDb250cm9sUHJ1bmUge1xuICAgIC8vIGJhY2tvZmYgaXMgbWVhc3VyZWQgaW4gc2Vjb25kc1xuICAgIC8vIFJlbGF5UHJ1bmVCYWNrb2ZmIGlzIG1lYXN1cmVkIGluIG1pbGxpc2Vjb25kc1xuICAgIGNvbnN0IGJhY2tvZmYgPSBjb25zdGFudHMuUmVsYXlQcnVuZUJhY2tvZmYgLyAxMDAwO1xuICAgIGNvbnN0IHB4OiBSUEMuSVBlZXJJbmZvW10gPSBbXTtcbiAgICBpZiAoZG9QWCkge1xuICAgICAgLy8gc2VsZWN0IHBlZXJzIGZvciBQZWVyIGVYY2hhbmdlXG4gICAgICBjb25zdCBwZWVycyA9IGdldFJlbGF5UGVlcnMoXG4gICAgICAgIHRoaXMsXG4gICAgICAgIHRvcGljLFxuICAgICAgICBjb25zdGFudHMuUmVsYXlQcnVuZVBlZXJzLFxuICAgICAgICAoeGlkOiBzdHJpbmcpOiBib29sZWFuID0+IHtcbiAgICAgICAgICByZXR1cm4geGlkICE9PSBpZCAmJiB0aGlzLnNjb3JlLnNjb3JlKHhpZCkgPj0gMDtcbiAgICAgICAgfVxuICAgICAgKTtcbiAgICAgIHBlZXJzLmZvckVhY2goKHApID0+IHtcbiAgICAgICAgLy8gc2VlIGlmIHdlIGhhdmUgYSBzaWduZWQgcmVjb3JkIHRvIHNlbmQgYmFjazsgaWYgd2UgZG9uJ3QsIGp1c3Qgc2VuZFxuICAgICAgICAvLyB0aGUgcGVlciBJRCBhbmQgbGV0IHRoZSBwcnVuZWQgcGVlciBmaW5kIHRoZW0gaW4gdGhlIERIVCAtLSB3ZSBjYW4ndCB0cnVzdFxuICAgICAgICAvLyB1bnNpZ25lZCBhZGRyZXNzIHJlY29yZHMgdGhyb3VnaCBQWCBhbnl3YXlzXG4gICAgICAgIC8vIEZpbmRpbmcgc2lnbmVkIHJlY29yZHMgaW4gdGhlIERIVCBpcyBub3Qgc3VwcG9ydGVkIGF0IHRoZSB0aW1lIG9mIHdyaXRpbmcgaW4ganMtbGlicDJwXG4gICAgICAgIGNvbnN0IHBlZXJJZCA9IFBlZXJJZC5jcmVhdGVGcm9tQjU4U3RyaW5nKHApO1xuICAgICAgICBweC5wdXNoKHtcbiAgICAgICAgICBwZWVySUQ6IHBlZXJJZC50b0J5dGVzKCksXG4gICAgICAgICAgc2lnbmVkUGVlclJlY29yZDpcbiAgICAgICAgICAgIHRoaXMuX2xpYnAycC5wZWVyU3RvcmUuYWRkcmVzc0Jvb2suZ2V0UmF3RW52ZWxvcGUocGVlcklkKSxcbiAgICAgICAgfSk7XG4gICAgICB9KTtcbiAgICB9XG4gICAgcmV0dXJuIHtcbiAgICAgIHRvcGljSUQ6IHRvcGljLFxuICAgICAgcGVlcnM6IHB4LFxuICAgICAgYmFja29mZjogYmFja29mZixcbiAgICB9O1xuICB9XG59XG4iLCIvKipcbiAqIEBoaWRkZW5cbiAqIEBtb2R1bGVcbiAqL1xuXG5pbXBvcnQgR29zc2lwc3ViIGZyb20gJ2xpYnAycC1nb3NzaXBzdWInO1xuaW1wb3J0IHsgSGVhcnRiZWF0IH0gZnJvbSAnbGlicDJwLWdvc3NpcHN1Yi9zcmMvaGVhcnRiZWF0JztcbmltcG9ydCB7IHNodWZmbGUgfSBmcm9tICdsaWJwMnAtZ29zc2lwc3ViL3NyYy91dGlscyc7XG5cbmltcG9ydCAqIGFzIGNvbnN0YW50cyBmcm9tICcuL2NvbnN0YW50cyc7XG5pbXBvcnQgeyBnZXRSZWxheVBlZXJzIH0gZnJvbSAnLi9nZXRfcmVsYXlfcGVlcnMnO1xuXG5leHBvcnQgY2xhc3MgUmVsYXlIZWFydGJlYXQgZXh0ZW5kcyBIZWFydGJlYXQge1xuICAvKipcbiAgICogQHBhcmFtIHtPYmplY3R9IGdvc3NpcHN1YlxuICAgKiBAY29uc3RydWN0b3JcbiAgICovXG4gIGNvbnN0cnVjdG9yKGdvc3NpcHN1YjogR29zc2lwc3ViKSB7XG4gICAgc3VwZXIoZ29zc2lwc3ViKTtcbiAgfVxuXG4gIHN0YXJ0KCk6IHZvaWQge1xuICAgIGlmICh0aGlzLl9oZWFydGJlYXRUaW1lcikge1xuICAgICAgcmV0dXJuO1xuICAgIH1cblxuICAgIGNvbnN0IGhlYXJ0YmVhdCA9IHRoaXMuX2hlYXJ0YmVhdC5iaW5kKHRoaXMpO1xuXG4gICAgY29uc3QgdGltZW91dCA9IHNldFRpbWVvdXQoKCkgPT4ge1xuICAgICAgaGVhcnRiZWF0KCk7XG4gICAgICB0aGlzLl9oZWFydGJlYXRUaW1lcj8ucnVuUGVyaW9kaWNhbGx5KFxuICAgICAgICBoZWFydGJlYXQsXG4gICAgICAgIGNvbnN0YW50cy5SZWxheUhlYXJ0YmVhdEludGVydmFsXG4gICAgICApO1xuICAgIH0sIGNvbnN0YW50cy5SZWxheUhlYXJ0YmVhdEluaXRpYWxEZWxheSk7XG5cbiAgICB0aGlzLl9oZWFydGJlYXRUaW1lciA9IHtcbiAgICAgIF9pbnRlcnZhbElkOiB1bmRlZmluZWQsXG4gICAgICBydW5QZXJpb2RpY2FsbHk6IChmbiwgcGVyaW9kKTogdm9pZCA9PiB7XG4gICAgICAgIC8vIHRoaXMuX2hlYXJ0YmVhdFRpbWVyIGNhbm5vdCBiZSBudWxsLCBpdCBpcyBiZWluZyBhc3NpZ25lZC5cbiAgICAgICAgLy8gZXNsaW50LWRpc2FibGUtbmV4dC1saW5lIEB0eXBlc2NyaXB0LWVzbGludC9uby1ub24tbnVsbC1hc3NlcnRpb25cbiAgICAgICAgdGhpcy5faGVhcnRiZWF0VGltZXIhLl9pbnRlcnZhbElkID0gc2V0SW50ZXJ2YWwoZm4sIHBlcmlvZCk7XG4gICAgICB9LFxuICAgICAgY2FuY2VsOiAoKTogdm9pZCA9PiB7XG4gICAgICAgIGNsZWFyVGltZW91dCh0aW1lb3V0KTtcbiAgICAgICAgY2xlYXJJbnRlcnZhbCh0aGlzLl9oZWFydGJlYXRUaW1lcj8uX2ludGVydmFsSWQgYXMgTm9kZUpTLlRpbWVvdXQpO1xuICAgICAgfSxcbiAgICB9O1xuICB9XG5cbiAgLyoqXG4gICAqIFVubW91bnRzIHRoZSBnb3NzaXBzdWIgcHJvdG9jb2wgYW5kIHNodXRzIGRvd24gZXZlcnkgY29ubmVjdGlvblxuICAgKiBAb3ZlcnJpZGVcbiAgICogQHJldHVybnMge3ZvaWR9XG4gICAqL1xuICBzdG9wKCk6IHZvaWQge1xuICAgIGlmICghdGhpcy5faGVhcnRiZWF0VGltZXIpIHtcbiAgICAgIHJldHVybjtcbiAgICB9XG5cbiAgICB0aGlzLl9oZWFydGJlYXRUaW1lci5jYW5jZWwoKTtcbiAgICB0aGlzLl9oZWFydGJlYXRUaW1lciA9IG51bGw7XG4gIH1cblxuICAvKipcbiAgICogTWFpbnRhaW5zIHRoZSBtZXNoIGFuZCBmYW5vdXQgbWFwcyBpbiBnb3NzaXBzdWIuXG4gICAqXG4gICAqIEByZXR1cm5zIHt2b2lkfVxuICAgKi9cbiAgX2hlYXJ0YmVhdCgpOiB2b2lkIHtcbiAgICBjb25zdCB7IEQsIERsbywgRGhpLCBEc2NvcmUsIERvdXQgfSA9IHRoaXMuZ29zc2lwc3ViLl9vcHRpb25zO1xuICAgIHRoaXMuZ29zc2lwc3ViLmhlYXJ0YmVhdFRpY2tzKys7XG5cbiAgICAvLyBjYWNoZSBzY29yZXMgdGhyb3VnaCB0aGUgaGVhcnRiZWF0XG4gICAgY29uc3Qgc2NvcmVzID0gbmV3IE1hcDxzdHJpbmcsIG51bWJlcj4oKTtcbiAgICBjb25zdCBnZXRTY29yZSA9IChpZDogc3RyaW5nKTogbnVtYmVyID0+IHtcbiAgICAgIGxldCBzID0gc2NvcmVzLmdldChpZCk7XG4gICAgICBpZiAocyA9PT0gdW5kZWZpbmVkKSB7XG4gICAgICAgIHMgPSB0aGlzLmdvc3NpcHN1Yi5zY29yZS5zY29yZShpZCk7XG4gICAgICAgIHNjb3Jlcy5zZXQoaWQsIHMpO1xuICAgICAgfVxuICAgICAgcmV0dXJuIHM7XG4gICAgfTtcblxuICAgIC8vIHBlZXIgaWQgPT4gdG9waWNbXVxuICAgIGNvbnN0IHRvR3JhZnQgPSBuZXcgTWFwPHN0cmluZywgc3RyaW5nW10+KCk7XG4gICAgLy8gcGVlciBpZCA9PiB0b3BpY1tdXG4gICAgY29uc3QgdG9QcnVuZSA9IG5ldyBNYXA8c3RyaW5nLCBzdHJpbmdbXT4oKTtcbiAgICAvLyBwZWVyIGlkID0+IGRvbid0IHB4XG4gICAgY29uc3Qgbm9QWCA9IG5ldyBNYXA8c3RyaW5nLCBib29sZWFuPigpO1xuXG4gICAgLy8gY2xlYW4gdXAgZXhwaXJlZCBiYWNrb2Zmc1xuICAgIHRoaXMuZ29zc2lwc3ViLl9jbGVhckJhY2tvZmYoKTtcblxuICAgIC8vIGNsZWFuIHVwIHBlZXJoYXZlL2lhc2tlZCBjb3VudGVyc1xuICAgIHRoaXMuZ29zc2lwc3ViLnBlZXJoYXZlLmNsZWFyKCk7XG4gICAgdGhpcy5nb3NzaXBzdWIuaWFza2VkLmNsZWFyKCk7XG5cbiAgICAvLyBhcHBseSBJV0FOVCByZXF1ZXN0IHBlbmFsdGllc1xuICAgIHRoaXMuZ29zc2lwc3ViLl9hcHBseUl3YW50UGVuYWx0aWVzKCk7XG5cbiAgICAvLyBlbnN1cmUgZGlyZWN0IHBlZXJzIGFyZSBjb25uZWN0ZWRcbiAgICB0aGlzLmdvc3NpcHN1Yi5fZGlyZWN0Q29ubmVjdCgpO1xuXG4gICAgLy8gbWFpbnRhaW4gdGhlIG1lc2ggZm9yIHRvcGljcyB3ZSBoYXZlIGpvaW5lZFxuICAgIHRoaXMuZ29zc2lwc3ViLm1lc2guZm9yRWFjaCgocGVlcnMsIHRvcGljKSA9PiB7XG4gICAgICAvLyBwcnVuZS9ncmFmdCBoZWxwZXIgZnVuY3Rpb25zIChkZWZpbmVkIHBlciB0b3BpYylcbiAgICAgIGNvbnN0IHBydW5lUGVlciA9IChpZDogc3RyaW5nKTogdm9pZCA9PiB7XG4gICAgICAgIHRoaXMuZ29zc2lwc3ViLmxvZyhcbiAgICAgICAgICAnSEVBUlRCRUFUOiBSZW1vdmUgbWVzaCBsaW5rIHRvICVzIGluICVzJyxcbiAgICAgICAgICBpZCxcbiAgICAgICAgICB0b3BpY1xuICAgICAgICApO1xuICAgICAgICAvLyB1cGRhdGUgcGVlciBzY29yZVxuICAgICAgICB0aGlzLmdvc3NpcHN1Yi5zY29yZS5wcnVuZShpZCwgdG9waWMpO1xuICAgICAgICAvLyBhZGQgcHJ1bmUgYmFja29mZiByZWNvcmRcbiAgICAgICAgdGhpcy5nb3NzaXBzdWIuX2FkZEJhY2tvZmYoaWQsIHRvcGljKTtcbiAgICAgICAgLy8gcmVtb3ZlIHBlZXIgZnJvbSBtZXNoXG4gICAgICAgIHBlZXJzLmRlbGV0ZShpZCk7XG4gICAgICAgIC8vIGFkZCB0byB0b1BydW5lXG4gICAgICAgIGNvbnN0IHRvcGljcyA9IHRvUHJ1bmUuZ2V0KGlkKTtcbiAgICAgICAgaWYgKCF0b3BpY3MpIHtcbiAgICAgICAgICB0b1BydW5lLnNldChpZCwgW3RvcGljXSk7XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgdG9waWNzLnB1c2godG9waWMpO1xuICAgICAgICB9XG4gICAgICB9O1xuICAgICAgY29uc3QgZ3JhZnRQZWVyID0gKGlkOiBzdHJpbmcpOiB2b2lkID0+IHtcbiAgICAgICAgdGhpcy5nb3NzaXBzdWIubG9nKCdIRUFSVEJFQVQ6IEFkZCBtZXNoIGxpbmsgdG8gJXMgaW4gJXMnLCBpZCwgdG9waWMpO1xuICAgICAgICAvLyB1cGRhdGUgcGVlciBzY29yZVxuICAgICAgICB0aGlzLmdvc3NpcHN1Yi5zY29yZS5ncmFmdChpZCwgdG9waWMpO1xuICAgICAgICAvLyBhZGQgcGVlciB0byBtZXNoXG4gICAgICAgIHBlZXJzLmFkZChpZCk7XG4gICAgICAgIC8vIGFkZCB0byB0b0dyYWZ0XG4gICAgICAgIGNvbnN0IHRvcGljcyA9IHRvR3JhZnQuZ2V0KGlkKTtcbiAgICAgICAgaWYgKCF0b3BpY3MpIHtcbiAgICAgICAgICB0b0dyYWZ0LnNldChpZCwgW3RvcGljXSk7XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgdG9waWNzLnB1c2godG9waWMpO1xuICAgICAgICB9XG4gICAgICB9O1xuXG4gICAgICAvLyBkcm9wIGFsbCBwZWVycyB3aXRoIG5lZ2F0aXZlIHNjb3JlLCB3aXRob3V0IFBYXG4gICAgICBwZWVycy5mb3JFYWNoKChpZCkgPT4ge1xuICAgICAgICBjb25zdCBzY29yZSA9IGdldFNjb3JlKGlkKTtcbiAgICAgICAgaWYgKHNjb3JlIDwgMCkge1xuICAgICAgICAgIHRoaXMuZ29zc2lwc3ViLmxvZyhcbiAgICAgICAgICAgICdIRUFSVEJFQVQ6IFBydW5lIHBlZXIgJXMgd2l0aCBuZWdhdGl2ZSBzY29yZTogc2NvcmU9JWQsIHRvcGljPSVzJyxcbiAgICAgICAgICAgIGlkLFxuICAgICAgICAgICAgc2NvcmUsXG4gICAgICAgICAgICB0b3BpY1xuICAgICAgICAgICk7XG4gICAgICAgICAgcHJ1bmVQZWVyKGlkKTtcbiAgICAgICAgICBub1BYLnNldChpZCwgdHJ1ZSk7XG4gICAgICAgIH1cbiAgICAgIH0pO1xuXG4gICAgICAvLyBkbyB3ZSBoYXZlIGVub3VnaCBwZWVycz9cbiAgICAgIGlmIChwZWVycy5zaXplIDwgRGxvKSB7XG4gICAgICAgIGNvbnN0IGJhY2tvZmYgPSB0aGlzLmdvc3NpcHN1Yi5iYWNrb2ZmLmdldCh0b3BpYyk7XG4gICAgICAgIGNvbnN0IGluZWVkID0gRCAtIHBlZXJzLnNpemU7XG4gICAgICAgIGNvbnN0IHBlZXJzU2V0ID0gZ2V0UmVsYXlQZWVycyhcbiAgICAgICAgICB0aGlzLmdvc3NpcHN1YixcbiAgICAgICAgICB0b3BpYyxcbiAgICAgICAgICBpbmVlZCxcbiAgICAgICAgICAoaWQ6IHN0cmluZykgPT4ge1xuICAgICAgICAgICAgLy8gZmlsdGVyIG91dCBtZXNoIHBlZXJzLCBkaXJlY3QgcGVlcnMsIHBlZXJzIHdlIGFyZSBiYWNraW5nIG9mZiwgcGVlcnMgd2l0aCBuZWdhdGl2ZSBzY29yZVxuICAgICAgICAgICAgcmV0dXJuIChcbiAgICAgICAgICAgICAgIXBlZXJzLmhhcyhpZCkgJiZcbiAgICAgICAgICAgICAgIXRoaXMuZ29zc2lwc3ViLmRpcmVjdC5oYXMoaWQpICYmXG4gICAgICAgICAgICAgICghYmFja29mZiB8fCAhYmFja29mZi5oYXMoaWQpKSAmJlxuICAgICAgICAgICAgICBnZXRTY29yZShpZCkgPj0gMFxuICAgICAgICAgICAgKTtcbiAgICAgICAgICB9XG4gICAgICAgICk7XG5cbiAgICAgICAgcGVlcnNTZXQuZm9yRWFjaChncmFmdFBlZXIpO1xuICAgICAgfVxuXG4gICAgICAvLyBkbyB3ZSBoYXZlIHRvIG1hbnkgcGVlcnM/XG4gICAgICBpZiAocGVlcnMuc2l6ZSA+IERoaSkge1xuICAgICAgICBsZXQgcGVlcnNBcnJheSA9IEFycmF5LmZyb20ocGVlcnMpO1xuICAgICAgICAvLyBzb3J0IGJ5IHNjb3JlXG4gICAgICAgIHBlZXJzQXJyYXkuc29ydCgoYSwgYikgPT4gZ2V0U2NvcmUoYikgLSBnZXRTY29yZShhKSk7XG4gICAgICAgIC8vIFdlIGtlZXAgdGhlIGZpcnN0IERfc2NvcmUgcGVlcnMgYnkgc2NvcmUgYW5kIHRoZSByZW1haW5pbmcgdXAgdG8gRCByYW5kb21seVxuICAgICAgICAvLyB1bmRlciB0aGUgY29uc3RyYWludCB0aGF0IHdlIGtlZXAgRF9vdXQgcGVlcnMgaW4gdGhlIG1lc2ggKGlmIHdlIGhhdmUgdGhhdCBtYW55KVxuICAgICAgICBwZWVyc0FycmF5ID0gcGVlcnNBcnJheVxuICAgICAgICAgIC5zbGljZSgwLCBEc2NvcmUpXG4gICAgICAgICAgLmNvbmNhdChzaHVmZmxlKHBlZXJzQXJyYXkuc2xpY2UoRHNjb3JlKSkpO1xuXG4gICAgICAgIC8vIGNvdW50IHRoZSBvdXRib3VuZCBwZWVycyB3ZSBhcmUga2VlcGluZ1xuICAgICAgICBsZXQgb3V0Ym91bmQgPSAwO1xuICAgICAgICBwZWVyc0FycmF5LnNsaWNlKDAsIEQpLmZvckVhY2goKHApID0+IHtcbiAgICAgICAgICBpZiAodGhpcy5nb3NzaXBzdWIub3V0Ym91bmQuZ2V0KHApKSB7XG4gICAgICAgICAgICBvdXRib3VuZCsrO1xuICAgICAgICAgIH1cbiAgICAgICAgfSk7XG5cbiAgICAgICAgLy8gaWYgaXQncyBsZXNzIHRoYW4gRF9vdXQsIGJ1YmJsZSB1cCBzb21lIG91dGJvdW5kIHBlZXJzIGZyb20gdGhlIHJhbmRvbSBzZWxlY3Rpb25cbiAgICAgICAgaWYgKG91dGJvdW5kIDwgRG91dCkge1xuICAgICAgICAgIGNvbnN0IHJvdGF0ZSA9IChpOiBudW1iZXIpOiB2b2lkID0+IHtcbiAgICAgICAgICAgIC8vIHJvdGF0ZSB0aGUgcGVlcnNBcnJheSB0byB0aGUgcmlnaHQgYW5kIHB1dCB0aGUgaXRoIHBlZXIgaW4gdGhlIGZyb250XG4gICAgICAgICAgICBjb25zdCBwID0gcGVlcnNBcnJheVtpXTtcbiAgICAgICAgICAgIGZvciAobGV0IGogPSBpOyBqID4gMDsgai0tKSB7XG4gICAgICAgICAgICAgIHBlZXJzQXJyYXlbal0gPSBwZWVyc0FycmF5W2ogLSAxXTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHBlZXJzQXJyYXlbMF0gPSBwO1xuICAgICAgICAgIH07XG5cbiAgICAgICAgICAvLyBmaXJzdCBidWJibGUgdXAgYWxsIG91dGJvdW5kIHBlZXJzIGFscmVhZHkgaW4gdGhlIHNlbGVjdGlvbiB0byB0aGUgZnJvbnRcbiAgICAgICAgICBpZiAob3V0Ym91bmQgPiAwKSB7XG4gICAgICAgICAgICBsZXQgaWhhdmUgPSBvdXRib3VuZDtcbiAgICAgICAgICAgIGZvciAobGV0IGkgPSAxOyBpIDwgRCAmJiBpaGF2ZSA+IDA7IGkrKykge1xuICAgICAgICAgICAgICBpZiAodGhpcy5nb3NzaXBzdWIub3V0Ym91bmQuZ2V0KHBlZXJzQXJyYXlbaV0pKSB7XG4gICAgICAgICAgICAgICAgcm90YXRlKGkpO1xuICAgICAgICAgICAgICAgIGloYXZlLS07XG4gICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgICB9XG5cbiAgICAgICAgICAvLyBub3cgYnViYmxlIHVwIGVub3VnaCBvdXRib3VuZCBwZWVycyBvdXRzaWRlIHRoZSBzZWxlY3Rpb24gdG8gdGhlIGZyb250XG4gICAgICAgICAgbGV0IGluZWVkID0gRCAtIG91dGJvdW5kO1xuICAgICAgICAgIGZvciAobGV0IGkgPSBEOyBpIDwgcGVlcnNBcnJheS5sZW5ndGggJiYgaW5lZWQgPiAwOyBpKyspIHtcbiAgICAgICAgICAgIGlmICh0aGlzLmdvc3NpcHN1Yi5vdXRib3VuZC5nZXQocGVlcnNBcnJheVtpXSkpIHtcbiAgICAgICAgICAgICAgcm90YXRlKGkpO1xuICAgICAgICAgICAgICBpbmVlZC0tO1xuICAgICAgICAgICAgfVxuICAgICAgICAgIH1cbiAgICAgICAgfVxuXG4gICAgICAgIC8vIHBydW5lIHRoZSBleGNlc3MgcGVlcnNcbiAgICAgICAgcGVlcnNBcnJheS5zbGljZShEKS5mb3JFYWNoKHBydW5lUGVlcik7XG4gICAgICB9XG5cbiAgICAgIC8vIGRvIHdlIGhhdmUgZW5vdWdoIG91dGJvdW5kIHBlZXJzP1xuICAgICAgaWYgKHBlZXJzLnNpemUgPj0gRGxvKSB7XG4gICAgICAgIC8vIGNvdW50IHRoZSBvdXRib3VuZCBwZWVycyB3ZSBoYXZlXG4gICAgICAgIGxldCBvdXRib3VuZCA9IDA7XG4gICAgICAgIHBlZXJzLmZvckVhY2goKHApID0+IHtcbiAgICAgICAgICBpZiAodGhpcy5nb3NzaXBzdWIub3V0Ym91bmQuZ2V0KHApKSB7XG4gICAgICAgICAgICBvdXRib3VuZCsrO1xuICAgICAgICAgIH1cbiAgICAgICAgfSk7XG5cbiAgICAgICAgLy8gaWYgaXQncyBsZXNzIHRoYW4gRF9vdXQsIHNlbGVjdCBzb21lIHBlZXJzIHdpdGggb3V0Ym91bmQgY29ubmVjdGlvbnMgYW5kIGdyYWZ0IHRoZW1cbiAgICAgICAgaWYgKG91dGJvdW5kIDwgRG91dCkge1xuICAgICAgICAgIGNvbnN0IGluZWVkID0gRG91dCAtIG91dGJvdW5kO1xuICAgICAgICAgIGNvbnN0IGJhY2tvZmYgPSB0aGlzLmdvc3NpcHN1Yi5iYWNrb2ZmLmdldCh0b3BpYyk7XG4gICAgICAgICAgZ2V0UmVsYXlQZWVycyh0aGlzLmdvc3NpcHN1YiwgdG9waWMsIGluZWVkLCAoaWQ6IHN0cmluZyk6IGJvb2xlYW4gPT4ge1xuICAgICAgICAgICAgLy8gZmlsdGVyIG91ciBjdXJyZW50IG1lc2ggcGVlcnMsIGRpcmVjdCBwZWVycywgcGVlcnMgd2UgYXJlIGJhY2tpbmcgb2ZmLCBwZWVycyB3aXRoIG5lZ2F0aXZlIHNjb3JlXG4gICAgICAgICAgICByZXR1cm4gKFxuICAgICAgICAgICAgICAhcGVlcnMuaGFzKGlkKSAmJlxuICAgICAgICAgICAgICAhdGhpcy5nb3NzaXBzdWIuZGlyZWN0LmhhcyhpZCkgJiZcbiAgICAgICAgICAgICAgKCFiYWNrb2ZmIHx8ICFiYWNrb2ZmLmhhcyhpZCkpICYmXG4gICAgICAgICAgICAgIGdldFNjb3JlKGlkKSA+PSAwXG4gICAgICAgICAgICApO1xuICAgICAgICAgIH0pLmZvckVhY2goZ3JhZnRQZWVyKTtcbiAgICAgICAgfVxuICAgICAgfVxuXG4gICAgICAvLyBzaG91bGQgd2UgdHJ5IHRvIGltcHJvdmUgdGhlIG1lc2ggd2l0aCBvcHBvcnR1bmlzdGljIGdyYWZ0aW5nP1xuICAgICAgaWYgKFxuICAgICAgICB0aGlzLmdvc3NpcHN1Yi5oZWFydGJlYXRUaWNrcyAlXG4gICAgICAgICAgY29uc3RhbnRzLlJlbGF5T3Bwb3J0dW5pc3RpY0dyYWZ0VGlja3MgPT09XG4gICAgICAgICAgMCAmJlxuICAgICAgICBwZWVycy5zaXplID4gMVxuICAgICAgKSB7XG4gICAgICAgIC8vIE9wcG9ydHVuaXN0aWMgZ3JhZnRpbmcgd29ya3MgYXMgZm9sbG93czogd2UgY2hlY2sgdGhlIG1lZGlhbiBzY29yZSBvZiBwZWVycyBpbiB0aGVcbiAgICAgICAgLy8gbWVzaDsgaWYgdGhpcyBzY29yZSBpcyBiZWxvdyB0aGUgb3Bwb3J0dW5pc3RpY0dyYWZ0VGhyZXNob2xkLCB3ZSBzZWxlY3QgYSBmZXcgcGVlcnMgYXRcbiAgICAgICAgLy8gcmFuZG9tIHdpdGggc2NvcmUgb3ZlciB0aGUgbWVkaWFuLlxuICAgICAgICAvLyBUaGUgaW50ZW50aW9uIGlzIHRvIChzbG93bHkpIGltcHJvdmUgYW4gdW5kZXIgcGVyZm9ybWluZyBtZXNoIGJ5IGludHJvZHVjaW5nIGdvb2RcbiAgICAgICAgLy8gc2NvcmluZyBwZWVycyB0aGF0IG1heSBoYXZlIGJlZW4gZ29zc2lwaW5nIGF0IHVzLiBUaGlzIGFsbG93cyB1cyB0byBnZXQgb3V0IG9mIHN0aWNreVxuICAgICAgICAvLyBzaXR1YXRpb25zIHdoZXJlIHdlIGFyZSBzdHVjayB3aXRoIHBvb3IgcGVlcnMgYW5kIGFsc28gcmVjb3ZlciBmcm9tIGNodXJuIG9mIGdvb2QgcGVlcnMuXG5cbiAgICAgICAgLy8gbm93IGNvbXB1dGUgdGhlIG1lZGlhbiBwZWVyIHNjb3JlIGluIHRoZSBtZXNoXG4gICAgICAgIGNvbnN0IHBlZXJzTGlzdCA9IEFycmF5LmZyb20ocGVlcnMpLnNvcnQoXG4gICAgICAgICAgKGEsIGIpID0+IGdldFNjb3JlKGEpIC0gZ2V0U2NvcmUoYilcbiAgICAgICAgKTtcbiAgICAgICAgY29uc3QgbWVkaWFuSW5kZXggPSBNYXRoLmZsb29yKHBlZXJzLnNpemUgLyAyKTtcbiAgICAgICAgY29uc3QgbWVkaWFuU2NvcmUgPSBnZXRTY29yZShwZWVyc0xpc3RbbWVkaWFuSW5kZXhdKTtcblxuICAgICAgICAvLyBpZiB0aGUgbWVkaWFuIHNjb3JlIGlzIGJlbG93IHRoZSB0aHJlc2hvbGQsIHNlbGVjdCBhIGJldHRlciBwZWVyIChpZiBhbnkpIGFuZCBHUkFGVFxuICAgICAgICBpZiAoXG4gICAgICAgICAgbWVkaWFuU2NvcmUgPFxuICAgICAgICAgIHRoaXMuZ29zc2lwc3ViLl9vcHRpb25zLnNjb3JlVGhyZXNob2xkcy5vcHBvcnR1bmlzdGljR3JhZnRUaHJlc2hvbGRcbiAgICAgICAgKSB7XG4gICAgICAgICAgY29uc3QgYmFja29mZiA9IHRoaXMuZ29zc2lwc3ViLmJhY2tvZmYuZ2V0KHRvcGljKTtcbiAgICAgICAgICBjb25zdCBwZWVyc1RvR3JhZnQgPSBnZXRSZWxheVBlZXJzKFxuICAgICAgICAgICAgdGhpcy5nb3NzaXBzdWIsXG4gICAgICAgICAgICB0b3BpYyxcbiAgICAgICAgICAgIGNvbnN0YW50cy5SZWxheU9wcG9ydHVuaXN0aWNHcmFmdFBlZXJzLFxuICAgICAgICAgICAgKGlkOiBzdHJpbmcpOiBib29sZWFuID0+IHtcbiAgICAgICAgICAgICAgLy8gZmlsdGVyIG91dCBjdXJyZW50IG1lc2ggcGVlcnMsIGRpcmVjdCBwZWVycywgcGVlcnMgd2UgYXJlIGJhY2tpbmcgb2ZmLCBwZWVycyBiZWxvdyBvciBhdCB0aHJlc2hvbGRcbiAgICAgICAgICAgICAgcmV0dXJuIChcbiAgICAgICAgICAgICAgICBwZWVycy5oYXMoaWQpICYmXG4gICAgICAgICAgICAgICAgIXRoaXMuZ29zc2lwc3ViLmRpcmVjdC5oYXMoaWQpICYmXG4gICAgICAgICAgICAgICAgKCFiYWNrb2ZmIHx8ICFiYWNrb2ZmLmhhcyhpZCkpICYmXG4gICAgICAgICAgICAgICAgZ2V0U2NvcmUoaWQpID4gbWVkaWFuU2NvcmVcbiAgICAgICAgICAgICAgKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICApO1xuICAgICAgICAgIHBlZXJzVG9HcmFmdC5mb3JFYWNoKChpZDogc3RyaW5nKSA9PiB7XG4gICAgICAgICAgICB0aGlzLmdvc3NpcHN1Yi5sb2coXG4gICAgICAgICAgICAgICdIRUFSVEJFQVQ6IE9wcG9ydHVuaXN0aWNhbGx5IGdyYWZ0IHBlZXIgJXMgb24gdG9waWMgJXMnLFxuICAgICAgICAgICAgICBpZCxcbiAgICAgICAgICAgICAgdG9waWNcbiAgICAgICAgICAgICk7XG4gICAgICAgICAgICBncmFmdFBlZXIoaWQpO1xuICAgICAgICAgIH0pO1xuICAgICAgICB9XG4gICAgICB9XG5cbiAgICAgIC8vIDJuZCBhcmcgYXJlIG1lc2ggcGVlcnMgZXhjbHVkZWQgZnJvbSBnb3NzaXAuIFdlIGhhdmUgYWxyZWFkeSBwdXNoZWRcbiAgICAgIC8vIG1lc3NhZ2VzIHRvIHRoZW0sIHNvIGl0cyByZWR1bmRhbnQgdG8gZ29zc2lwIElIQVZFcy5cbiAgICAgIHRoaXMuZ29zc2lwc3ViLl9lbWl0R29zc2lwKHRvcGljLCBwZWVycyk7XG4gICAgfSk7XG5cbiAgICAvLyBleHBpcmUgZmFub3V0IGZvciB0b3BpY3Mgd2UgaGF2ZW4ndCBwdWJsaXNoZWQgdG8gaW4gYSB3aGlsZVxuICAgIGNvbnN0IG5vdyA9IHRoaXMuZ29zc2lwc3ViLl9ub3coKTtcbiAgICB0aGlzLmdvc3NpcHN1Yi5sYXN0cHViLmZvckVhY2goKGxhc3RwdWIsIHRvcGljKSA9PiB7XG4gICAgICBpZiAobGFzdHB1YiArIGNvbnN0YW50cy5SZWxheUZhbm91dFRUTCA8IG5vdykge1xuICAgICAgICB0aGlzLmdvc3NpcHN1Yi5mYW5vdXQuZGVsZXRlKHRvcGljKTtcbiAgICAgICAgdGhpcy5nb3NzaXBzdWIubGFzdHB1Yi5kZWxldGUodG9waWMpO1xuICAgICAgfVxuICAgIH0pO1xuXG4gICAgLy8gbWFpbnRhaW4gb3VyIGZhbm91dCBmb3IgdG9waWNzIHdlIGFyZSBwdWJsaXNoaW5nIGJ1dCB3ZSBoYXZlIG5vdCBqb2luZWRcbiAgICB0aGlzLmdvc3NpcHN1Yi5mYW5vdXQuZm9yRWFjaCgoZmFub3V0UGVlcnMsIHRvcGljKSA9PiB7XG4gICAgICAvLyBjaGVja3Mgd2hldGhlciBvdXIgcGVlcnMgYXJlIHN0aWxsIGluIHRoZSB0b3BpYyBhbmQgaGF2ZSBhIHNjb3JlIGFib3ZlIHRoZSBwdWJsaXNoIHRocmVzaG9sZFxuICAgICAgY29uc3QgdG9waWNQZWVycyA9IHRoaXMuZ29zc2lwc3ViLnRvcGljcy5nZXQodG9waWMpO1xuICAgICAgZmFub3V0UGVlcnMuZm9yRWFjaCgoaWQpID0+IHtcbiAgICAgICAgaWYgKFxuICAgICAgICAgICF0b3BpY1BlZXJzPy5oYXMoaWQpIHx8XG4gICAgICAgICAgZ2V0U2NvcmUoaWQpIDxcbiAgICAgICAgICAgIHRoaXMuZ29zc2lwc3ViLl9vcHRpb25zLnNjb3JlVGhyZXNob2xkcy5wdWJsaXNoVGhyZXNob2xkXG4gICAgICAgICkge1xuICAgICAgICAgIGZhbm91dFBlZXJzLmRlbGV0ZShpZCk7XG4gICAgICAgIH1cbiAgICAgIH0pO1xuXG4gICAgICAvLyBkbyB3ZSBuZWVkIG1vcmUgcGVlcnM/XG4gICAgICBpZiAoZmFub3V0UGVlcnMuc2l6ZSA8IEQpIHtcbiAgICAgICAgY29uc3QgaW5lZWQgPSBEIC0gZmFub3V0UGVlcnMuc2l6ZTtcbiAgICAgICAgY29uc3QgcGVlcnNTZXQgPSBnZXRSZWxheVBlZXJzKFxuICAgICAgICAgIHRoaXMuZ29zc2lwc3ViLFxuICAgICAgICAgIHRvcGljLFxuICAgICAgICAgIGluZWVkLFxuICAgICAgICAgIChpZDogc3RyaW5nKTogYm9vbGVhbiA9PiB7XG4gICAgICAgICAgICAvLyBmaWx0ZXIgb3V0IGV4aXN0aW5nIGZhbm91dCBwZWVycywgZGlyZWN0IHBlZXJzLCBhbmQgcGVlcnMgd2l0aCBzY29yZSBhYm92ZSB0aGUgcHVibGlzaCB0aHJlc2hvbGRcbiAgICAgICAgICAgIHJldHVybiAoXG4gICAgICAgICAgICAgICFmYW5vdXRQZWVycy5oYXMoaWQpICYmXG4gICAgICAgICAgICAgICF0aGlzLmdvc3NpcHN1Yi5kaXJlY3QuaGFzKGlkKSAmJlxuICAgICAgICAgICAgICBnZXRTY29yZShpZCkgPj1cbiAgICAgICAgICAgICAgICB0aGlzLmdvc3NpcHN1Yi5fb3B0aW9ucy5zY29yZVRocmVzaG9sZHMucHVibGlzaFRocmVzaG9sZFxuICAgICAgICAgICAgKTtcbiAgICAgICAgICB9XG4gICAgICAgICk7XG4gICAgICAgIHBlZXJzU2V0LmZvckVhY2goKGlkOiBzdHJpbmcpID0+IHtcbiAgICAgICAgICBmYW5vdXRQZWVycy5hZGQoaWQpO1xuICAgICAgICB9KTtcbiAgICAgIH1cblxuICAgICAgLy8gMm5kIGFyZyBhcmUgZmFub3V0IHBlZXJzIGV4Y2x1ZGVkIGZyb20gZ29zc2lwLlxuICAgICAgLy8gV2UgaGF2ZSBhbHJlYWR5IHB1c2hlZCBtZXNzYWdlcyB0byB0aGVtLCBzbyBpdHMgcmVkdW5kYW50IHRvIGdvc3NpcCBJSEFWRXNcbiAgICAgIHRoaXMuZ29zc2lwc3ViLl9lbWl0R29zc2lwKHRvcGljLCBmYW5vdXRQZWVycyk7XG4gICAgfSk7XG5cbiAgICAvLyBzZW5kIGNvYWxlc2NlZCBHUkFGVC9QUlVORSBtZXNzYWdlcyAod2lsbCBwaWdneWJhY2sgZ29zc2lwKVxuICAgIHRoaXMuZ29zc2lwc3ViLl9zZW5kR3JhZnRQcnVuZSh0b0dyYWZ0LCB0b1BydW5lLCBub1BYKTtcblxuICAgIC8vIGZsdXNoIHBlbmRpbmcgZ29zc2lwIHRoYXQgd2Fzbid0IHBpZ2d5YmFja2VkIGFib3ZlXG4gICAgdGhpcy5nb3NzaXBzdWIuX2ZsdXNoKCk7XG5cbiAgICAvLyBhZHZhbmNlIHRoZSBtZXNzYWdlIGhpc3Rvcnkgd2luZG93XG4gICAgdGhpcy5nb3NzaXBzdWIubWVzc2FnZUNhY2hlLnNoaWZ0KCk7XG5cbiAgICB0aGlzLmdvc3NpcHN1Yi5lbWl0KCdnb3NzaXBzdWI6aGVhcnRiZWF0Jyk7XG4gIH1cbn1cbiIsImltcG9ydCB7IFJlYWRlciB9IGZyb20gJ3Byb3RvYnVmanMvbWluaW1hbCc7XG5pbXBvcnQgeyB2NCBhcyB1dWlkIH0gZnJvbSAndXVpZCc7XG5cbmltcG9ydCAqIGFzIHByb3RvIGZyb20gJy4uLy4uL3Byb3RvL3dha3UvdjIvc3RvcmUnO1xuXG5leHBvcnQgZW51bSBQYWdlRGlyZWN0aW9uIHtcbiAgQkFDS1dBUkQgPSAnYmFja3dhcmQnLFxuICBGT1JXQVJEID0gJ2ZvcndhcmQnLFxufVxuXG5leHBvcnQgaW50ZXJmYWNlIFBhcmFtcyB7XG4gIGNvbnRlbnRUb3BpY3M6IHN0cmluZ1tdO1xuICBwdWJTdWJUb3BpYzogc3RyaW5nO1xuICBwYWdlRGlyZWN0aW9uOiBQYWdlRGlyZWN0aW9uO1xuICBwYWdlU2l6ZTogbnVtYmVyO1xuICBzdGFydFRpbWU/OiBudW1iZXI7XG4gIGVuZFRpbWU/OiBudW1iZXI7XG4gIGN1cnNvcj86IHByb3RvLkluZGV4O1xufVxuXG5leHBvcnQgY2xhc3MgSGlzdG9yeVJQQyB7XG4gIHB1YmxpYyBjb25zdHJ1Y3RvcihwdWJsaWMgcHJvdG86IHByb3RvLkhpc3RvcnlSUEMpIHt9XG5cbiAgLyoqXG4gICAqIENyZWF0ZSBIaXN0b3J5IFF1ZXJ5LlxuICAgKi9cbiAgc3RhdGljIGNyZWF0ZVF1ZXJ5KHBhcmFtczogUGFyYW1zKTogSGlzdG9yeVJQQyB7XG4gICAgY29uc3QgZGlyZWN0aW9uID0gZGlyZWN0aW9uVG9Qcm90byhwYXJhbXMucGFnZURpcmVjdGlvbik7XG4gICAgY29uc3QgcGFnaW5nSW5mbyA9IHtcbiAgICAgIHBhZ2VTaXplOiBwYXJhbXMucGFnZVNpemUsXG4gICAgICBjdXJzb3I6IHBhcmFtcy5jdXJzb3IsXG4gICAgICBkaXJlY3Rpb24sXG4gICAgfTtcblxuICAgIGNvbnN0IGNvbnRlbnRGaWx0ZXJzID0gcGFyYW1zLmNvbnRlbnRUb3BpY3MubWFwKChjb250ZW50VG9waWMpID0+IHtcbiAgICAgIHJldHVybiB7IGNvbnRlbnRUb3BpYyB9O1xuICAgIH0pO1xuXG4gICAgcmV0dXJuIG5ldyBIaXN0b3J5UlBDKHtcbiAgICAgIHJlcXVlc3RJZDogdXVpZCgpLFxuICAgICAgcXVlcnk6IHtcbiAgICAgICAgcHViU3ViVG9waWM6IHBhcmFtcy5wdWJTdWJUb3BpYyxcbiAgICAgICAgY29udGVudEZpbHRlcnMsXG4gICAgICAgIHBhZ2luZ0luZm8sXG4gICAgICAgIHN0YXJ0VGltZTogcGFyYW1zLnN0YXJ0VGltZSxcbiAgICAgICAgZW5kVGltZTogcGFyYW1zLmVuZFRpbWUsXG4gICAgICB9LFxuICAgICAgcmVzcG9uc2U6IHVuZGVmaW5lZCxcbiAgICB9KTtcbiAgfVxuXG4gIHN0YXRpYyBkZWNvZGUoYnl0ZXM6IFVpbnQ4QXJyYXkpOiBIaXN0b3J5UlBDIHtcbiAgICBjb25zdCByZXMgPSBwcm90by5IaXN0b3J5UlBDLmRlY29kZShSZWFkZXIuY3JlYXRlKGJ5dGVzKSk7XG4gICAgcmV0dXJuIG5ldyBIaXN0b3J5UlBDKHJlcyk7XG4gIH1cblxuICBlbmNvZGUoKTogVWludDhBcnJheSB7XG4gICAgcmV0dXJuIHByb3RvLkhpc3RvcnlSUEMuZW5jb2RlKHRoaXMucHJvdG8pLmZpbmlzaCgpO1xuICB9XG5cbiAgZ2V0IHF1ZXJ5KCk6IHByb3RvLkhpc3RvcnlRdWVyeSB8IHVuZGVmaW5lZCB7XG4gICAgcmV0dXJuIHRoaXMucHJvdG8ucXVlcnk7XG4gIH1cblxuICBnZXQgcmVzcG9uc2UoKTogcHJvdG8uSGlzdG9yeVJlc3BvbnNlIHwgdW5kZWZpbmVkIHtcbiAgICByZXR1cm4gdGhpcy5wcm90by5yZXNwb25zZTtcbiAgfVxufVxuXG5mdW5jdGlvbiBkaXJlY3Rpb25Ub1Byb3RvKFxuICBwYWdlRGlyZWN0aW9uOiBQYWdlRGlyZWN0aW9uXG4pOiBwcm90by5QYWdpbmdJbmZvX0RpcmVjdGlvbiB7XG4gIHN3aXRjaCAocGFnZURpcmVjdGlvbikge1xuICAgIGNhc2UgUGFnZURpcmVjdGlvbi5CQUNLV0FSRDpcbiAgICAgIHJldHVybiBwcm90by5QYWdpbmdJbmZvX0RpcmVjdGlvbi5ESVJFQ1RJT05fQkFDS1dBUkRfVU5TUEVDSUZJRUQ7XG4gICAgY2FzZSBQYWdlRGlyZWN0aW9uLkZPUldBUkQ6XG4gICAgICByZXR1cm4gcHJvdG8uUGFnaW5nSW5mb19EaXJlY3Rpb24uRElSRUNUSU9OX0ZPUldBUkQ7XG4gICAgZGVmYXVsdDpcbiAgICAgIHJldHVybiBwcm90by5QYWdpbmdJbmZvX0RpcmVjdGlvbi5ESVJFQ1RJT05fQkFDS1dBUkRfVU5TUEVDSUZJRUQ7XG4gIH1cbn1cbiIsImltcG9ydCBkZWJ1ZyBmcm9tICdkZWJ1Zyc7XG5pbXBvcnQgY29uY2F0IGZyb20gJ2l0LWNvbmNhdCc7XG5pbXBvcnQgbHAgZnJvbSAnaXQtbGVuZ3RoLXByZWZpeGVkJztcbmltcG9ydCBwaXBlIGZyb20gJ2l0LXBpcGUnO1xuaW1wb3J0IExpYnAycCBmcm9tICdsaWJwMnAnO1xuaW1wb3J0IHsgUGVlciB9IGZyb20gJ2xpYnAycC9zcmMvcGVlci1zdG9yZSc7XG5pbXBvcnQgUGVlcklkIGZyb20gJ3BlZXItaWQnO1xuXG5pbXBvcnQgeyBIaXN0b3J5UmVzcG9uc2VfRXJyb3IgfSBmcm9tICcuLi8uLi9wcm90by93YWt1L3YyL3N0b3JlJztcbmltcG9ydCB7IGdldFBlZXJzRm9yUHJvdG9jb2wsIHNlbGVjdFJhbmRvbVBlZXIgfSBmcm9tICcuLi9zZWxlY3RfcGVlcic7XG5pbXBvcnQgeyBoZXhUb0J1ZiB9IGZyb20gJy4uL3V0aWxzJztcbmltcG9ydCB7IERlZmF1bHRQdWJTdWJUb3BpYyB9IGZyb20gJy4uL3dha3UnO1xuaW1wb3J0IHsgV2FrdU1lc3NhZ2UgfSBmcm9tICcuLi93YWt1X21lc3NhZ2UnO1xuXG5pbXBvcnQgeyBIaXN0b3J5UlBDLCBQYWdlRGlyZWN0aW9uIH0gZnJvbSAnLi9oaXN0b3J5X3JwYyc7XG5cbmNvbnN0IGRiZyA9IGRlYnVnKCd3YWt1OnN0b3JlJyk7XG5cbmV4cG9ydCBjb25zdCBTdG9yZUNvZGVjID0gJy92YWMvd2FrdS9zdG9yZS8yLjAuMC1iZXRhMyc7XG5cbmV4cG9ydCBjb25zdCBEZWZhdWx0UGFnZVNpemUgPSAxMDtcblxuZXhwb3J0IHsgUGFnZURpcmVjdGlvbiB9O1xuXG5leHBvcnQgaW50ZXJmYWNlIENyZWF0ZU9wdGlvbnMge1xuICAvKipcbiAgICogVGhlIFB1YlN1YiBUb3BpYyB0byB1c2UuIERlZmF1bHRzIHRvIHtAbGluayBEZWZhdWx0UHViU3ViVG9waWN9LlxuICAgKlxuICAgKiBUaGUgdXNhZ2Ugb2YgdGhlIGRlZmF1bHQgcHVic3ViIHRvcGljIGlzIHJlY29tbWVuZGVkLlxuICAgKiBTZWUgW1dha3UgdjIgVG9waWMgVXNhZ2UgUmVjb21tZW5kYXRpb25zXShodHRwczovL3JmYy52YWMuZGV2L3NwZWMvMjMvKSBmb3IgZGV0YWlscy5cbiAgICpcbiAgICogQGRlZmF1bHQge0BsaW5rIERlZmF1bHRQdWJTdWJUb3BpY31cbiAgICovXG4gIHB1YlN1YlRvcGljPzogc3RyaW5nO1xufVxuXG5leHBvcnQgaW50ZXJmYWNlIFRpbWVGaWx0ZXIge1xuICBzdGFydFRpbWU6IERhdGU7XG4gIGVuZFRpbWU6IERhdGU7XG59XG5cbmV4cG9ydCBpbnRlcmZhY2UgUXVlcnlPcHRpb25zIHtcbiAgLyoqXG4gICAqIFRoZSBwZWVyIHRvIHF1ZXJ5LiBJZiB1bmRlZmluZWQsIGEgcHNldWRvLXJhbmRvbSBwZWVyIGlzIHNlbGVjdGVkIGZyb20gdGhlIGNvbm5lY3RlZCBXYWt1IFN0b3JlIHBlZXJzLlxuICAgKi9cbiAgcGVlcklkPzogUGVlcklkO1xuICAvKipcbiAgICogVGhlIHB1YnN1YiB0b3BpYyB0byBwYXNzIHRvIHRoZSBxdWVyeS5cbiAgICogU2VlIFtXYWt1IHYyIFRvcGljIFVzYWdlIFJlY29tbWVuZGF0aW9uc10oaHR0cHM6Ly9yZmMudmFjLmRldi9zcGVjLzIzLykuXG4gICAqL1xuICBwdWJTdWJUb3BpYz86IHN0cmluZztcbiAgLyoqXG4gICAqIFRoZSBkaXJlY3Rpb24gaW4gd2hpY2ggcGFnZXMgYXJlIHJldHJpZXZlZDpcbiAgICogLSBbW0RpcmVjdGlvbi5CQUNLV0FSRF1dOiBNb3N0IHJlY2VudCBwYWdlIGZpcnN0LlxuICAgKiAtIFtbRGlyZWN0aW9uLkZPUldBUkRdXTogT2xkZXN0IHBhZ2UgZmlyc3QuXG4gICAqXG4gICAqIE5vdGU6IFRoaXMgZG9lcyBub3QgYWZmZWN0IHRoZSBvcmRlcmluZyBvZiBtZXNzYWdlcyB3aXRoIHRoZSBwYWdlXG4gICAqIChvbGRlc3QgbWVzc2FnZSBpcyBhbHdheXMgZmlyc3QpLlxuICAgKlxuICAgKiBAZGVmYXVsdCBbW0RpcmVjdGlvbi5CQUNLV0FSRF1dXG4gICAqL1xuICBwYWdlRGlyZWN0aW9uPzogUGFnZURpcmVjdGlvbjtcbiAgLyoqXG4gICAqIFRoZSBudW1iZXIgb2YgbWVzc2FnZSBwZXIgcGFnZS5cbiAgICpcbiAgICogQGRlZmF1bHQgW1tEZWZhdWx0UGFnZVNpemVdXVxuICAgKi9cbiAgcGFnZVNpemU/OiBudW1iZXI7XG4gIC8qKlxuICAgKiBSZXRyaWV2ZSBtZXNzYWdlcyB3aXRoIGEgdGltZXN0YW1wIHdpdGhpbiB0aGUgcHJvdmlkZWQgdmFsdWVzLlxuICAgKi9cbiAgdGltZUZpbHRlcj86IFRpbWVGaWx0ZXI7XG4gIC8qKlxuICAgKiBDYWxsYmFjayBjYWxsZWQgb24gcGFnZXMgb2Ygc3RvcmVkIG1lc3NhZ2VzIGFzIHRoZXkgYXJlIHJldHJpZXZlZC5cbiAgICpcbiAgICogQWxsb3dzIGZvciBhIGZhc3RlciBhY2Nlc3MgdG8gdGhlIHJlc3VsdHMgYXMgaXQgaXMgY2FsbGVkIGFzIHNvb24gYXMgYSBwYWdlXG4gICAqIGlzIHJlY2VpdmVkLiBUcmF2ZXJzYWwgb2YgdGhlIHBhZ2VzIGlzIGRvbmUgYXV0b21hdGljYWxseSBzbyB0aGlzIGZ1bmN0aW9uXG4gICAqIHdpbGwgaW52b2tlZCBmb3IgZWFjaCByZXRyaWV2ZWQgcGFnZS5cbiAgICpcbiAgICogSWYgdGhlIGNhbGwgb24gYSBwYWdlIHJldHVybnMgYHRydWVgLCB0aGVuIHRyYXZlcnNhbCBvZiB0aGUgcGFnZXMgaXMgYWJvcnRlZC5cbiAgICogRm9yIGV4YW1wbGUsIHRoaXMgY2FuIGJlIHVzZWQgZm9yIHRoZSBjYWxsZXIgdG8gc3RvcCB0aGUgcXVlcnkgYWZ0ZXIgYVxuICAgKiBzcGVjaWZpYyBtZXNzYWdlIGlzIGZvdW5kLlxuICAgKi9cbiAgY2FsbGJhY2s/OiAobWVzc2FnZXM6IFdha3VNZXNzYWdlW10pID0+IHZvaWQgfCBib29sZWFuO1xuICAvKipcbiAgICogS2V5cyB0aGF0IHdpbGwgYmUgdXNlZCB0byBkZWNyeXB0IG1lc3NhZ2VzLlxuICAgKlxuICAgKiBJdCBjYW4gYmUgQXN5bW1ldHJpYyBQcml2YXRlIEtleXMgYW5kIFN5bW1ldHJpYyBLZXlzIGluIHRoZSBzYW1lIGFycmF5LFxuICAgKiBhbGwga2V5cyB3aWxsIGJlIHRyaWVkIHdpdGggYm90aCBtZXRob2RzLlxuICAgKi9cbiAgZGVjcnlwdGlvbktleXM/OiBBcnJheTxVaW50OEFycmF5IHwgc3RyaW5nPjtcbn1cblxuLyoqXG4gKiBJbXBsZW1lbnRzIHRoZSBbV2FrdSB2MiBTdG9yZSBwcm90b2NvbF0oaHR0cHM6Ly9yZmMudmFjLmRldi9zcGVjLzEzLykuXG4gKi9cbmV4cG9ydCBjbGFzcyBXYWt1U3RvcmUge1xuICBwdWJTdWJUb3BpYzogc3RyaW5nO1xuICBwdWJsaWMgZGVjcnlwdGlvbktleXM6IFNldDxVaW50OEFycmF5PjtcblxuICBjb25zdHJ1Y3RvcihwdWJsaWMgbGlicDJwOiBMaWJwMnAsIG9wdGlvbnM/OiBDcmVhdGVPcHRpb25zKSB7XG4gICAgaWYgKG9wdGlvbnM/LnB1YlN1YlRvcGljKSB7XG4gICAgICB0aGlzLnB1YlN1YlRvcGljID0gb3B0aW9ucy5wdWJTdWJUb3BpYztcbiAgICB9IGVsc2Uge1xuICAgICAgdGhpcy5wdWJTdWJUb3BpYyA9IERlZmF1bHRQdWJTdWJUb3BpYztcbiAgICB9XG5cbiAgICB0aGlzLmRlY3J5cHRpb25LZXlzID0gbmV3IFNldCgpO1xuICB9XG5cbiAgLyoqXG4gICAqIERvIGEgSGlzdG9yeSBRdWVyeSB0byBhIFdha3UgU3RvcmUuXG4gICAqXG4gICAqIEBwYXJhbSBjb250ZW50VG9waWNzIFRoZSBjb250ZW50IHRvcGljcyB0byBwYXNzIHRvIHRoZSBxdWVyeSwgbGVhdmUgZW1wdHkgdG9cbiAgICogcmV0cmlldmUgYWxsIG1lc3NhZ2VzLlxuICAgKlxuICAgKiBAdGhyb3dzIElmIG5vdCBhYmxlIHRvIHJlYWNoIGEgV2FrdSBTdG9yZSBwZWVyIHRvIHF1ZXJ5XG4gICAqIG9yIGlmIGFuIGVycm9yIGlzIGVuY291bnRlcmVkIHdoZW4gcHJvY2Vzc2luZyB0aGUgcmVwbHkuXG4gICAqL1xuICBhc3luYyBxdWVyeUhpc3RvcnkoXG4gICAgY29udGVudFRvcGljczogc3RyaW5nW10sXG4gICAgb3B0aW9ucz86IFF1ZXJ5T3B0aW9uc1xuICApOiBQcm9taXNlPFdha3VNZXNzYWdlW10+IHtcbiAgICBsZXQgc3RhcnRUaW1lLCBlbmRUaW1lO1xuICAgIGlmIChvcHRpb25zPy50aW1lRmlsdGVyKSB7XG4gICAgICBzdGFydFRpbWUgPSBvcHRpb25zLnRpbWVGaWx0ZXIuc3RhcnRUaW1lLmdldFRpbWUoKSAvIDEwMDA7XG4gICAgICBlbmRUaW1lID0gb3B0aW9ucy50aW1lRmlsdGVyLmVuZFRpbWUuZ2V0VGltZSgpIC8gMTAwMDtcbiAgICB9XG5cbiAgICBjb25zdCBvcHRzID0gT2JqZWN0LmFzc2lnbihcbiAgICAgIHtcbiAgICAgICAgcHViU3ViVG9waWM6IHRoaXMucHViU3ViVG9waWMsXG4gICAgICAgIHBhZ2VEaXJlY3Rpb246IFBhZ2VEaXJlY3Rpb24uQkFDS1dBUkQsXG4gICAgICAgIHBhZ2VTaXplOiBEZWZhdWx0UGFnZVNpemUsXG4gICAgICB9LFxuICAgICAgb3B0aW9ucyxcbiAgICAgIHtcbiAgICAgICAgc3RhcnRUaW1lLFxuICAgICAgICBlbmRUaW1lLFxuICAgICAgfSxcbiAgICAgIHsgY29udGVudFRvcGljcyB9XG4gICAgKTtcbiAgICBkYmcoJ1F1ZXJ5aW5nIGhpc3Rvcnkgd2l0aCB0aGUgZm9sbG93aW5nIG9wdGlvbnMnLCBvcHRpb25zKTtcblxuICAgIGxldCBwZWVyO1xuICAgIGlmIChvcHRzLnBlZXJJZCkge1xuICAgICAgcGVlciA9IHRoaXMubGlicDJwLnBlZXJTdG9yZS5nZXQob3B0cy5wZWVySWQpO1xuICAgICAgaWYgKCFwZWVyKVxuICAgICAgICB0aHJvdyBgRmFpbGVkIHRvIHJldHJpZXZlIGNvbm5lY3Rpb24gZGV0YWlscyBmb3IgcHJvdmlkZWQgcGVlciBpbiBwZWVyIHN0b3JlOiAke29wdHMucGVlcklkLnRvQjU4U3RyaW5nKCl9YDtcbiAgICB9IGVsc2Uge1xuICAgICAgcGVlciA9IHRoaXMucmFuZG9tUGVlcjtcbiAgICAgIGlmICghcGVlcilcbiAgICAgICAgdGhyb3cgJ0ZhaWxlZCB0byBmaW5kIGtub3duIHBlZXIgdGhhdCByZWdpc3RlcnMgd2FrdSBzdG9yZSBwcm90b2NvbCc7XG4gICAgfVxuICAgIGlmICghcGVlci5wcm90b2NvbHMuaW5jbHVkZXMoU3RvcmVDb2RlYykpXG4gICAgICB0aHJvdyBgUGVlciBkb2VzIG5vdCByZWdpc3RlciB3YWt1IHN0b3JlIHByb3RvY29sOiAke3BlZXIuaWQudG9CNThTdHJpbmcoKX1gO1xuICAgIGNvbnN0IGNvbm5lY3Rpb24gPSB0aGlzLmxpYnAycC5jb25uZWN0aW9uTWFuYWdlci5nZXQocGVlci5pZCk7XG4gICAgaWYgKCFjb25uZWN0aW9uKSB0aHJvdyAnRmFpbGVkIHRvIGdldCBhIGNvbm5lY3Rpb24gdG8gdGhlIHBlZXInO1xuXG4gICAgY29uc3QgZGVjcnlwdGlvbktleXMgPSBBcnJheS5mcm9tKHRoaXMuZGVjcnlwdGlvbktleXMudmFsdWVzKCkpO1xuICAgIGlmIChvcHRzLmRlY3J5cHRpb25LZXlzKSB7XG4gICAgICBvcHRzLmRlY3J5cHRpb25LZXlzLmZvckVhY2goKGtleSkgPT4ge1xuICAgICAgICBkZWNyeXB0aW9uS2V5cy5wdXNoKGhleFRvQnVmKGtleSkpO1xuICAgICAgfSk7XG4gICAgfVxuXG4gICAgY29uc3QgbWVzc2FnZXM6IFdha3VNZXNzYWdlW10gPSBbXTtcbiAgICBsZXQgY3Vyc29yID0gdW5kZWZpbmVkO1xuICAgIHdoaWxlICh0cnVlKSB7XG4gICAgICBjb25zdCB7IHN0cmVhbSB9ID0gYXdhaXQgY29ubmVjdGlvbi5uZXdTdHJlYW0oU3RvcmVDb2RlYyk7XG4gICAgICBjb25zdCBxdWVyeU9wdHMgPSBPYmplY3QuYXNzaWduKG9wdHMsIHsgY3Vyc29yIH0pO1xuICAgICAgY29uc3QgaGlzdG9yeVJwY1F1ZXJ5ID0gSGlzdG9yeVJQQy5jcmVhdGVRdWVyeShxdWVyeU9wdHMpO1xuICAgICAgZGJnKCdRdWVyeWluZyBzdG9yZSBwZWVyJywgY29ubmVjdGlvbi5yZW1vdGVBZGRyLnRvU3RyaW5nKCkpO1xuXG4gICAgICBjb25zdCByZXMgPSBhd2FpdCBwaXBlKFxuICAgICAgICBbaGlzdG9yeVJwY1F1ZXJ5LmVuY29kZSgpXSxcbiAgICAgICAgbHAuZW5jb2RlKCksXG4gICAgICAgIHN0cmVhbSxcbiAgICAgICAgbHAuZGVjb2RlKCksXG4gICAgICAgIGNvbmNhdFxuICAgICAgKTtcbiAgICAgIGNvbnN0IHJlcGx5ID0gSGlzdG9yeVJQQy5kZWNvZGUocmVzLnNsaWNlKCkpO1xuXG4gICAgICBjb25zdCByZXNwb25zZSA9IHJlcGx5LnJlc3BvbnNlO1xuICAgICAgaWYgKCFyZXNwb25zZSkge1xuICAgICAgICB0aHJvdyAnSGlzdG9yeSByZXNwb25zZSBtaXNzZXMgcmVzcG9uc2UgZmllbGQnO1xuICAgICAgfVxuXG4gICAgICBpZiAoXG4gICAgICAgIHJlc3BvbnNlLmVycm9yICYmXG4gICAgICAgIHJlc3BvbnNlLmVycm9yID09PSBIaXN0b3J5UmVzcG9uc2VfRXJyb3IuRVJST1JfSU5WQUxJRF9DVVJTT1JcbiAgICAgICkge1xuICAgICAgICB0aHJvdyAnSGlzdG9yeSByZXNwb25zZSBjb250YWlucyBhbiBFcnJvcjogSU5WQUxJRCBDVVJTT1InO1xuICAgICAgfVxuXG4gICAgICBpZiAoIXJlc3BvbnNlLm1lc3NhZ2VzIHx8ICFyZXNwb25zZS5tZXNzYWdlcy5sZW5ndGgpIHtcbiAgICAgICAgLy8gTm8gbWVzc2FnZXMgbGVmdCAob3Igc3RvcmVkKVxuICAgICAgICBjb25zb2xlLmxvZygnTm8gbWVzc2FnZXMgcHJlc2VudCBpbiBIaXN0b3J5UlBDIHJlc3BvbnNlJyk7XG4gICAgICAgIHJldHVybiBtZXNzYWdlcztcbiAgICAgIH1cblxuICAgICAgZGJnKFxuICAgICAgICBgJHtyZXNwb25zZS5tZXNzYWdlcy5sZW5ndGh9IG1lc3NhZ2VzIHJldHJpZXZlZCBmb3IgcHVic3ViIHRvcGljICR7b3B0cy5wdWJTdWJUb3BpY31gXG4gICAgICApO1xuXG4gICAgICBjb25zdCBwYWdlTWVzc2FnZXM6IFdha3VNZXNzYWdlW10gPSBbXTtcbiAgICAgIGF3YWl0IFByb21pc2UuYWxsKFxuICAgICAgICByZXNwb25zZS5tZXNzYWdlcy5tYXAoYXN5bmMgKHByb3RvTXNnKSA9PiB7XG4gICAgICAgICAgY29uc3QgbXNnID0gYXdhaXQgV2FrdU1lc3NhZ2UuZGVjb2RlUHJvdG8ocHJvdG9Nc2csIGRlY3J5cHRpb25LZXlzKTtcblxuICAgICAgICAgIGlmIChtc2cpIHtcbiAgICAgICAgICAgIG1lc3NhZ2VzLnB1c2gobXNnKTtcbiAgICAgICAgICAgIHBhZ2VNZXNzYWdlcy5wdXNoKG1zZyk7XG4gICAgICAgICAgfVxuICAgICAgICB9KVxuICAgICAgKTtcblxuICAgICAgbGV0IGFib3J0ID0gZmFsc2U7XG4gICAgICBpZiAob3B0cy5jYWxsYmFjaykge1xuICAgICAgICBhYm9ydCA9IEJvb2xlYW4ob3B0cy5jYWxsYmFjayhwYWdlTWVzc2FnZXMpKTtcbiAgICAgIH1cblxuICAgICAgY29uc3QgcmVzcG9uc2VQYWdlU2l6ZSA9IHJlc3BvbnNlLnBhZ2luZ0luZm8/LnBhZ2VTaXplO1xuICAgICAgY29uc3QgcXVlcnlQYWdlU2l6ZSA9IGhpc3RvcnlScGNRdWVyeS5xdWVyeT8ucGFnaW5nSW5mbz8ucGFnZVNpemU7XG4gICAgICBpZiAoXG4gICAgICAgIGFib3J0IHx8XG4gICAgICAgIC8vIFJlc3BvbnNlIHBhZ2Ugc2l6ZSBzbWFsbGVyIHRoYW4gcXVlcnksIG1lYW5pbmcgdGhpcyBpcyB0aGUgbGFzdCBwYWdlXG4gICAgICAgIChyZXNwb25zZVBhZ2VTaXplICYmIHF1ZXJ5UGFnZVNpemUgJiYgcmVzcG9uc2VQYWdlU2l6ZSA8IHF1ZXJ5UGFnZVNpemUpXG4gICAgICApIHtcbiAgICAgICAgcmV0dXJuIG1lc3NhZ2VzO1xuICAgICAgfVxuXG4gICAgICBjdXJzb3IgPSByZXNwb25zZS5wYWdpbmdJbmZvPy5jdXJzb3I7XG4gICAgICBpZiAoY3Vyc29yID09PSB1bmRlZmluZWQpIHtcbiAgICAgICAgLy8gSWYgdGhlIHNlcnZlciBkb2VzIG5vdCByZXR1cm4gY3Vyc29yIHRoZW4gdGhlcmUgaXMgYW4gaXNzdWUsXG4gICAgICAgIC8vIE5lZWQgdG8gYWJvcnQgb3Igd2UgZW5kIHVwIGluIGFuIGluZmluaXRlIGxvb3BcbiAgICAgICAgY29uc29sZS5sb2coJ05vIGN1cnNvciByZXR1cm5lZCBieSBwZWVyLicpO1xuICAgICAgICByZXR1cm4gbWVzc2FnZXM7XG4gICAgICB9XG4gICAgfVxuICB9XG5cbiAgLyoqXG4gICAqIFJlZ2lzdGVyIGEgZGVjcnlwdGlvbiBrZXkgdG8gYXR0ZW1wdCBkZWNyeXB0aW9uIG9mIG1lc3NhZ2VzIHJlY2VpdmVkIGluIGFueVxuICAgKiBzdWJzZXF1ZW50IFtbcXVlcnlIaXN0b3J5XV0gY2FsbC4gVGhpcyBjYW4gZWl0aGVyIGJlIGEgcHJpdmF0ZSBrZXkgZm9yXG4gICAqIGFzeW1tZXRyaWMgZW5jcnlwdGlvbiBvciBhIHN5bW1ldHJpYyBrZXkuIFtbV2FrdVN0b3JlXV0gd2lsbCBhdHRlbXB0IHRvXG4gICAqIGRlY3J5cHQgbWVzc2FnZXMgdXNpbmcgYm90aCBtZXRob2RzLlxuICAgKlxuICAgKiBTdHJpbmdzIG11c3QgYmUgaW4gaGV4IGZvcm1hdC5cbiAgICovXG4gIGFkZERlY3J5cHRpb25LZXkoa2V5OiBVaW50OEFycmF5IHwgc3RyaW5nKTogdm9pZCB7XG4gICAgdGhpcy5kZWNyeXB0aW9uS2V5cy5hZGQoaGV4VG9CdWYoa2V5KSk7XG4gIH1cblxuICAvKipcbiAgICogRGVsZXRlIGEgZGVjcnlwdGlvbiBrZXkgdGhhdCB3YXMgdXNlZCB0byBhdHRlbXB0IGRlY3J5cHRpb24gb2YgbWVzc2FnZXNcbiAgICogcmVjZWl2ZWQgaW4gc3Vic2VxdWVudCBbW3F1ZXJ5SGlzdG9yeV1dIGNhbGxzLlxuICAgKlxuICAgKiBTdHJpbmdzIG11c3QgYmUgaW4gaGV4IGZvcm1hdC5cbiAgICovXG4gIGRlbGV0ZURlY3J5cHRpb25LZXkoa2V5OiBVaW50OEFycmF5IHwgc3RyaW5nKTogdm9pZCB7XG4gICAgdGhpcy5kZWNyeXB0aW9uS2V5cy5kZWxldGUoaGV4VG9CdWYoa2V5KSk7XG4gIH1cblxuICAvKipcbiAgICogUmV0dXJucyBrbm93biBwZWVycyBmcm9tIHRoZSBhZGRyZXNzIGJvb2sgKGBsaWJwMnAucGVlclN0b3JlYCkgdGhhdCBzdXBwb3J0XG4gICAqIHN0b3JlIHByb3RvY29sLiBXYWt1IG1heSBvciAgbWF5IG5vdCBiZSBjdXJyZW50bHkgY29ubmVjdGVkIHRvIHRoZXNlIHBlZXJzLlxuICAgKi9cbiAgZ2V0IHBlZXJzKCk6IFBlZXJbXSB7XG4gICAgcmV0dXJuIGdldFBlZXJzRm9yUHJvdG9jb2wodGhpcy5saWJwMnAsIFN0b3JlQ29kZWMpO1xuICB9XG5cbiAgLyoqXG4gICAqIFJldHVybnMgYSByYW5kb20gcGVlciB0aGF0IHN1cHBvcnRzIHN0b3JlIHByb3RvY29sIGZyb20gdGhlIGFkZHJlc3NcbiAgICogYm9vayAoYGxpYnAycC5wZWVyU3RvcmVgKS4gV2FrdSBtYXkgb3IgIG1heSBub3QgYmUgY3VycmVudGx5IGNvbm5lY3RlZCB0b1xuICAgKiB0aGlzIHBlZXIuXG4gICAqL1xuICBnZXQgcmFuZG9tUGVlcigpOiBQZWVyIHwgdW5kZWZpbmVkIHtcbiAgICByZXR1cm4gc2VsZWN0UmFuZG9tUGVlcih0aGlzLnBlZXJzKTtcbiAgfVxufVxuIiwiZXhwb3J0IHsgV2FrdU1lc3NhZ2UgfSBmcm9tICcuL3dha3UvdjIvbWVzc2FnZSc7XG5cbmV4cG9ydCB7XG4gIEluZGV4LFxuICBQYWdpbmdJbmZvLFxuICBQYWdpbmdJbmZvX0RpcmVjdGlvbixcbiAgQ29udGVudEZpbHRlcixcbiAgSGlzdG9yeVF1ZXJ5LFxuICBIaXN0b3J5UmVzcG9uc2UsXG4gIEhpc3RvcnlSUEMsXG59IGZyb20gJy4vd2FrdS92Mi9zdG9yZSc7XG4iLCIvKiBlc2xpbnQtZGlzYWJsZSAqL1xuaW1wb3J0IExvbmcgZnJvbSAnbG9uZyc7XG5pbXBvcnQgX20wIGZyb20gJ3Byb3RvYnVmanMvbWluaW1hbCc7XG5pbXBvcnQgeyBXYWt1TWVzc2FnZSB9IGZyb20gJy4uLy4uL3dha3UvdjIvbWVzc2FnZSc7XG5cbmV4cG9ydCBjb25zdCBwcm90b2J1ZlBhY2thZ2UgPSAnd2FrdS52Mic7XG5cbmV4cG9ydCBpbnRlcmZhY2UgUHVzaFJlcXVlc3Qge1xuICBwdWJTdWJUb3BpYzogc3RyaW5nO1xuICBtZXNzYWdlOiBXYWt1TWVzc2FnZSB8IHVuZGVmaW5lZDtcbn1cblxuZXhwb3J0IGludGVyZmFjZSBQdXNoUmVzcG9uc2Uge1xuICBpc1N1Y2Nlc3M6IGJvb2xlYW47XG4gIGluZm86IHN0cmluZztcbn1cblxuZXhwb3J0IGludGVyZmFjZSBQdXNoUlBDIHtcbiAgcmVxdWVzdElkOiBzdHJpbmc7XG4gIHJlcXVlc3Q6IFB1c2hSZXF1ZXN0IHwgdW5kZWZpbmVkO1xuICByZXNwb25zZTogUHVzaFJlc3BvbnNlIHwgdW5kZWZpbmVkO1xufVxuXG5jb25zdCBiYXNlUHVzaFJlcXVlc3Q6IG9iamVjdCA9IHsgcHViU3ViVG9waWM6ICcnIH07XG5cbmV4cG9ydCBjb25zdCBQdXNoUmVxdWVzdCA9IHtcbiAgZW5jb2RlKFxuICAgIG1lc3NhZ2U6IFB1c2hSZXF1ZXN0LFxuICAgIHdyaXRlcjogX20wLldyaXRlciA9IF9tMC5Xcml0ZXIuY3JlYXRlKClcbiAgKTogX20wLldyaXRlciB7XG4gICAgaWYgKG1lc3NhZ2UucHViU3ViVG9waWMgIT09ICcnKSB7XG4gICAgICB3cml0ZXIudWludDMyKDEwKS5zdHJpbmcobWVzc2FnZS5wdWJTdWJUb3BpYyk7XG4gICAgfVxuICAgIGlmIChtZXNzYWdlLm1lc3NhZ2UgIT09IHVuZGVmaW5lZCkge1xuICAgICAgV2FrdU1lc3NhZ2UuZW5jb2RlKG1lc3NhZ2UubWVzc2FnZSwgd3JpdGVyLnVpbnQzMigxOCkuZm9yaygpKS5sZGVsaW0oKTtcbiAgICB9XG4gICAgcmV0dXJuIHdyaXRlcjtcbiAgfSxcblxuICBkZWNvZGUoaW5wdXQ6IF9tMC5SZWFkZXIgfCBVaW50OEFycmF5LCBsZW5ndGg/OiBudW1iZXIpOiBQdXNoUmVxdWVzdCB7XG4gICAgY29uc3QgcmVhZGVyID0gaW5wdXQgaW5zdGFuY2VvZiBfbTAuUmVhZGVyID8gaW5wdXQgOiBuZXcgX20wLlJlYWRlcihpbnB1dCk7XG4gICAgbGV0IGVuZCA9IGxlbmd0aCA9PT0gdW5kZWZpbmVkID8gcmVhZGVyLmxlbiA6IHJlYWRlci5wb3MgKyBsZW5ndGg7XG4gICAgY29uc3QgbWVzc2FnZSA9IHsgLi4uYmFzZVB1c2hSZXF1ZXN0IH0gYXMgUHVzaFJlcXVlc3Q7XG4gICAgd2hpbGUgKHJlYWRlci5wb3MgPCBlbmQpIHtcbiAgICAgIGNvbnN0IHRhZyA9IHJlYWRlci51aW50MzIoKTtcbiAgICAgIHN3aXRjaCAodGFnID4+PiAzKSB7XG4gICAgICAgIGNhc2UgMTpcbiAgICAgICAgICBtZXNzYWdlLnB1YlN1YlRvcGljID0gcmVhZGVyLnN0cmluZygpO1xuICAgICAgICAgIGJyZWFrO1xuICAgICAgICBjYXNlIDI6XG4gICAgICAgICAgbWVzc2FnZS5tZXNzYWdlID0gV2FrdU1lc3NhZ2UuZGVjb2RlKHJlYWRlciwgcmVhZGVyLnVpbnQzMigpKTtcbiAgICAgICAgICBicmVhaztcbiAgICAgICAgZGVmYXVsdDpcbiAgICAgICAgICByZWFkZXIuc2tpcFR5cGUodGFnICYgNyk7XG4gICAgICAgICAgYnJlYWs7XG4gICAgICB9XG4gICAgfVxuICAgIHJldHVybiBtZXNzYWdlO1xuICB9LFxuXG4gIGZyb21KU09OKG9iamVjdDogYW55KTogUHVzaFJlcXVlc3Qge1xuICAgIGNvbnN0IG1lc3NhZ2UgPSB7IC4uLmJhc2VQdXNoUmVxdWVzdCB9IGFzIFB1c2hSZXF1ZXN0O1xuICAgIGlmIChvYmplY3QucHViU3ViVG9waWMgIT09IHVuZGVmaW5lZCAmJiBvYmplY3QucHViU3ViVG9waWMgIT09IG51bGwpIHtcbiAgICAgIG1lc3NhZ2UucHViU3ViVG9waWMgPSBTdHJpbmcob2JqZWN0LnB1YlN1YlRvcGljKTtcbiAgICB9IGVsc2Uge1xuICAgICAgbWVzc2FnZS5wdWJTdWJUb3BpYyA9ICcnO1xuICAgIH1cbiAgICBpZiAob2JqZWN0Lm1lc3NhZ2UgIT09IHVuZGVmaW5lZCAmJiBvYmplY3QubWVzc2FnZSAhPT0gbnVsbCkge1xuICAgICAgbWVzc2FnZS5tZXNzYWdlID0gV2FrdU1lc3NhZ2UuZnJvbUpTT04ob2JqZWN0Lm1lc3NhZ2UpO1xuICAgIH0gZWxzZSB7XG4gICAgICBtZXNzYWdlLm1lc3NhZ2UgPSB1bmRlZmluZWQ7XG4gICAgfVxuICAgIHJldHVybiBtZXNzYWdlO1xuICB9LFxuXG4gIHRvSlNPTihtZXNzYWdlOiBQdXNoUmVxdWVzdCk6IHVua25vd24ge1xuICAgIGNvbnN0IG9iajogYW55ID0ge307XG4gICAgbWVzc2FnZS5wdWJTdWJUb3BpYyAhPT0gdW5kZWZpbmVkICYmXG4gICAgICAob2JqLnB1YlN1YlRvcGljID0gbWVzc2FnZS5wdWJTdWJUb3BpYyk7XG4gICAgbWVzc2FnZS5tZXNzYWdlICE9PSB1bmRlZmluZWQgJiZcbiAgICAgIChvYmoubWVzc2FnZSA9IG1lc3NhZ2UubWVzc2FnZVxuICAgICAgICA/IFdha3VNZXNzYWdlLnRvSlNPTihtZXNzYWdlLm1lc3NhZ2UpXG4gICAgICAgIDogdW5kZWZpbmVkKTtcbiAgICByZXR1cm4gb2JqO1xuICB9LFxuXG4gIGZyb21QYXJ0aWFsKG9iamVjdDogRGVlcFBhcnRpYWw8UHVzaFJlcXVlc3Q+KTogUHVzaFJlcXVlc3Qge1xuICAgIGNvbnN0IG1lc3NhZ2UgPSB7IC4uLmJhc2VQdXNoUmVxdWVzdCB9IGFzIFB1c2hSZXF1ZXN0O1xuICAgIGlmIChvYmplY3QucHViU3ViVG9waWMgIT09IHVuZGVmaW5lZCAmJiBvYmplY3QucHViU3ViVG9waWMgIT09IG51bGwpIHtcbiAgICAgIG1lc3NhZ2UucHViU3ViVG9waWMgPSBvYmplY3QucHViU3ViVG9waWM7XG4gICAgfSBlbHNlIHtcbiAgICAgIG1lc3NhZ2UucHViU3ViVG9waWMgPSAnJztcbiAgICB9XG4gICAgaWYgKG9iamVjdC5tZXNzYWdlICE9PSB1bmRlZmluZWQgJiYgb2JqZWN0Lm1lc3NhZ2UgIT09IG51bGwpIHtcbiAgICAgIG1lc3NhZ2UubWVzc2FnZSA9IFdha3VNZXNzYWdlLmZyb21QYXJ0aWFsKG9iamVjdC5tZXNzYWdlKTtcbiAgICB9IGVsc2Uge1xuICAgICAgbWVzc2FnZS5tZXNzYWdlID0gdW5kZWZpbmVkO1xuICAgIH1cbiAgICByZXR1cm4gbWVzc2FnZTtcbiAgfSxcbn07XG5cbmNvbnN0IGJhc2VQdXNoUmVzcG9uc2U6IG9iamVjdCA9IHsgaXNTdWNjZXNzOiBmYWxzZSwgaW5mbzogJycgfTtcblxuZXhwb3J0IGNvbnN0IFB1c2hSZXNwb25zZSA9IHtcbiAgZW5jb2RlKFxuICAgIG1lc3NhZ2U6IFB1c2hSZXNwb25zZSxcbiAgICB3cml0ZXI6IF9tMC5Xcml0ZXIgPSBfbTAuV3JpdGVyLmNyZWF0ZSgpXG4gICk6IF9tMC5Xcml0ZXIge1xuICAgIGlmIChtZXNzYWdlLmlzU3VjY2VzcyA9PT0gdHJ1ZSkge1xuICAgICAgd3JpdGVyLnVpbnQzMig4KS5ib29sKG1lc3NhZ2UuaXNTdWNjZXNzKTtcbiAgICB9XG4gICAgaWYgKG1lc3NhZ2UuaW5mbyAhPT0gJycpIHtcbiAgICAgIHdyaXRlci51aW50MzIoMTgpLnN0cmluZyhtZXNzYWdlLmluZm8pO1xuICAgIH1cbiAgICByZXR1cm4gd3JpdGVyO1xuICB9LFxuXG4gIGRlY29kZShpbnB1dDogX20wLlJlYWRlciB8IFVpbnQ4QXJyYXksIGxlbmd0aD86IG51bWJlcik6IFB1c2hSZXNwb25zZSB7XG4gICAgY29uc3QgcmVhZGVyID0gaW5wdXQgaW5zdGFuY2VvZiBfbTAuUmVhZGVyID8gaW5wdXQgOiBuZXcgX20wLlJlYWRlcihpbnB1dCk7XG4gICAgbGV0IGVuZCA9IGxlbmd0aCA9PT0gdW5kZWZpbmVkID8gcmVhZGVyLmxlbiA6IHJlYWRlci5wb3MgKyBsZW5ndGg7XG4gICAgY29uc3QgbWVzc2FnZSA9IHsgLi4uYmFzZVB1c2hSZXNwb25zZSB9IGFzIFB1c2hSZXNwb25zZTtcbiAgICB3aGlsZSAocmVhZGVyLnBvcyA8IGVuZCkge1xuICAgICAgY29uc3QgdGFnID0gcmVhZGVyLnVpbnQzMigpO1xuICAgICAgc3dpdGNoICh0YWcgPj4+IDMpIHtcbiAgICAgICAgY2FzZSAxOlxuICAgICAgICAgIG1lc3NhZ2UuaXNTdWNjZXNzID0gcmVhZGVyLmJvb2woKTtcbiAgICAgICAgICBicmVhaztcbiAgICAgICAgY2FzZSAyOlxuICAgICAgICAgIG1lc3NhZ2UuaW5mbyA9IHJlYWRlci5zdHJpbmcoKTtcbiAgICAgICAgICBicmVhaztcbiAgICAgICAgZGVmYXVsdDpcbiAgICAgICAgICByZWFkZXIuc2tpcFR5cGUodGFnICYgNyk7XG4gICAgICAgICAgYnJlYWs7XG4gICAgICB9XG4gICAgfVxuICAgIHJldHVybiBtZXNzYWdlO1xuICB9LFxuXG4gIGZyb21KU09OKG9iamVjdDogYW55KTogUHVzaFJlc3BvbnNlIHtcbiAgICBjb25zdCBtZXNzYWdlID0geyAuLi5iYXNlUHVzaFJlc3BvbnNlIH0gYXMgUHVzaFJlc3BvbnNlO1xuICAgIGlmIChvYmplY3QuaXNTdWNjZXNzICE9PSB1bmRlZmluZWQgJiYgb2JqZWN0LmlzU3VjY2VzcyAhPT0gbnVsbCkge1xuICAgICAgbWVzc2FnZS5pc1N1Y2Nlc3MgPSBCb29sZWFuKG9iamVjdC5pc1N1Y2Nlc3MpO1xuICAgIH0gZWxzZSB7XG4gICAgICBtZXNzYWdlLmlzU3VjY2VzcyA9IGZhbHNlO1xuICAgIH1cbiAgICBpZiAob2JqZWN0LmluZm8gIT09IHVuZGVmaW5lZCAmJiBvYmplY3QuaW5mbyAhPT0gbnVsbCkge1xuICAgICAgbWVzc2FnZS5pbmZvID0gU3RyaW5nKG9iamVjdC5pbmZvKTtcbiAgICB9IGVsc2Uge1xuICAgICAgbWVzc2FnZS5pbmZvID0gJyc7XG4gICAgfVxuICAgIHJldHVybiBtZXNzYWdlO1xuICB9LFxuXG4gIHRvSlNPTihtZXNzYWdlOiBQdXNoUmVzcG9uc2UpOiB1bmtub3duIHtcbiAgICBjb25zdCBvYmo6IGFueSA9IHt9O1xuICAgIG1lc3NhZ2UuaXNTdWNjZXNzICE9PSB1bmRlZmluZWQgJiYgKG9iai5pc1N1Y2Nlc3MgPSBtZXNzYWdlLmlzU3VjY2Vzcyk7XG4gICAgbWVzc2FnZS5pbmZvICE9PSB1bmRlZmluZWQgJiYgKG9iai5pbmZvID0gbWVzc2FnZS5pbmZvKTtcbiAgICByZXR1cm4gb2JqO1xuICB9LFxuXG4gIGZyb21QYXJ0aWFsKG9iamVjdDogRGVlcFBhcnRpYWw8UHVzaFJlc3BvbnNlPik6IFB1c2hSZXNwb25zZSB7XG4gICAgY29uc3QgbWVzc2FnZSA9IHsgLi4uYmFzZVB1c2hSZXNwb25zZSB9IGFzIFB1c2hSZXNwb25zZTtcbiAgICBpZiAob2JqZWN0LmlzU3VjY2VzcyAhPT0gdW5kZWZpbmVkICYmIG9iamVjdC5pc1N1Y2Nlc3MgIT09IG51bGwpIHtcbiAgICAgIG1lc3NhZ2UuaXNTdWNjZXNzID0gb2JqZWN0LmlzU3VjY2VzcztcbiAgICB9IGVsc2Uge1xuICAgICAgbWVzc2FnZS5pc1N1Y2Nlc3MgPSBmYWxzZTtcbiAgICB9XG4gICAgaWYgKG9iamVjdC5pbmZvICE9PSB1bmRlZmluZWQgJiYgb2JqZWN0LmluZm8gIT09IG51bGwpIHtcbiAgICAgIG1lc3NhZ2UuaW5mbyA9IG9iamVjdC5pbmZvO1xuICAgIH0gZWxzZSB7XG4gICAgICBtZXNzYWdlLmluZm8gPSAnJztcbiAgICB9XG4gICAgcmV0dXJuIG1lc3NhZ2U7XG4gIH0sXG59O1xuXG5jb25zdCBiYXNlUHVzaFJQQzogb2JqZWN0ID0geyByZXF1ZXN0SWQ6ICcnIH07XG5cbmV4cG9ydCBjb25zdCBQdXNoUlBDID0ge1xuICBlbmNvZGUoXG4gICAgbWVzc2FnZTogUHVzaFJQQyxcbiAgICB3cml0ZXI6IF9tMC5Xcml0ZXIgPSBfbTAuV3JpdGVyLmNyZWF0ZSgpXG4gICk6IF9tMC5Xcml0ZXIge1xuICAgIGlmIChtZXNzYWdlLnJlcXVlc3RJZCAhPT0gJycpIHtcbiAgICAgIHdyaXRlci51aW50MzIoMTApLnN0cmluZyhtZXNzYWdlLnJlcXVlc3RJZCk7XG4gICAgfVxuICAgIGlmIChtZXNzYWdlLnJlcXVlc3QgIT09IHVuZGVmaW5lZCkge1xuICAgICAgUHVzaFJlcXVlc3QuZW5jb2RlKG1lc3NhZ2UucmVxdWVzdCwgd3JpdGVyLnVpbnQzMigxOCkuZm9yaygpKS5sZGVsaW0oKTtcbiAgICB9XG4gICAgaWYgKG1lc3NhZ2UucmVzcG9uc2UgIT09IHVuZGVmaW5lZCkge1xuICAgICAgUHVzaFJlc3BvbnNlLmVuY29kZShtZXNzYWdlLnJlc3BvbnNlLCB3cml0ZXIudWludDMyKDI2KS5mb3JrKCkpLmxkZWxpbSgpO1xuICAgIH1cbiAgICByZXR1cm4gd3JpdGVyO1xuICB9LFxuXG4gIGRlY29kZShpbnB1dDogX20wLlJlYWRlciB8IFVpbnQ4QXJyYXksIGxlbmd0aD86IG51bWJlcik6IFB1c2hSUEMge1xuICAgIGNvbnN0IHJlYWRlciA9IGlucHV0IGluc3RhbmNlb2YgX20wLlJlYWRlciA/IGlucHV0IDogbmV3IF9tMC5SZWFkZXIoaW5wdXQpO1xuICAgIGxldCBlbmQgPSBsZW5ndGggPT09IHVuZGVmaW5lZCA/IHJlYWRlci5sZW4gOiByZWFkZXIucG9zICsgbGVuZ3RoO1xuICAgIGNvbnN0IG1lc3NhZ2UgPSB7IC4uLmJhc2VQdXNoUlBDIH0gYXMgUHVzaFJQQztcbiAgICB3aGlsZSAocmVhZGVyLnBvcyA8IGVuZCkge1xuICAgICAgY29uc3QgdGFnID0gcmVhZGVyLnVpbnQzMigpO1xuICAgICAgc3dpdGNoICh0YWcgPj4+IDMpIHtcbiAgICAgICAgY2FzZSAxOlxuICAgICAgICAgIG1lc3NhZ2UucmVxdWVzdElkID0gcmVhZGVyLnN0cmluZygpO1xuICAgICAgICAgIGJyZWFrO1xuICAgICAgICBjYXNlIDI6XG4gICAgICAgICAgbWVzc2FnZS5yZXF1ZXN0ID0gUHVzaFJlcXVlc3QuZGVjb2RlKHJlYWRlciwgcmVhZGVyLnVpbnQzMigpKTtcbiAgICAgICAgICBicmVhaztcbiAgICAgICAgY2FzZSAzOlxuICAgICAgICAgIG1lc3NhZ2UucmVzcG9uc2UgPSBQdXNoUmVzcG9uc2UuZGVjb2RlKHJlYWRlciwgcmVhZGVyLnVpbnQzMigpKTtcbiAgICAgICAgICBicmVhaztcbiAgICAgICAgZGVmYXVsdDpcbiAgICAgICAgICByZWFkZXIuc2tpcFR5cGUodGFnICYgNyk7XG4gICAgICAgICAgYnJlYWs7XG4gICAgICB9XG4gICAgfVxuICAgIHJldHVybiBtZXNzYWdlO1xuICB9LFxuXG4gIGZyb21KU09OKG9iamVjdDogYW55KTogUHVzaFJQQyB7XG4gICAgY29uc3QgbWVzc2FnZSA9IHsgLi4uYmFzZVB1c2hSUEMgfSBhcyBQdXNoUlBDO1xuICAgIGlmIChvYmplY3QucmVxdWVzdElkICE9PSB1bmRlZmluZWQgJiYgb2JqZWN0LnJlcXVlc3RJZCAhPT0gbnVsbCkge1xuICAgICAgbWVzc2FnZS5yZXF1ZXN0SWQgPSBTdHJpbmcob2JqZWN0LnJlcXVlc3RJZCk7XG4gICAgfSBlbHNlIHtcbiAgICAgIG1lc3NhZ2UucmVxdWVzdElkID0gJyc7XG4gICAgfVxuICAgIGlmIChvYmplY3QucmVxdWVzdCAhPT0gdW5kZWZpbmVkICYmIG9iamVjdC5yZXF1ZXN0ICE9PSBudWxsKSB7XG4gICAgICBtZXNzYWdlLnJlcXVlc3QgPSBQdXNoUmVxdWVzdC5mcm9tSlNPTihvYmplY3QucmVxdWVzdCk7XG4gICAgfSBlbHNlIHtcbiAgICAgIG1lc3NhZ2UucmVxdWVzdCA9IHVuZGVmaW5lZDtcbiAgICB9XG4gICAgaWYgKG9iamVjdC5yZXNwb25zZSAhPT0gdW5kZWZpbmVkICYmIG9iamVjdC5yZXNwb25zZSAhPT0gbnVsbCkge1xuICAgICAgbWVzc2FnZS5yZXNwb25zZSA9IFB1c2hSZXNwb25zZS5mcm9tSlNPTihvYmplY3QucmVzcG9uc2UpO1xuICAgIH0gZWxzZSB7XG4gICAgICBtZXNzYWdlLnJlc3BvbnNlID0gdW5kZWZpbmVkO1xuICAgIH1cbiAgICByZXR1cm4gbWVzc2FnZTtcbiAgfSxcblxuICB0b0pTT04obWVzc2FnZTogUHVzaFJQQyk6IHVua25vd24ge1xuICAgIGNvbnN0IG9iajogYW55ID0ge307XG4gICAgbWVzc2FnZS5yZXF1ZXN0SWQgIT09IHVuZGVmaW5lZCAmJiAob2JqLnJlcXVlc3RJZCA9IG1lc3NhZ2UucmVxdWVzdElkKTtcbiAgICBtZXNzYWdlLnJlcXVlc3QgIT09IHVuZGVmaW5lZCAmJlxuICAgICAgKG9iai5yZXF1ZXN0ID0gbWVzc2FnZS5yZXF1ZXN0XG4gICAgICAgID8gUHVzaFJlcXVlc3QudG9KU09OKG1lc3NhZ2UucmVxdWVzdClcbiAgICAgICAgOiB1bmRlZmluZWQpO1xuICAgIG1lc3NhZ2UucmVzcG9uc2UgIT09IHVuZGVmaW5lZCAmJlxuICAgICAgKG9iai5yZXNwb25zZSA9IG1lc3NhZ2UucmVzcG9uc2VcbiAgICAgICAgPyBQdXNoUmVzcG9uc2UudG9KU09OKG1lc3NhZ2UucmVzcG9uc2UpXG4gICAgICAgIDogdW5kZWZpbmVkKTtcbiAgICByZXR1cm4gb2JqO1xuICB9LFxuXG4gIGZyb21QYXJ0aWFsKG9iamVjdDogRGVlcFBhcnRpYWw8UHVzaFJQQz4pOiBQdXNoUlBDIHtcbiAgICBjb25zdCBtZXNzYWdlID0geyAuLi5iYXNlUHVzaFJQQyB9IGFzIFB1c2hSUEM7XG4gICAgaWYgKG9iamVjdC5yZXF1ZXN0SWQgIT09IHVuZGVmaW5lZCAmJiBvYmplY3QucmVxdWVzdElkICE9PSBudWxsKSB7XG4gICAgICBtZXNzYWdlLnJlcXVlc3RJZCA9IG9iamVjdC5yZXF1ZXN0SWQ7XG4gICAgfSBlbHNlIHtcbiAgICAgIG1lc3NhZ2UucmVxdWVzdElkID0gJyc7XG4gICAgfVxuICAgIGlmIChvYmplY3QucmVxdWVzdCAhPT0gdW5kZWZpbmVkICYmIG9iamVjdC5yZXF1ZXN0ICE9PSBudWxsKSB7XG4gICAgICBtZXNzYWdlLnJlcXVlc3QgPSBQdXNoUmVxdWVzdC5mcm9tUGFydGlhbChvYmplY3QucmVxdWVzdCk7XG4gICAgfSBlbHNlIHtcbiAgICAgIG1lc3NhZ2UucmVxdWVzdCA9IHVuZGVmaW5lZDtcbiAgICB9XG4gICAgaWYgKG9iamVjdC5yZXNwb25zZSAhPT0gdW5kZWZpbmVkICYmIG9iamVjdC5yZXNwb25zZSAhPT0gbnVsbCkge1xuICAgICAgbWVzc2FnZS5yZXNwb25zZSA9IFB1c2hSZXNwb25zZS5mcm9tUGFydGlhbChvYmplY3QucmVzcG9uc2UpO1xuICAgIH0gZWxzZSB7XG4gICAgICBtZXNzYWdlLnJlc3BvbnNlID0gdW5kZWZpbmVkO1xuICAgIH1cbiAgICByZXR1cm4gbWVzc2FnZTtcbiAgfSxcbn07XG5cbnR5cGUgQnVpbHRpbiA9XG4gIHwgRGF0ZVxuICB8IEZ1bmN0aW9uXG4gIHwgVWludDhBcnJheVxuICB8IHN0cmluZ1xuICB8IG51bWJlclxuICB8IGJvb2xlYW5cbiAgfCB1bmRlZmluZWQ7XG5leHBvcnQgdHlwZSBEZWVwUGFydGlhbDxUPiA9IFQgZXh0ZW5kcyBCdWlsdGluXG4gID8gVFxuICA6IFQgZXh0ZW5kcyBBcnJheTxpbmZlciBVPlxuICA/IEFycmF5PERlZXBQYXJ0aWFsPFU+PlxuICA6IFQgZXh0ZW5kcyBSZWFkb25seUFycmF5PGluZmVyIFU+XG4gID8gUmVhZG9ubHlBcnJheTxEZWVwUGFydGlhbDxVPj5cbiAgOiBUIGV4dGVuZHMge31cbiAgPyB7IFtLIGluIGtleW9mIFRdPzogRGVlcFBhcnRpYWw8VFtLXT4gfVxuICA6IFBhcnRpYWw8VD47XG5cbmlmIChfbTAudXRpbC5Mb25nICE9PSBMb25nKSB7XG4gIF9tMC51dGlsLkxvbmcgPSBMb25nIGFzIGFueTtcbiAgX20wLmNvbmZpZ3VyZSgpO1xufVxuIiwiLyogZXNsaW50LWRpc2FibGUgKi9cbmltcG9ydCBMb25nIGZyb20gJ2xvbmcnO1xuaW1wb3J0IF9tMCBmcm9tICdwcm90b2J1ZmpzL21pbmltYWwnO1xuXG5leHBvcnQgY29uc3QgcHJvdG9idWZQYWNrYWdlID0gJ3dha3UudjInO1xuXG5leHBvcnQgaW50ZXJmYWNlIFdha3VNZXNzYWdlIHtcbiAgcGF5bG9hZD86IFVpbnQ4QXJyYXkgfCB1bmRlZmluZWQ7XG4gIGNvbnRlbnRUb3BpYz86IHN0cmluZyB8IHVuZGVmaW5lZDtcbiAgdmVyc2lvbj86IG51bWJlciB8IHVuZGVmaW5lZDtcbiAgdGltZXN0YW1wPzogbnVtYmVyIHwgdW5kZWZpbmVkO1xufVxuXG5jb25zdCBiYXNlV2FrdU1lc3NhZ2U6IG9iamVjdCA9IHt9O1xuXG5leHBvcnQgY29uc3QgV2FrdU1lc3NhZ2UgPSB7XG4gIGVuY29kZShcbiAgICBtZXNzYWdlOiBXYWt1TWVzc2FnZSxcbiAgICB3cml0ZXI6IF9tMC5Xcml0ZXIgPSBfbTAuV3JpdGVyLmNyZWF0ZSgpXG4gICk6IF9tMC5Xcml0ZXIge1xuICAgIGlmIChtZXNzYWdlLnBheWxvYWQgIT09IHVuZGVmaW5lZCkge1xuICAgICAgd3JpdGVyLnVpbnQzMigxMCkuYnl0ZXMobWVzc2FnZS5wYXlsb2FkKTtcbiAgICB9XG4gICAgaWYgKG1lc3NhZ2UuY29udGVudFRvcGljICE9PSB1bmRlZmluZWQpIHtcbiAgICAgIHdyaXRlci51aW50MzIoMTgpLnN0cmluZyhtZXNzYWdlLmNvbnRlbnRUb3BpYyk7XG4gICAgfVxuICAgIGlmIChtZXNzYWdlLnZlcnNpb24gIT09IHVuZGVmaW5lZCkge1xuICAgICAgd3JpdGVyLnVpbnQzMigyNCkudWludDMyKG1lc3NhZ2UudmVyc2lvbik7XG4gICAgfVxuICAgIGlmIChtZXNzYWdlLnRpbWVzdGFtcCAhPT0gdW5kZWZpbmVkKSB7XG4gICAgICB3cml0ZXIudWludDMyKDMzKS5kb3VibGUobWVzc2FnZS50aW1lc3RhbXApO1xuICAgIH1cbiAgICByZXR1cm4gd3JpdGVyO1xuICB9LFxuXG4gIGRlY29kZShpbnB1dDogX20wLlJlYWRlciB8IFVpbnQ4QXJyYXksIGxlbmd0aD86IG51bWJlcik6IFdha3VNZXNzYWdlIHtcbiAgICBjb25zdCByZWFkZXIgPSBpbnB1dCBpbnN0YW5jZW9mIF9tMC5SZWFkZXIgPyBpbnB1dCA6IG5ldyBfbTAuUmVhZGVyKGlucHV0KTtcbiAgICBsZXQgZW5kID0gbGVuZ3RoID09PSB1bmRlZmluZWQgPyByZWFkZXIubGVuIDogcmVhZGVyLnBvcyArIGxlbmd0aDtcbiAgICBjb25zdCBtZXNzYWdlID0geyAuLi5iYXNlV2FrdU1lc3NhZ2UgfSBhcyBXYWt1TWVzc2FnZTtcbiAgICB3aGlsZSAocmVhZGVyLnBvcyA8IGVuZCkge1xuICAgICAgY29uc3QgdGFnID0gcmVhZGVyLnVpbnQzMigpO1xuICAgICAgc3dpdGNoICh0YWcgPj4+IDMpIHtcbiAgICAgICAgY2FzZSAxOlxuICAgICAgICAgIG1lc3NhZ2UucGF5bG9hZCA9IHJlYWRlci5ieXRlcygpO1xuICAgICAgICAgIGJyZWFrO1xuICAgICAgICBjYXNlIDI6XG4gICAgICAgICAgbWVzc2FnZS5jb250ZW50VG9waWMgPSByZWFkZXIuc3RyaW5nKCk7XG4gICAgICAgICAgYnJlYWs7XG4gICAgICAgIGNhc2UgMzpcbiAgICAgICAgICBtZXNzYWdlLnZlcnNpb24gPSByZWFkZXIudWludDMyKCk7XG4gICAgICAgICAgYnJlYWs7XG4gICAgICAgIGNhc2UgNDpcbiAgICAgICAgICBtZXNzYWdlLnRpbWVzdGFtcCA9IHJlYWRlci5kb3VibGUoKTtcbiAgICAgICAgICBicmVhaztcbiAgICAgICAgZGVmYXVsdDpcbiAgICAgICAgICByZWFkZXIuc2tpcFR5cGUodGFnICYgNyk7XG4gICAgICAgICAgYnJlYWs7XG4gICAgICB9XG4gICAgfVxuICAgIHJldHVybiBtZXNzYWdlO1xuICB9LFxuXG4gIGZyb21KU09OKG9iamVjdDogYW55KTogV2FrdU1lc3NhZ2Uge1xuICAgIGNvbnN0IG1lc3NhZ2UgPSB7IC4uLmJhc2VXYWt1TWVzc2FnZSB9IGFzIFdha3VNZXNzYWdlO1xuICAgIGlmIChvYmplY3QucGF5bG9hZCAhPT0gdW5kZWZpbmVkICYmIG9iamVjdC5wYXlsb2FkICE9PSBudWxsKSB7XG4gICAgICBtZXNzYWdlLnBheWxvYWQgPSBieXRlc0Zyb21CYXNlNjQob2JqZWN0LnBheWxvYWQpO1xuICAgIH1cbiAgICBpZiAob2JqZWN0LmNvbnRlbnRUb3BpYyAhPT0gdW5kZWZpbmVkICYmIG9iamVjdC5jb250ZW50VG9waWMgIT09IG51bGwpIHtcbiAgICAgIG1lc3NhZ2UuY29udGVudFRvcGljID0gU3RyaW5nKG9iamVjdC5jb250ZW50VG9waWMpO1xuICAgIH0gZWxzZSB7XG4gICAgICBtZXNzYWdlLmNvbnRlbnRUb3BpYyA9IHVuZGVmaW5lZDtcbiAgICB9XG4gICAgaWYgKG9iamVjdC52ZXJzaW9uICE9PSB1bmRlZmluZWQgJiYgb2JqZWN0LnZlcnNpb24gIT09IG51bGwpIHtcbiAgICAgIG1lc3NhZ2UudmVyc2lvbiA9IE51bWJlcihvYmplY3QudmVyc2lvbik7XG4gICAgfSBlbHNlIHtcbiAgICAgIG1lc3NhZ2UudmVyc2lvbiA9IHVuZGVmaW5lZDtcbiAgICB9XG4gICAgaWYgKG9iamVjdC50aW1lc3RhbXAgIT09IHVuZGVmaW5lZCAmJiBvYmplY3QudGltZXN0YW1wICE9PSBudWxsKSB7XG4gICAgICBtZXNzYWdlLnRpbWVzdGFtcCA9IE51bWJlcihvYmplY3QudGltZXN0YW1wKTtcbiAgICB9IGVsc2Uge1xuICAgICAgbWVzc2FnZS50aW1lc3RhbXAgPSB1bmRlZmluZWQ7XG4gICAgfVxuICAgIHJldHVybiBtZXNzYWdlO1xuICB9LFxuXG4gIHRvSlNPTihtZXNzYWdlOiBXYWt1TWVzc2FnZSk6IHVua25vd24ge1xuICAgIGNvbnN0IG9iajogYW55ID0ge307XG4gICAgbWVzc2FnZS5wYXlsb2FkICE9PSB1bmRlZmluZWQgJiZcbiAgICAgIChvYmoucGF5bG9hZCA9XG4gICAgICAgIG1lc3NhZ2UucGF5bG9hZCAhPT0gdW5kZWZpbmVkXG4gICAgICAgICAgPyBiYXNlNjRGcm9tQnl0ZXMobWVzc2FnZS5wYXlsb2FkKVxuICAgICAgICAgIDogdW5kZWZpbmVkKTtcbiAgICBtZXNzYWdlLmNvbnRlbnRUb3BpYyAhPT0gdW5kZWZpbmVkICYmXG4gICAgICAob2JqLmNvbnRlbnRUb3BpYyA9IG1lc3NhZ2UuY29udGVudFRvcGljKTtcbiAgICBtZXNzYWdlLnZlcnNpb24gIT09IHVuZGVmaW5lZCAmJiAob2JqLnZlcnNpb24gPSBtZXNzYWdlLnZlcnNpb24pO1xuICAgIG1lc3NhZ2UudGltZXN0YW1wICE9PSB1bmRlZmluZWQgJiYgKG9iai50aW1lc3RhbXAgPSBtZXNzYWdlLnRpbWVzdGFtcCk7XG4gICAgcmV0dXJuIG9iajtcbiAgfSxcblxuICBmcm9tUGFydGlhbChvYmplY3Q6IERlZXBQYXJ0aWFsPFdha3VNZXNzYWdlPik6IFdha3VNZXNzYWdlIHtcbiAgICBjb25zdCBtZXNzYWdlID0geyAuLi5iYXNlV2FrdU1lc3NhZ2UgfSBhcyBXYWt1TWVzc2FnZTtcbiAgICBpZiAob2JqZWN0LnBheWxvYWQgIT09IHVuZGVmaW5lZCAmJiBvYmplY3QucGF5bG9hZCAhPT0gbnVsbCkge1xuICAgICAgbWVzc2FnZS5wYXlsb2FkID0gb2JqZWN0LnBheWxvYWQ7XG4gICAgfSBlbHNlIHtcbiAgICAgIG1lc3NhZ2UucGF5bG9hZCA9IHVuZGVmaW5lZDtcbiAgICB9XG4gICAgaWYgKG9iamVjdC5jb250ZW50VG9waWMgIT09IHVuZGVmaW5lZCAmJiBvYmplY3QuY29udGVudFRvcGljICE9PSBudWxsKSB7XG4gICAgICBtZXNzYWdlLmNvbnRlbnRUb3BpYyA9IG9iamVjdC5jb250ZW50VG9waWM7XG4gICAgfSBlbHNlIHtcbiAgICAgIG1lc3NhZ2UuY29udGVudFRvcGljID0gdW5kZWZpbmVkO1xuICAgIH1cbiAgICBpZiAob2JqZWN0LnZlcnNpb24gIT09IHVuZGVmaW5lZCAmJiBvYmplY3QudmVyc2lvbiAhPT0gbnVsbCkge1xuICAgICAgbWVzc2FnZS52ZXJzaW9uID0gb2JqZWN0LnZlcnNpb247XG4gICAgfSBlbHNlIHtcbiAgICAgIG1lc3NhZ2UudmVyc2lvbiA9IHVuZGVmaW5lZDtcbiAgICB9XG4gICAgaWYgKG9iamVjdC50aW1lc3RhbXAgIT09IHVuZGVmaW5lZCAmJiBvYmplY3QudGltZXN0YW1wICE9PSBudWxsKSB7XG4gICAgICBtZXNzYWdlLnRpbWVzdGFtcCA9IG9iamVjdC50aW1lc3RhbXA7XG4gICAgfSBlbHNlIHtcbiAgICAgIG1lc3NhZ2UudGltZXN0YW1wID0gdW5kZWZpbmVkO1xuICAgIH1cbiAgICByZXR1cm4gbWVzc2FnZTtcbiAgfSxcbn07XG5cbmRlY2xhcmUgdmFyIHNlbGY6IGFueSB8IHVuZGVmaW5lZDtcbmRlY2xhcmUgdmFyIHdpbmRvdzogYW55IHwgdW5kZWZpbmVkO1xudmFyIGdsb2JhbFRoaXM6IGFueSA9ICgoKSA9PiB7XG4gIGlmICh0eXBlb2YgZ2xvYmFsVGhpcyAhPT0gJ3VuZGVmaW5lZCcpIHJldHVybiBnbG9iYWxUaGlzO1xuICBpZiAodHlwZW9mIHNlbGYgIT09ICd1bmRlZmluZWQnKSByZXR1cm4gc2VsZjtcbiAgaWYgKHR5cGVvZiB3aW5kb3cgIT09ICd1bmRlZmluZWQnKSByZXR1cm4gd2luZG93O1xuICBpZiAodHlwZW9mIGdsb2JhbCAhPT0gJ3VuZGVmaW5lZCcpIHJldHVybiBnbG9iYWw7XG4gIHRocm93ICdVbmFibGUgdG8gbG9jYXRlIGdsb2JhbCBvYmplY3QnO1xufSkoKTtcblxuY29uc3QgYXRvYjogKGI2NDogc3RyaW5nKSA9PiBzdHJpbmcgPVxuICBnbG9iYWxUaGlzLmF0b2IgfHxcbiAgKChiNjQpID0+IGdsb2JhbFRoaXMuQnVmZmVyLmZyb20oYjY0LCAnYmFzZTY0JykudG9TdHJpbmcoJ2JpbmFyeScpKTtcbmZ1bmN0aW9uIGJ5dGVzRnJvbUJhc2U2NChiNjQ6IHN0cmluZyk6IFVpbnQ4QXJyYXkge1xuICBjb25zdCBiaW4gPSBhdG9iKGI2NCk7XG4gIGNvbnN0IGFyciA9IG5ldyBVaW50OEFycmF5KGJpbi5sZW5ndGgpO1xuICBmb3IgKGxldCBpID0gMDsgaSA8IGJpbi5sZW5ndGg7ICsraSkge1xuICAgIGFycltpXSA9IGJpbi5jaGFyQ29kZUF0KGkpO1xuICB9XG4gIHJldHVybiBhcnI7XG59XG5cbmNvbnN0IGJ0b2E6IChiaW46IHN0cmluZykgPT4gc3RyaW5nID1cbiAgZ2xvYmFsVGhpcy5idG9hIHx8XG4gICgoYmluKSA9PiBnbG9iYWxUaGlzLkJ1ZmZlci5mcm9tKGJpbiwgJ2JpbmFyeScpLnRvU3RyaW5nKCdiYXNlNjQnKSk7XG5mdW5jdGlvbiBiYXNlNjRGcm9tQnl0ZXMoYXJyOiBVaW50OEFycmF5KTogc3RyaW5nIHtcbiAgY29uc3QgYmluOiBzdHJpbmdbXSA9IFtdO1xuICBmb3IgKGNvbnN0IGJ5dGUgb2YgYXJyKSB7XG4gICAgYmluLnB1c2goU3RyaW5nLmZyb21DaGFyQ29kZShieXRlKSk7XG4gIH1cbiAgcmV0dXJuIGJ0b2EoYmluLmpvaW4oJycpKTtcbn1cblxudHlwZSBCdWlsdGluID1cbiAgfCBEYXRlXG4gIHwgRnVuY3Rpb25cbiAgfCBVaW50OEFycmF5XG4gIHwgc3RyaW5nXG4gIHwgbnVtYmVyXG4gIHwgYm9vbGVhblxuICB8IHVuZGVmaW5lZDtcbmV4cG9ydCB0eXBlIERlZXBQYXJ0aWFsPFQ+ID0gVCBleHRlbmRzIEJ1aWx0aW5cbiAgPyBUXG4gIDogVCBleHRlbmRzIEFycmF5PGluZmVyIFU+XG4gID8gQXJyYXk8RGVlcFBhcnRpYWw8VT4+XG4gIDogVCBleHRlbmRzIFJlYWRvbmx5QXJyYXk8aW5mZXIgVT5cbiAgPyBSZWFkb25seUFycmF5PERlZXBQYXJ0aWFsPFU+PlxuICA6IFQgZXh0ZW5kcyB7fVxuICA/IHsgW0sgaW4ga2V5b2YgVF0/OiBEZWVwUGFydGlhbDxUW0tdPiB9XG4gIDogUGFydGlhbDxUPjtcblxuaWYgKF9tMC51dGlsLkxvbmcgIT09IExvbmcpIHtcbiAgX20wLnV0aWwuTG9uZyA9IExvbmcgYXMgYW55O1xuICBfbTAuY29uZmlndXJlKCk7XG59XG4iLCIvKiBlc2xpbnQtZGlzYWJsZSAqL1xuaW1wb3J0IExvbmcgZnJvbSAnbG9uZyc7XG5pbXBvcnQgX20wIGZyb20gJ3Byb3RvYnVmanMvbWluaW1hbCc7XG5pbXBvcnQgeyBXYWt1TWVzc2FnZSB9IGZyb20gJy4uLy4uL3dha3UvdjIvbWVzc2FnZSc7XG5cbmV4cG9ydCBjb25zdCBwcm90b2J1ZlBhY2thZ2UgPSAnd2FrdS52Mic7XG5cbmV4cG9ydCBpbnRlcmZhY2UgSW5kZXgge1xuICBkaWdlc3Q6IFVpbnQ4QXJyYXk7XG4gIHJlY2VpdmVkVGltZTogbnVtYmVyO1xuICBzZW5kZXJUaW1lOiBudW1iZXI7XG59XG5cbmV4cG9ydCBpbnRlcmZhY2UgUGFnaW5nSW5mbyB7XG4gIHBhZ2VTaXplOiBudW1iZXI7XG4gIGN1cnNvcjogSW5kZXggfCB1bmRlZmluZWQ7XG4gIGRpcmVjdGlvbjogUGFnaW5nSW5mb19EaXJlY3Rpb247XG59XG5cbmV4cG9ydCBlbnVtIFBhZ2luZ0luZm9fRGlyZWN0aW9uIHtcbiAgRElSRUNUSU9OX0JBQ0tXQVJEX1VOU1BFQ0lGSUVEID0gMCxcbiAgRElSRUNUSU9OX0ZPUldBUkQgPSAxLFxuICBVTlJFQ09HTklaRUQgPSAtMSxcbn1cblxuZXhwb3J0IGZ1bmN0aW9uIHBhZ2luZ0luZm9fRGlyZWN0aW9uRnJvbUpTT04oXG4gIG9iamVjdDogYW55XG4pOiBQYWdpbmdJbmZvX0RpcmVjdGlvbiB7XG4gIHN3aXRjaCAob2JqZWN0KSB7XG4gICAgY2FzZSAwOlxuICAgIGNhc2UgJ0RJUkVDVElPTl9CQUNLV0FSRF9VTlNQRUNJRklFRCc6XG4gICAgICByZXR1cm4gUGFnaW5nSW5mb19EaXJlY3Rpb24uRElSRUNUSU9OX0JBQ0tXQVJEX1VOU1BFQ0lGSUVEO1xuICAgIGNhc2UgMTpcbiAgICBjYXNlICdESVJFQ1RJT05fRk9SV0FSRCc6XG4gICAgICByZXR1cm4gUGFnaW5nSW5mb19EaXJlY3Rpb24uRElSRUNUSU9OX0ZPUldBUkQ7XG4gICAgY2FzZSAtMTpcbiAgICBjYXNlICdVTlJFQ09HTklaRUQnOlxuICAgIGRlZmF1bHQ6XG4gICAgICByZXR1cm4gUGFnaW5nSW5mb19EaXJlY3Rpb24uVU5SRUNPR05JWkVEO1xuICB9XG59XG5cbmV4cG9ydCBmdW5jdGlvbiBwYWdpbmdJbmZvX0RpcmVjdGlvblRvSlNPTihcbiAgb2JqZWN0OiBQYWdpbmdJbmZvX0RpcmVjdGlvblxuKTogc3RyaW5nIHtcbiAgc3dpdGNoIChvYmplY3QpIHtcbiAgICBjYXNlIFBhZ2luZ0luZm9fRGlyZWN0aW9uLkRJUkVDVElPTl9CQUNLV0FSRF9VTlNQRUNJRklFRDpcbiAgICAgIHJldHVybiAnRElSRUNUSU9OX0JBQ0tXQVJEX1VOU1BFQ0lGSUVEJztcbiAgICBjYXNlIFBhZ2luZ0luZm9fRGlyZWN0aW9uLkRJUkVDVElPTl9GT1JXQVJEOlxuICAgICAgcmV0dXJuICdESVJFQ1RJT05fRk9SV0FSRCc7XG4gICAgZGVmYXVsdDpcbiAgICAgIHJldHVybiAnVU5LTk9XTic7XG4gIH1cbn1cblxuZXhwb3J0IGludGVyZmFjZSBDb250ZW50RmlsdGVyIHtcbiAgY29udGVudFRvcGljOiBzdHJpbmc7XG59XG5cbmV4cG9ydCBpbnRlcmZhY2UgSGlzdG9yeVF1ZXJ5IHtcbiAgcHViU3ViVG9waWM/OiBzdHJpbmcgfCB1bmRlZmluZWQ7XG4gIGNvbnRlbnRGaWx0ZXJzOiBDb250ZW50RmlsdGVyW107XG4gIHBhZ2luZ0luZm8/OiBQYWdpbmdJbmZvIHwgdW5kZWZpbmVkO1xuICBzdGFydFRpbWU/OiBudW1iZXIgfCB1bmRlZmluZWQ7XG4gIGVuZFRpbWU/OiBudW1iZXIgfCB1bmRlZmluZWQ7XG59XG5cbmV4cG9ydCBpbnRlcmZhY2UgSGlzdG9yeVJlc3BvbnNlIHtcbiAgbWVzc2FnZXM6IFdha3VNZXNzYWdlW107XG4gIHBhZ2luZ0luZm86IFBhZ2luZ0luZm8gfCB1bmRlZmluZWQ7XG4gIGVycm9yOiBIaXN0b3J5UmVzcG9uc2VfRXJyb3I7XG59XG5cbmV4cG9ydCBlbnVtIEhpc3RvcnlSZXNwb25zZV9FcnJvciB7XG4gIEVSUk9SX05PTkVfVU5TUEVDSUZJRUQgPSAwLFxuICBFUlJPUl9JTlZBTElEX0NVUlNPUiA9IDEsXG4gIFVOUkVDT0dOSVpFRCA9IC0xLFxufVxuXG5leHBvcnQgZnVuY3Rpb24gaGlzdG9yeVJlc3BvbnNlX0Vycm9yRnJvbUpTT04oXG4gIG9iamVjdDogYW55XG4pOiBIaXN0b3J5UmVzcG9uc2VfRXJyb3Ige1xuICBzd2l0Y2ggKG9iamVjdCkge1xuICAgIGNhc2UgMDpcbiAgICBjYXNlICdFUlJPUl9OT05FX1VOU1BFQ0lGSUVEJzpcbiAgICAgIHJldHVybiBIaXN0b3J5UmVzcG9uc2VfRXJyb3IuRVJST1JfTk9ORV9VTlNQRUNJRklFRDtcbiAgICBjYXNlIDE6XG4gICAgY2FzZSAnRVJST1JfSU5WQUxJRF9DVVJTT1InOlxuICAgICAgcmV0dXJuIEhpc3RvcnlSZXNwb25zZV9FcnJvci5FUlJPUl9JTlZBTElEX0NVUlNPUjtcbiAgICBjYXNlIC0xOlxuICAgIGNhc2UgJ1VOUkVDT0dOSVpFRCc6XG4gICAgZGVmYXVsdDpcbiAgICAgIHJldHVybiBIaXN0b3J5UmVzcG9uc2VfRXJyb3IuVU5SRUNPR05JWkVEO1xuICB9XG59XG5cbmV4cG9ydCBmdW5jdGlvbiBoaXN0b3J5UmVzcG9uc2VfRXJyb3JUb0pTT04oXG4gIG9iamVjdDogSGlzdG9yeVJlc3BvbnNlX0Vycm9yXG4pOiBzdHJpbmcge1xuICBzd2l0Y2ggKG9iamVjdCkge1xuICAgIGNhc2UgSGlzdG9yeVJlc3BvbnNlX0Vycm9yLkVSUk9SX05PTkVfVU5TUEVDSUZJRUQ6XG4gICAgICByZXR1cm4gJ0VSUk9SX05PTkVfVU5TUEVDSUZJRUQnO1xuICAgIGNhc2UgSGlzdG9yeVJlc3BvbnNlX0Vycm9yLkVSUk9SX0lOVkFMSURfQ1VSU09SOlxuICAgICAgcmV0dXJuICdFUlJPUl9JTlZBTElEX0NVUlNPUic7XG4gICAgZGVmYXVsdDpcbiAgICAgIHJldHVybiAnVU5LTk9XTic7XG4gIH1cbn1cblxuZXhwb3J0IGludGVyZmFjZSBIaXN0b3J5UlBDIHtcbiAgcmVxdWVzdElkOiBzdHJpbmc7XG4gIHF1ZXJ5OiBIaXN0b3J5UXVlcnkgfCB1bmRlZmluZWQ7XG4gIHJlc3BvbnNlOiBIaXN0b3J5UmVzcG9uc2UgfCB1bmRlZmluZWQ7XG59XG5cbmNvbnN0IGJhc2VJbmRleDogb2JqZWN0ID0geyByZWNlaXZlZFRpbWU6IDAsIHNlbmRlclRpbWU6IDAgfTtcblxuZXhwb3J0IGNvbnN0IEluZGV4ID0ge1xuICBlbmNvZGUobWVzc2FnZTogSW5kZXgsIHdyaXRlcjogX20wLldyaXRlciA9IF9tMC5Xcml0ZXIuY3JlYXRlKCkpOiBfbTAuV3JpdGVyIHtcbiAgICBpZiAobWVzc2FnZS5kaWdlc3QubGVuZ3RoICE9PSAwKSB7XG4gICAgICB3cml0ZXIudWludDMyKDEwKS5ieXRlcyhtZXNzYWdlLmRpZ2VzdCk7XG4gICAgfVxuICAgIGlmIChtZXNzYWdlLnJlY2VpdmVkVGltZSAhPT0gMCkge1xuICAgICAgd3JpdGVyLnVpbnQzMigxNykuZG91YmxlKG1lc3NhZ2UucmVjZWl2ZWRUaW1lKTtcbiAgICB9XG4gICAgaWYgKG1lc3NhZ2Uuc2VuZGVyVGltZSAhPT0gMCkge1xuICAgICAgd3JpdGVyLnVpbnQzMigyNSkuZG91YmxlKG1lc3NhZ2Uuc2VuZGVyVGltZSk7XG4gICAgfVxuICAgIHJldHVybiB3cml0ZXI7XG4gIH0sXG5cbiAgZGVjb2RlKGlucHV0OiBfbTAuUmVhZGVyIHwgVWludDhBcnJheSwgbGVuZ3RoPzogbnVtYmVyKTogSW5kZXgge1xuICAgIGNvbnN0IHJlYWRlciA9IGlucHV0IGluc3RhbmNlb2YgX20wLlJlYWRlciA/IGlucHV0IDogbmV3IF9tMC5SZWFkZXIoaW5wdXQpO1xuICAgIGxldCBlbmQgPSBsZW5ndGggPT09IHVuZGVmaW5lZCA/IHJlYWRlci5sZW4gOiByZWFkZXIucG9zICsgbGVuZ3RoO1xuICAgIGNvbnN0IG1lc3NhZ2UgPSB7IC4uLmJhc2VJbmRleCB9IGFzIEluZGV4O1xuICAgIG1lc3NhZ2UuZGlnZXN0ID0gbmV3IFVpbnQ4QXJyYXkoKTtcbiAgICB3aGlsZSAocmVhZGVyLnBvcyA8IGVuZCkge1xuICAgICAgY29uc3QgdGFnID0gcmVhZGVyLnVpbnQzMigpO1xuICAgICAgc3dpdGNoICh0YWcgPj4+IDMpIHtcbiAgICAgICAgY2FzZSAxOlxuICAgICAgICAgIG1lc3NhZ2UuZGlnZXN0ID0gcmVhZGVyLmJ5dGVzKCk7XG4gICAgICAgICAgYnJlYWs7XG4gICAgICAgIGNhc2UgMjpcbiAgICAgICAgICBtZXNzYWdlLnJlY2VpdmVkVGltZSA9IHJlYWRlci5kb3VibGUoKTtcbiAgICAgICAgICBicmVhaztcbiAgICAgICAgY2FzZSAzOlxuICAgICAgICAgIG1lc3NhZ2Uuc2VuZGVyVGltZSA9IHJlYWRlci5kb3VibGUoKTtcbiAgICAgICAgICBicmVhaztcbiAgICAgICAgZGVmYXVsdDpcbiAgICAgICAgICByZWFkZXIuc2tpcFR5cGUodGFnICYgNyk7XG4gICAgICAgICAgYnJlYWs7XG4gICAgICB9XG4gICAgfVxuICAgIHJldHVybiBtZXNzYWdlO1xuICB9LFxuXG4gIGZyb21KU09OKG9iamVjdDogYW55KTogSW5kZXgge1xuICAgIGNvbnN0IG1lc3NhZ2UgPSB7IC4uLmJhc2VJbmRleCB9IGFzIEluZGV4O1xuICAgIG1lc3NhZ2UuZGlnZXN0ID0gbmV3IFVpbnQ4QXJyYXkoKTtcbiAgICBpZiAob2JqZWN0LmRpZ2VzdCAhPT0gdW5kZWZpbmVkICYmIG9iamVjdC5kaWdlc3QgIT09IG51bGwpIHtcbiAgICAgIG1lc3NhZ2UuZGlnZXN0ID0gYnl0ZXNGcm9tQmFzZTY0KG9iamVjdC5kaWdlc3QpO1xuICAgIH1cbiAgICBpZiAob2JqZWN0LnJlY2VpdmVkVGltZSAhPT0gdW5kZWZpbmVkICYmIG9iamVjdC5yZWNlaXZlZFRpbWUgIT09IG51bGwpIHtcbiAgICAgIG1lc3NhZ2UucmVjZWl2ZWRUaW1lID0gTnVtYmVyKG9iamVjdC5yZWNlaXZlZFRpbWUpO1xuICAgIH0gZWxzZSB7XG4gICAgICBtZXNzYWdlLnJlY2VpdmVkVGltZSA9IDA7XG4gICAgfVxuICAgIGlmIChvYmplY3Quc2VuZGVyVGltZSAhPT0gdW5kZWZpbmVkICYmIG9iamVjdC5zZW5kZXJUaW1lICE9PSBudWxsKSB7XG4gICAgICBtZXNzYWdlLnNlbmRlclRpbWUgPSBOdW1iZXIob2JqZWN0LnNlbmRlclRpbWUpO1xuICAgIH0gZWxzZSB7XG4gICAgICBtZXNzYWdlLnNlbmRlclRpbWUgPSAwO1xuICAgIH1cbiAgICByZXR1cm4gbWVzc2FnZTtcbiAgfSxcblxuICB0b0pTT04obWVzc2FnZTogSW5kZXgpOiB1bmtub3duIHtcbiAgICBjb25zdCBvYmo6IGFueSA9IHt9O1xuICAgIG1lc3NhZ2UuZGlnZXN0ICE9PSB1bmRlZmluZWQgJiZcbiAgICAgIChvYmouZGlnZXN0ID0gYmFzZTY0RnJvbUJ5dGVzKFxuICAgICAgICBtZXNzYWdlLmRpZ2VzdCAhPT0gdW5kZWZpbmVkID8gbWVzc2FnZS5kaWdlc3QgOiBuZXcgVWludDhBcnJheSgpXG4gICAgICApKTtcbiAgICBtZXNzYWdlLnJlY2VpdmVkVGltZSAhPT0gdW5kZWZpbmVkICYmXG4gICAgICAob2JqLnJlY2VpdmVkVGltZSA9IG1lc3NhZ2UucmVjZWl2ZWRUaW1lKTtcbiAgICBtZXNzYWdlLnNlbmRlclRpbWUgIT09IHVuZGVmaW5lZCAmJiAob2JqLnNlbmRlclRpbWUgPSBtZXNzYWdlLnNlbmRlclRpbWUpO1xuICAgIHJldHVybiBvYmo7XG4gIH0sXG5cbiAgZnJvbVBhcnRpYWwob2JqZWN0OiBEZWVwUGFydGlhbDxJbmRleD4pOiBJbmRleCB7XG4gICAgY29uc3QgbWVzc2FnZSA9IHsgLi4uYmFzZUluZGV4IH0gYXMgSW5kZXg7XG4gICAgaWYgKG9iamVjdC5kaWdlc3QgIT09IHVuZGVmaW5lZCAmJiBvYmplY3QuZGlnZXN0ICE9PSBudWxsKSB7XG4gICAgICBtZXNzYWdlLmRpZ2VzdCA9IG9iamVjdC5kaWdlc3Q7XG4gICAgfSBlbHNlIHtcbiAgICAgIG1lc3NhZ2UuZGlnZXN0ID0gbmV3IFVpbnQ4QXJyYXkoKTtcbiAgICB9XG4gICAgaWYgKG9iamVjdC5yZWNlaXZlZFRpbWUgIT09IHVuZGVmaW5lZCAmJiBvYmplY3QucmVjZWl2ZWRUaW1lICE9PSBudWxsKSB7XG4gICAgICBtZXNzYWdlLnJlY2VpdmVkVGltZSA9IG9iamVjdC5yZWNlaXZlZFRpbWU7XG4gICAgfSBlbHNlIHtcbiAgICAgIG1lc3NhZ2UucmVjZWl2ZWRUaW1lID0gMDtcbiAgICB9XG4gICAgaWYgKG9iamVjdC5zZW5kZXJUaW1lICE9PSB1bmRlZmluZWQgJiYgb2JqZWN0LnNlbmRlclRpbWUgIT09IG51bGwpIHtcbiAgICAgIG1lc3NhZ2Uuc2VuZGVyVGltZSA9IG9iamVjdC5zZW5kZXJUaW1lO1xuICAgIH0gZWxzZSB7XG4gICAgICBtZXNzYWdlLnNlbmRlclRpbWUgPSAwO1xuICAgIH1cbiAgICByZXR1cm4gbWVzc2FnZTtcbiAgfSxcbn07XG5cbmNvbnN0IGJhc2VQYWdpbmdJbmZvOiBvYmplY3QgPSB7IHBhZ2VTaXplOiAwLCBkaXJlY3Rpb246IDAgfTtcblxuZXhwb3J0IGNvbnN0IFBhZ2luZ0luZm8gPSB7XG4gIGVuY29kZShcbiAgICBtZXNzYWdlOiBQYWdpbmdJbmZvLFxuICAgIHdyaXRlcjogX20wLldyaXRlciA9IF9tMC5Xcml0ZXIuY3JlYXRlKClcbiAgKTogX20wLldyaXRlciB7XG4gICAgaWYgKG1lc3NhZ2UucGFnZVNpemUgIT09IDApIHtcbiAgICAgIHdyaXRlci51aW50MzIoOCkudWludDY0KG1lc3NhZ2UucGFnZVNpemUpO1xuICAgIH1cbiAgICBpZiAobWVzc2FnZS5jdXJzb3IgIT09IHVuZGVmaW5lZCkge1xuICAgICAgSW5kZXguZW5jb2RlKG1lc3NhZ2UuY3Vyc29yLCB3cml0ZXIudWludDMyKDE4KS5mb3JrKCkpLmxkZWxpbSgpO1xuICAgIH1cbiAgICBpZiAobWVzc2FnZS5kaXJlY3Rpb24gIT09IDApIHtcbiAgICAgIHdyaXRlci51aW50MzIoMjQpLmludDMyKG1lc3NhZ2UuZGlyZWN0aW9uKTtcbiAgICB9XG4gICAgcmV0dXJuIHdyaXRlcjtcbiAgfSxcblxuICBkZWNvZGUoaW5wdXQ6IF9tMC5SZWFkZXIgfCBVaW50OEFycmF5LCBsZW5ndGg/OiBudW1iZXIpOiBQYWdpbmdJbmZvIHtcbiAgICBjb25zdCByZWFkZXIgPSBpbnB1dCBpbnN0YW5jZW9mIF9tMC5SZWFkZXIgPyBpbnB1dCA6IG5ldyBfbTAuUmVhZGVyKGlucHV0KTtcbiAgICBsZXQgZW5kID0gbGVuZ3RoID09PSB1bmRlZmluZWQgPyByZWFkZXIubGVuIDogcmVhZGVyLnBvcyArIGxlbmd0aDtcbiAgICBjb25zdCBtZXNzYWdlID0geyAuLi5iYXNlUGFnaW5nSW5mbyB9IGFzIFBhZ2luZ0luZm87XG4gICAgd2hpbGUgKHJlYWRlci5wb3MgPCBlbmQpIHtcbiAgICAgIGNvbnN0IHRhZyA9IHJlYWRlci51aW50MzIoKTtcbiAgICAgIHN3aXRjaCAodGFnID4+PiAzKSB7XG4gICAgICAgIGNhc2UgMTpcbiAgICAgICAgICBtZXNzYWdlLnBhZ2VTaXplID0gbG9uZ1RvTnVtYmVyKHJlYWRlci51aW50NjQoKSBhcyBMb25nKTtcbiAgICAgICAgICBicmVhaztcbiAgICAgICAgY2FzZSAyOlxuICAgICAgICAgIG1lc3NhZ2UuY3Vyc29yID0gSW5kZXguZGVjb2RlKHJlYWRlciwgcmVhZGVyLnVpbnQzMigpKTtcbiAgICAgICAgICBicmVhaztcbiAgICAgICAgY2FzZSAzOlxuICAgICAgICAgIG1lc3NhZ2UuZGlyZWN0aW9uID0gcmVhZGVyLmludDMyKCkgYXMgYW55O1xuICAgICAgICAgIGJyZWFrO1xuICAgICAgICBkZWZhdWx0OlxuICAgICAgICAgIHJlYWRlci5za2lwVHlwZSh0YWcgJiA3KTtcbiAgICAgICAgICBicmVhaztcbiAgICAgIH1cbiAgICB9XG4gICAgcmV0dXJuIG1lc3NhZ2U7XG4gIH0sXG5cbiAgZnJvbUpTT04ob2JqZWN0OiBhbnkpOiBQYWdpbmdJbmZvIHtcbiAgICBjb25zdCBtZXNzYWdlID0geyAuLi5iYXNlUGFnaW5nSW5mbyB9IGFzIFBhZ2luZ0luZm87XG4gICAgaWYgKG9iamVjdC5wYWdlU2l6ZSAhPT0gdW5kZWZpbmVkICYmIG9iamVjdC5wYWdlU2l6ZSAhPT0gbnVsbCkge1xuICAgICAgbWVzc2FnZS5wYWdlU2l6ZSA9IE51bWJlcihvYmplY3QucGFnZVNpemUpO1xuICAgIH0gZWxzZSB7XG4gICAgICBtZXNzYWdlLnBhZ2VTaXplID0gMDtcbiAgICB9XG4gICAgaWYgKG9iamVjdC5jdXJzb3IgIT09IHVuZGVmaW5lZCAmJiBvYmplY3QuY3Vyc29yICE9PSBudWxsKSB7XG4gICAgICBtZXNzYWdlLmN1cnNvciA9IEluZGV4LmZyb21KU09OKG9iamVjdC5jdXJzb3IpO1xuICAgIH0gZWxzZSB7XG4gICAgICBtZXNzYWdlLmN1cnNvciA9IHVuZGVmaW5lZDtcbiAgICB9XG4gICAgaWYgKG9iamVjdC5kaXJlY3Rpb24gIT09IHVuZGVmaW5lZCAmJiBvYmplY3QuZGlyZWN0aW9uICE9PSBudWxsKSB7XG4gICAgICBtZXNzYWdlLmRpcmVjdGlvbiA9IHBhZ2luZ0luZm9fRGlyZWN0aW9uRnJvbUpTT04ob2JqZWN0LmRpcmVjdGlvbik7XG4gICAgfSBlbHNlIHtcbiAgICAgIG1lc3NhZ2UuZGlyZWN0aW9uID0gMDtcbiAgICB9XG4gICAgcmV0dXJuIG1lc3NhZ2U7XG4gIH0sXG5cbiAgdG9KU09OKG1lc3NhZ2U6IFBhZ2luZ0luZm8pOiB1bmtub3duIHtcbiAgICBjb25zdCBvYmo6IGFueSA9IHt9O1xuICAgIG1lc3NhZ2UucGFnZVNpemUgIT09IHVuZGVmaW5lZCAmJiAob2JqLnBhZ2VTaXplID0gbWVzc2FnZS5wYWdlU2l6ZSk7XG4gICAgbWVzc2FnZS5jdXJzb3IgIT09IHVuZGVmaW5lZCAmJlxuICAgICAgKG9iai5jdXJzb3IgPSBtZXNzYWdlLmN1cnNvciA/IEluZGV4LnRvSlNPTihtZXNzYWdlLmN1cnNvcikgOiB1bmRlZmluZWQpO1xuICAgIG1lc3NhZ2UuZGlyZWN0aW9uICE9PSB1bmRlZmluZWQgJiZcbiAgICAgIChvYmouZGlyZWN0aW9uID0gcGFnaW5nSW5mb19EaXJlY3Rpb25Ub0pTT04obWVzc2FnZS5kaXJlY3Rpb24pKTtcbiAgICByZXR1cm4gb2JqO1xuICB9LFxuXG4gIGZyb21QYXJ0aWFsKG9iamVjdDogRGVlcFBhcnRpYWw8UGFnaW5nSW5mbz4pOiBQYWdpbmdJbmZvIHtcbiAgICBjb25zdCBtZXNzYWdlID0geyAuLi5iYXNlUGFnaW5nSW5mbyB9IGFzIFBhZ2luZ0luZm87XG4gICAgaWYgKG9iamVjdC5wYWdlU2l6ZSAhPT0gdW5kZWZpbmVkICYmIG9iamVjdC5wYWdlU2l6ZSAhPT0gbnVsbCkge1xuICAgICAgbWVzc2FnZS5wYWdlU2l6ZSA9IG9iamVjdC5wYWdlU2l6ZTtcbiAgICB9IGVsc2Uge1xuICAgICAgbWVzc2FnZS5wYWdlU2l6ZSA9IDA7XG4gICAgfVxuICAgIGlmIChvYmplY3QuY3Vyc29yICE9PSB1bmRlZmluZWQgJiYgb2JqZWN0LmN1cnNvciAhPT0gbnVsbCkge1xuICAgICAgbWVzc2FnZS5jdXJzb3IgPSBJbmRleC5mcm9tUGFydGlhbChvYmplY3QuY3Vyc29yKTtcbiAgICB9IGVsc2Uge1xuICAgICAgbWVzc2FnZS5jdXJzb3IgPSB1bmRlZmluZWQ7XG4gICAgfVxuICAgIGlmIChvYmplY3QuZGlyZWN0aW9uICE9PSB1bmRlZmluZWQgJiYgb2JqZWN0LmRpcmVjdGlvbiAhPT0gbnVsbCkge1xuICAgICAgbWVzc2FnZS5kaXJlY3Rpb24gPSBvYmplY3QuZGlyZWN0aW9uO1xuICAgIH0gZWxzZSB7XG4gICAgICBtZXNzYWdlLmRpcmVjdGlvbiA9IDA7XG4gICAgfVxuICAgIHJldHVybiBtZXNzYWdlO1xuICB9LFxufTtcblxuY29uc3QgYmFzZUNvbnRlbnRGaWx0ZXI6IG9iamVjdCA9IHsgY29udGVudFRvcGljOiAnJyB9O1xuXG5leHBvcnQgY29uc3QgQ29udGVudEZpbHRlciA9IHtcbiAgZW5jb2RlKFxuICAgIG1lc3NhZ2U6IENvbnRlbnRGaWx0ZXIsXG4gICAgd3JpdGVyOiBfbTAuV3JpdGVyID0gX20wLldyaXRlci5jcmVhdGUoKVxuICApOiBfbTAuV3JpdGVyIHtcbiAgICBpZiAobWVzc2FnZS5jb250ZW50VG9waWMgIT09ICcnKSB7XG4gICAgICB3cml0ZXIudWludDMyKDEwKS5zdHJpbmcobWVzc2FnZS5jb250ZW50VG9waWMpO1xuICAgIH1cbiAgICByZXR1cm4gd3JpdGVyO1xuICB9LFxuXG4gIGRlY29kZShpbnB1dDogX20wLlJlYWRlciB8IFVpbnQ4QXJyYXksIGxlbmd0aD86IG51bWJlcik6IENvbnRlbnRGaWx0ZXIge1xuICAgIGNvbnN0IHJlYWRlciA9IGlucHV0IGluc3RhbmNlb2YgX20wLlJlYWRlciA/IGlucHV0IDogbmV3IF9tMC5SZWFkZXIoaW5wdXQpO1xuICAgIGxldCBlbmQgPSBsZW5ndGggPT09IHVuZGVmaW5lZCA/IHJlYWRlci5sZW4gOiByZWFkZXIucG9zICsgbGVuZ3RoO1xuICAgIGNvbnN0IG1lc3NhZ2UgPSB7IC4uLmJhc2VDb250ZW50RmlsdGVyIH0gYXMgQ29udGVudEZpbHRlcjtcbiAgICB3aGlsZSAocmVhZGVyLnBvcyA8IGVuZCkge1xuICAgICAgY29uc3QgdGFnID0gcmVhZGVyLnVpbnQzMigpO1xuICAgICAgc3dpdGNoICh0YWcgPj4+IDMpIHtcbiAgICAgICAgY2FzZSAxOlxuICAgICAgICAgIG1lc3NhZ2UuY29udGVudFRvcGljID0gcmVhZGVyLnN0cmluZygpO1xuICAgICAgICAgIGJyZWFrO1xuICAgICAgICBkZWZhdWx0OlxuICAgICAgICAgIHJlYWRlci5za2lwVHlwZSh0YWcgJiA3KTtcbiAgICAgICAgICBicmVhaztcbiAgICAgIH1cbiAgICB9XG4gICAgcmV0dXJuIG1lc3NhZ2U7XG4gIH0sXG5cbiAgZnJvbUpTT04ob2JqZWN0OiBhbnkpOiBDb250ZW50RmlsdGVyIHtcbiAgICBjb25zdCBtZXNzYWdlID0geyAuLi5iYXNlQ29udGVudEZpbHRlciB9IGFzIENvbnRlbnRGaWx0ZXI7XG4gICAgaWYgKG9iamVjdC5jb250ZW50VG9waWMgIT09IHVuZGVmaW5lZCAmJiBvYmplY3QuY29udGVudFRvcGljICE9PSBudWxsKSB7XG4gICAgICBtZXNzYWdlLmNvbnRlbnRUb3BpYyA9IFN0cmluZyhvYmplY3QuY29udGVudFRvcGljKTtcbiAgICB9IGVsc2Uge1xuICAgICAgbWVzc2FnZS5jb250ZW50VG9waWMgPSAnJztcbiAgICB9XG4gICAgcmV0dXJuIG1lc3NhZ2U7XG4gIH0sXG5cbiAgdG9KU09OKG1lc3NhZ2U6IENvbnRlbnRGaWx0ZXIpOiB1bmtub3duIHtcbiAgICBjb25zdCBvYmo6IGFueSA9IHt9O1xuICAgIG1lc3NhZ2UuY29udGVudFRvcGljICE9PSB1bmRlZmluZWQgJiZcbiAgICAgIChvYmouY29udGVudFRvcGljID0gbWVzc2FnZS5jb250ZW50VG9waWMpO1xuICAgIHJldHVybiBvYmo7XG4gIH0sXG5cbiAgZnJvbVBhcnRpYWwob2JqZWN0OiBEZWVwUGFydGlhbDxDb250ZW50RmlsdGVyPik6IENvbnRlbnRGaWx0ZXIge1xuICAgIGNvbnN0IG1lc3NhZ2UgPSB7IC4uLmJhc2VDb250ZW50RmlsdGVyIH0gYXMgQ29udGVudEZpbHRlcjtcbiAgICBpZiAob2JqZWN0LmNvbnRlbnRUb3BpYyAhPT0gdW5kZWZpbmVkICYmIG9iamVjdC5jb250ZW50VG9waWMgIT09IG51bGwpIHtcbiAgICAgIG1lc3NhZ2UuY29udGVudFRvcGljID0gb2JqZWN0LmNvbnRlbnRUb3BpYztcbiAgICB9IGVsc2Uge1xuICAgICAgbWVzc2FnZS5jb250ZW50VG9waWMgPSAnJztcbiAgICB9XG4gICAgcmV0dXJuIG1lc3NhZ2U7XG4gIH0sXG59O1xuXG5jb25zdCBiYXNlSGlzdG9yeVF1ZXJ5OiBvYmplY3QgPSB7fTtcblxuZXhwb3J0IGNvbnN0IEhpc3RvcnlRdWVyeSA9IHtcbiAgZW5jb2RlKFxuICAgIG1lc3NhZ2U6IEhpc3RvcnlRdWVyeSxcbiAgICB3cml0ZXI6IF9tMC5Xcml0ZXIgPSBfbTAuV3JpdGVyLmNyZWF0ZSgpXG4gICk6IF9tMC5Xcml0ZXIge1xuICAgIGlmIChtZXNzYWdlLnB1YlN1YlRvcGljICE9PSB1bmRlZmluZWQpIHtcbiAgICAgIHdyaXRlci51aW50MzIoMTgpLnN0cmluZyhtZXNzYWdlLnB1YlN1YlRvcGljKTtcbiAgICB9XG4gICAgZm9yIChjb25zdCB2IG9mIG1lc3NhZ2UuY29udGVudEZpbHRlcnMpIHtcbiAgICAgIENvbnRlbnRGaWx0ZXIuZW5jb2RlKHYhLCB3cml0ZXIudWludDMyKDI2KS5mb3JrKCkpLmxkZWxpbSgpO1xuICAgIH1cbiAgICBpZiAobWVzc2FnZS5wYWdpbmdJbmZvICE9PSB1bmRlZmluZWQpIHtcbiAgICAgIFBhZ2luZ0luZm8uZW5jb2RlKG1lc3NhZ2UucGFnaW5nSW5mbywgd3JpdGVyLnVpbnQzMigzNCkuZm9yaygpKS5sZGVsaW0oKTtcbiAgICB9XG4gICAgaWYgKG1lc3NhZ2Uuc3RhcnRUaW1lICE9PSB1bmRlZmluZWQpIHtcbiAgICAgIHdyaXRlci51aW50MzIoNDEpLmRvdWJsZShtZXNzYWdlLnN0YXJ0VGltZSk7XG4gICAgfVxuICAgIGlmIChtZXNzYWdlLmVuZFRpbWUgIT09IHVuZGVmaW5lZCkge1xuICAgICAgd3JpdGVyLnVpbnQzMig0OSkuZG91YmxlKG1lc3NhZ2UuZW5kVGltZSk7XG4gICAgfVxuICAgIHJldHVybiB3cml0ZXI7XG4gIH0sXG5cbiAgZGVjb2RlKGlucHV0OiBfbTAuUmVhZGVyIHwgVWludDhBcnJheSwgbGVuZ3RoPzogbnVtYmVyKTogSGlzdG9yeVF1ZXJ5IHtcbiAgICBjb25zdCByZWFkZXIgPSBpbnB1dCBpbnN0YW5jZW9mIF9tMC5SZWFkZXIgPyBpbnB1dCA6IG5ldyBfbTAuUmVhZGVyKGlucHV0KTtcbiAgICBsZXQgZW5kID0gbGVuZ3RoID09PSB1bmRlZmluZWQgPyByZWFkZXIubGVuIDogcmVhZGVyLnBvcyArIGxlbmd0aDtcbiAgICBjb25zdCBtZXNzYWdlID0geyAuLi5iYXNlSGlzdG9yeVF1ZXJ5IH0gYXMgSGlzdG9yeVF1ZXJ5O1xuICAgIG1lc3NhZ2UuY29udGVudEZpbHRlcnMgPSBbXTtcbiAgICB3aGlsZSAocmVhZGVyLnBvcyA8IGVuZCkge1xuICAgICAgY29uc3QgdGFnID0gcmVhZGVyLnVpbnQzMigpO1xuICAgICAgc3dpdGNoICh0YWcgPj4+IDMpIHtcbiAgICAgICAgY2FzZSAyOlxuICAgICAgICAgIG1lc3NhZ2UucHViU3ViVG9waWMgPSByZWFkZXIuc3RyaW5nKCk7XG4gICAgICAgICAgYnJlYWs7XG4gICAgICAgIGNhc2UgMzpcbiAgICAgICAgICBtZXNzYWdlLmNvbnRlbnRGaWx0ZXJzLnB1c2goXG4gICAgICAgICAgICBDb250ZW50RmlsdGVyLmRlY29kZShyZWFkZXIsIHJlYWRlci51aW50MzIoKSlcbiAgICAgICAgICApO1xuICAgICAgICAgIGJyZWFrO1xuICAgICAgICBjYXNlIDQ6XG4gICAgICAgICAgbWVzc2FnZS5wYWdpbmdJbmZvID0gUGFnaW5nSW5mby5kZWNvZGUocmVhZGVyLCByZWFkZXIudWludDMyKCkpO1xuICAgICAgICAgIGJyZWFrO1xuICAgICAgICBjYXNlIDU6XG4gICAgICAgICAgbWVzc2FnZS5zdGFydFRpbWUgPSByZWFkZXIuZG91YmxlKCk7XG4gICAgICAgICAgYnJlYWs7XG4gICAgICAgIGNhc2UgNjpcbiAgICAgICAgICBtZXNzYWdlLmVuZFRpbWUgPSByZWFkZXIuZG91YmxlKCk7XG4gICAgICAgICAgYnJlYWs7XG4gICAgICAgIGRlZmF1bHQ6XG4gICAgICAgICAgcmVhZGVyLnNraXBUeXBlKHRhZyAmIDcpO1xuICAgICAgICAgIGJyZWFrO1xuICAgICAgfVxuICAgIH1cbiAgICByZXR1cm4gbWVzc2FnZTtcbiAgfSxcblxuICBmcm9tSlNPTihvYmplY3Q6IGFueSk6IEhpc3RvcnlRdWVyeSB7XG4gICAgY29uc3QgbWVzc2FnZSA9IHsgLi4uYmFzZUhpc3RvcnlRdWVyeSB9IGFzIEhpc3RvcnlRdWVyeTtcbiAgICBtZXNzYWdlLmNvbnRlbnRGaWx0ZXJzID0gW107XG4gICAgaWYgKG9iamVjdC5wdWJTdWJUb3BpYyAhPT0gdW5kZWZpbmVkICYmIG9iamVjdC5wdWJTdWJUb3BpYyAhPT0gbnVsbCkge1xuICAgICAgbWVzc2FnZS5wdWJTdWJUb3BpYyA9IFN0cmluZyhvYmplY3QucHViU3ViVG9waWMpO1xuICAgIH0gZWxzZSB7XG4gICAgICBtZXNzYWdlLnB1YlN1YlRvcGljID0gdW5kZWZpbmVkO1xuICAgIH1cbiAgICBpZiAob2JqZWN0LmNvbnRlbnRGaWx0ZXJzICE9PSB1bmRlZmluZWQgJiYgb2JqZWN0LmNvbnRlbnRGaWx0ZXJzICE9PSBudWxsKSB7XG4gICAgICBmb3IgKGNvbnN0IGUgb2Ygb2JqZWN0LmNvbnRlbnRGaWx0ZXJzKSB7XG4gICAgICAgIG1lc3NhZ2UuY29udGVudEZpbHRlcnMucHVzaChDb250ZW50RmlsdGVyLmZyb21KU09OKGUpKTtcbiAgICAgIH1cbiAgICB9XG4gICAgaWYgKG9iamVjdC5wYWdpbmdJbmZvICE9PSB1bmRlZmluZWQgJiYgb2JqZWN0LnBhZ2luZ0luZm8gIT09IG51bGwpIHtcbiAgICAgIG1lc3NhZ2UucGFnaW5nSW5mbyA9IFBhZ2luZ0luZm8uZnJvbUpTT04ob2JqZWN0LnBhZ2luZ0luZm8pO1xuICAgIH0gZWxzZSB7XG4gICAgICBtZXNzYWdlLnBhZ2luZ0luZm8gPSB1bmRlZmluZWQ7XG4gICAgfVxuICAgIGlmIChvYmplY3Quc3RhcnRUaW1lICE9PSB1bmRlZmluZWQgJiYgb2JqZWN0LnN0YXJ0VGltZSAhPT0gbnVsbCkge1xuICAgICAgbWVzc2FnZS5zdGFydFRpbWUgPSBOdW1iZXIob2JqZWN0LnN0YXJ0VGltZSk7XG4gICAgfSBlbHNlIHtcbiAgICAgIG1lc3NhZ2Uuc3RhcnRUaW1lID0gdW5kZWZpbmVkO1xuICAgIH1cbiAgICBpZiAob2JqZWN0LmVuZFRpbWUgIT09IHVuZGVmaW5lZCAmJiBvYmplY3QuZW5kVGltZSAhPT0gbnVsbCkge1xuICAgICAgbWVzc2FnZS5lbmRUaW1lID0gTnVtYmVyKG9iamVjdC5lbmRUaW1lKTtcbiAgICB9IGVsc2Uge1xuICAgICAgbWVzc2FnZS5lbmRUaW1lID0gdW5kZWZpbmVkO1xuICAgIH1cbiAgICByZXR1cm4gbWVzc2FnZTtcbiAgfSxcblxuICB0b0pTT04obWVzc2FnZTogSGlzdG9yeVF1ZXJ5KTogdW5rbm93biB7XG4gICAgY29uc3Qgb2JqOiBhbnkgPSB7fTtcbiAgICBtZXNzYWdlLnB1YlN1YlRvcGljICE9PSB1bmRlZmluZWQgJiZcbiAgICAgIChvYmoucHViU3ViVG9waWMgPSBtZXNzYWdlLnB1YlN1YlRvcGljKTtcbiAgICBpZiAobWVzc2FnZS5jb250ZW50RmlsdGVycykge1xuICAgICAgb2JqLmNvbnRlbnRGaWx0ZXJzID0gbWVzc2FnZS5jb250ZW50RmlsdGVycy5tYXAoKGUpID0+XG4gICAgICAgIGUgPyBDb250ZW50RmlsdGVyLnRvSlNPTihlKSA6IHVuZGVmaW5lZFxuICAgICAgKTtcbiAgICB9IGVsc2Uge1xuICAgICAgb2JqLmNvbnRlbnRGaWx0ZXJzID0gW107XG4gICAgfVxuICAgIG1lc3NhZ2UucGFnaW5nSW5mbyAhPT0gdW5kZWZpbmVkICYmXG4gICAgICAob2JqLnBhZ2luZ0luZm8gPSBtZXNzYWdlLnBhZ2luZ0luZm9cbiAgICAgICAgPyBQYWdpbmdJbmZvLnRvSlNPTihtZXNzYWdlLnBhZ2luZ0luZm8pXG4gICAgICAgIDogdW5kZWZpbmVkKTtcbiAgICBtZXNzYWdlLnN0YXJ0VGltZSAhPT0gdW5kZWZpbmVkICYmIChvYmouc3RhcnRUaW1lID0gbWVzc2FnZS5zdGFydFRpbWUpO1xuICAgIG1lc3NhZ2UuZW5kVGltZSAhPT0gdW5kZWZpbmVkICYmIChvYmouZW5kVGltZSA9IG1lc3NhZ2UuZW5kVGltZSk7XG4gICAgcmV0dXJuIG9iajtcbiAgfSxcblxuICBmcm9tUGFydGlhbChvYmplY3Q6IERlZXBQYXJ0aWFsPEhpc3RvcnlRdWVyeT4pOiBIaXN0b3J5UXVlcnkge1xuICAgIGNvbnN0IG1lc3NhZ2UgPSB7IC4uLmJhc2VIaXN0b3J5UXVlcnkgfSBhcyBIaXN0b3J5UXVlcnk7XG4gICAgbWVzc2FnZS5jb250ZW50RmlsdGVycyA9IFtdO1xuICAgIGlmIChvYmplY3QucHViU3ViVG9waWMgIT09IHVuZGVmaW5lZCAmJiBvYmplY3QucHViU3ViVG9waWMgIT09IG51bGwpIHtcbiAgICAgIG1lc3NhZ2UucHViU3ViVG9waWMgPSBvYmplY3QucHViU3ViVG9waWM7XG4gICAgfSBlbHNlIHtcbiAgICAgIG1lc3NhZ2UucHViU3ViVG9waWMgPSB1bmRlZmluZWQ7XG4gICAgfVxuICAgIGlmIChvYmplY3QuY29udGVudEZpbHRlcnMgIT09IHVuZGVmaW5lZCAmJiBvYmplY3QuY29udGVudEZpbHRlcnMgIT09IG51bGwpIHtcbiAgICAgIGZvciAoY29uc3QgZSBvZiBvYmplY3QuY29udGVudEZpbHRlcnMpIHtcbiAgICAgICAgbWVzc2FnZS5jb250ZW50RmlsdGVycy5wdXNoKENvbnRlbnRGaWx0ZXIuZnJvbVBhcnRpYWwoZSkpO1xuICAgICAgfVxuICAgIH1cbiAgICBpZiAob2JqZWN0LnBhZ2luZ0luZm8gIT09IHVuZGVmaW5lZCAmJiBvYmplY3QucGFnaW5nSW5mbyAhPT0gbnVsbCkge1xuICAgICAgbWVzc2FnZS5wYWdpbmdJbmZvID0gUGFnaW5nSW5mby5mcm9tUGFydGlhbChvYmplY3QucGFnaW5nSW5mbyk7XG4gICAgfSBlbHNlIHtcbiAgICAgIG1lc3NhZ2UucGFnaW5nSW5mbyA9IHVuZGVmaW5lZDtcbiAgICB9XG4gICAgaWYgKG9iamVjdC5zdGFydFRpbWUgIT09IHVuZGVmaW5lZCAmJiBvYmplY3Quc3RhcnRUaW1lICE9PSBudWxsKSB7XG4gICAgICBtZXNzYWdlLnN0YXJ0VGltZSA9IG9iamVjdC5zdGFydFRpbWU7XG4gICAgfSBlbHNlIHtcbiAgICAgIG1lc3NhZ2Uuc3RhcnRUaW1lID0gdW5kZWZpbmVkO1xuICAgIH1cbiAgICBpZiAob2JqZWN0LmVuZFRpbWUgIT09IHVuZGVmaW5lZCAmJiBvYmplY3QuZW5kVGltZSAhPT0gbnVsbCkge1xuICAgICAgbWVzc2FnZS5lbmRUaW1lID0gb2JqZWN0LmVuZFRpbWU7XG4gICAgfSBlbHNlIHtcbiAgICAgIG1lc3NhZ2UuZW5kVGltZSA9IHVuZGVmaW5lZDtcbiAgICB9XG4gICAgcmV0dXJuIG1lc3NhZ2U7XG4gIH0sXG59O1xuXG5jb25zdCBiYXNlSGlzdG9yeVJlc3BvbnNlOiBvYmplY3QgPSB7IGVycm9yOiAwIH07XG5cbmV4cG9ydCBjb25zdCBIaXN0b3J5UmVzcG9uc2UgPSB7XG4gIGVuY29kZShcbiAgICBtZXNzYWdlOiBIaXN0b3J5UmVzcG9uc2UsXG4gICAgd3JpdGVyOiBfbTAuV3JpdGVyID0gX20wLldyaXRlci5jcmVhdGUoKVxuICApOiBfbTAuV3JpdGVyIHtcbiAgICBmb3IgKGNvbnN0IHYgb2YgbWVzc2FnZS5tZXNzYWdlcykge1xuICAgICAgV2FrdU1lc3NhZ2UuZW5jb2RlKHYhLCB3cml0ZXIudWludDMyKDE4KS5mb3JrKCkpLmxkZWxpbSgpO1xuICAgIH1cbiAgICBpZiAobWVzc2FnZS5wYWdpbmdJbmZvICE9PSB1bmRlZmluZWQpIHtcbiAgICAgIFBhZ2luZ0luZm8uZW5jb2RlKG1lc3NhZ2UucGFnaW5nSW5mbywgd3JpdGVyLnVpbnQzMigyNikuZm9yaygpKS5sZGVsaW0oKTtcbiAgICB9XG4gICAgaWYgKG1lc3NhZ2UuZXJyb3IgIT09IDApIHtcbiAgICAgIHdyaXRlci51aW50MzIoMzIpLmludDMyKG1lc3NhZ2UuZXJyb3IpO1xuICAgIH1cbiAgICByZXR1cm4gd3JpdGVyO1xuICB9LFxuXG4gIGRlY29kZShpbnB1dDogX20wLlJlYWRlciB8IFVpbnQ4QXJyYXksIGxlbmd0aD86IG51bWJlcik6IEhpc3RvcnlSZXNwb25zZSB7XG4gICAgY29uc3QgcmVhZGVyID0gaW5wdXQgaW5zdGFuY2VvZiBfbTAuUmVhZGVyID8gaW5wdXQgOiBuZXcgX20wLlJlYWRlcihpbnB1dCk7XG4gICAgbGV0IGVuZCA9IGxlbmd0aCA9PT0gdW5kZWZpbmVkID8gcmVhZGVyLmxlbiA6IHJlYWRlci5wb3MgKyBsZW5ndGg7XG4gICAgY29uc3QgbWVzc2FnZSA9IHsgLi4uYmFzZUhpc3RvcnlSZXNwb25zZSB9IGFzIEhpc3RvcnlSZXNwb25zZTtcbiAgICBtZXNzYWdlLm1lc3NhZ2VzID0gW107XG4gICAgd2hpbGUgKHJlYWRlci5wb3MgPCBlbmQpIHtcbiAgICAgIGNvbnN0IHRhZyA9IHJlYWRlci51aW50MzIoKTtcbiAgICAgIHN3aXRjaCAodGFnID4+PiAzKSB7XG4gICAgICAgIGNhc2UgMjpcbiAgICAgICAgICBtZXNzYWdlLm1lc3NhZ2VzLnB1c2goV2FrdU1lc3NhZ2UuZGVjb2RlKHJlYWRlciwgcmVhZGVyLnVpbnQzMigpKSk7XG4gICAgICAgICAgYnJlYWs7XG4gICAgICAgIGNhc2UgMzpcbiAgICAgICAgICBtZXNzYWdlLnBhZ2luZ0luZm8gPSBQYWdpbmdJbmZvLmRlY29kZShyZWFkZXIsIHJlYWRlci51aW50MzIoKSk7XG4gICAgICAgICAgYnJlYWs7XG4gICAgICAgIGNhc2UgNDpcbiAgICAgICAgICBtZXNzYWdlLmVycm9yID0gcmVhZGVyLmludDMyKCkgYXMgYW55O1xuICAgICAgICAgIGJyZWFrO1xuICAgICAgICBkZWZhdWx0OlxuICAgICAgICAgIHJlYWRlci5za2lwVHlwZSh0YWcgJiA3KTtcbiAgICAgICAgICBicmVhaztcbiAgICAgIH1cbiAgICB9XG4gICAgcmV0dXJuIG1lc3NhZ2U7XG4gIH0sXG5cbiAgZnJvbUpTT04ob2JqZWN0OiBhbnkpOiBIaXN0b3J5UmVzcG9uc2Uge1xuICAgIGNvbnN0IG1lc3NhZ2UgPSB7IC4uLmJhc2VIaXN0b3J5UmVzcG9uc2UgfSBhcyBIaXN0b3J5UmVzcG9uc2U7XG4gICAgbWVzc2FnZS5tZXNzYWdlcyA9IFtdO1xuICAgIGlmIChvYmplY3QubWVzc2FnZXMgIT09IHVuZGVmaW5lZCAmJiBvYmplY3QubWVzc2FnZXMgIT09IG51bGwpIHtcbiAgICAgIGZvciAoY29uc3QgZSBvZiBvYmplY3QubWVzc2FnZXMpIHtcbiAgICAgICAgbWVzc2FnZS5tZXNzYWdlcy5wdXNoKFdha3VNZXNzYWdlLmZyb21KU09OKGUpKTtcbiAgICAgIH1cbiAgICB9XG4gICAgaWYgKG9iamVjdC5wYWdpbmdJbmZvICE9PSB1bmRlZmluZWQgJiYgb2JqZWN0LnBhZ2luZ0luZm8gIT09IG51bGwpIHtcbiAgICAgIG1lc3NhZ2UucGFnaW5nSW5mbyA9IFBhZ2luZ0luZm8uZnJvbUpTT04ob2JqZWN0LnBhZ2luZ0luZm8pO1xuICAgIH0gZWxzZSB7XG4gICAgICBtZXNzYWdlLnBhZ2luZ0luZm8gPSB1bmRlZmluZWQ7XG4gICAgfVxuICAgIGlmIChvYmplY3QuZXJyb3IgIT09IHVuZGVmaW5lZCAmJiBvYmplY3QuZXJyb3IgIT09IG51bGwpIHtcbiAgICAgIG1lc3NhZ2UuZXJyb3IgPSBoaXN0b3J5UmVzcG9uc2VfRXJyb3JGcm9tSlNPTihvYmplY3QuZXJyb3IpO1xuICAgIH0gZWxzZSB7XG4gICAgICBtZXNzYWdlLmVycm9yID0gMDtcbiAgICB9XG4gICAgcmV0dXJuIG1lc3NhZ2U7XG4gIH0sXG5cbiAgdG9KU09OKG1lc3NhZ2U6IEhpc3RvcnlSZXNwb25zZSk6IHVua25vd24ge1xuICAgIGNvbnN0IG9iajogYW55ID0ge307XG4gICAgaWYgKG1lc3NhZ2UubWVzc2FnZXMpIHtcbiAgICAgIG9iai5tZXNzYWdlcyA9IG1lc3NhZ2UubWVzc2FnZXMubWFwKChlKSA9PlxuICAgICAgICBlID8gV2FrdU1lc3NhZ2UudG9KU09OKGUpIDogdW5kZWZpbmVkXG4gICAgICApO1xuICAgIH0gZWxzZSB7XG4gICAgICBvYmoubWVzc2FnZXMgPSBbXTtcbiAgICB9XG4gICAgbWVzc2FnZS5wYWdpbmdJbmZvICE9PSB1bmRlZmluZWQgJiZcbiAgICAgIChvYmoucGFnaW5nSW5mbyA9IG1lc3NhZ2UucGFnaW5nSW5mb1xuICAgICAgICA/IFBhZ2luZ0luZm8udG9KU09OKG1lc3NhZ2UucGFnaW5nSW5mbylcbiAgICAgICAgOiB1bmRlZmluZWQpO1xuICAgIG1lc3NhZ2UuZXJyb3IgIT09IHVuZGVmaW5lZCAmJlxuICAgICAgKG9iai5lcnJvciA9IGhpc3RvcnlSZXNwb25zZV9FcnJvclRvSlNPTihtZXNzYWdlLmVycm9yKSk7XG4gICAgcmV0dXJuIG9iajtcbiAgfSxcblxuICBmcm9tUGFydGlhbChvYmplY3Q6IERlZXBQYXJ0aWFsPEhpc3RvcnlSZXNwb25zZT4pOiBIaXN0b3J5UmVzcG9uc2Uge1xuICAgIGNvbnN0IG1lc3NhZ2UgPSB7IC4uLmJhc2VIaXN0b3J5UmVzcG9uc2UgfSBhcyBIaXN0b3J5UmVzcG9uc2U7XG4gICAgbWVzc2FnZS5tZXNzYWdlcyA9IFtdO1xuICAgIGlmIChvYmplY3QubWVzc2FnZXMgIT09IHVuZGVmaW5lZCAmJiBvYmplY3QubWVzc2FnZXMgIT09IG51bGwpIHtcbiAgICAgIGZvciAoY29uc3QgZSBvZiBvYmplY3QubWVzc2FnZXMpIHtcbiAgICAgICAgbWVzc2FnZS5tZXNzYWdlcy5wdXNoKFdha3VNZXNzYWdlLmZyb21QYXJ0aWFsKGUpKTtcbiAgICAgIH1cbiAgICB9XG4gICAgaWYgKG9iamVjdC5wYWdpbmdJbmZvICE9PSB1bmRlZmluZWQgJiYgb2JqZWN0LnBhZ2luZ0luZm8gIT09IG51bGwpIHtcbiAgICAgIG1lc3NhZ2UucGFnaW5nSW5mbyA9IFBhZ2luZ0luZm8uZnJvbVBhcnRpYWwob2JqZWN0LnBhZ2luZ0luZm8pO1xuICAgIH0gZWxzZSB7XG4gICAgICBtZXNzYWdlLnBhZ2luZ0luZm8gPSB1bmRlZmluZWQ7XG4gICAgfVxuICAgIGlmIChvYmplY3QuZXJyb3IgIT09IHVuZGVmaW5lZCAmJiBvYmplY3QuZXJyb3IgIT09IG51bGwpIHtcbiAgICAgIG1lc3NhZ2UuZXJyb3IgPSBvYmplY3QuZXJyb3I7XG4gICAgfSBlbHNlIHtcbiAgICAgIG1lc3NhZ2UuZXJyb3IgPSAwO1xuICAgIH1cbiAgICByZXR1cm4gbWVzc2FnZTtcbiAgfSxcbn07XG5cbmNvbnN0IGJhc2VIaXN0b3J5UlBDOiBvYmplY3QgPSB7IHJlcXVlc3RJZDogJycgfTtcblxuZXhwb3J0IGNvbnN0IEhpc3RvcnlSUEMgPSB7XG4gIGVuY29kZShcbiAgICBtZXNzYWdlOiBIaXN0b3J5UlBDLFxuICAgIHdyaXRlcjogX20wLldyaXRlciA9IF9tMC5Xcml0ZXIuY3JlYXRlKClcbiAgKTogX20wLldyaXRlciB7XG4gICAgaWYgKG1lc3NhZ2UucmVxdWVzdElkICE9PSAnJykge1xuICAgICAgd3JpdGVyLnVpbnQzMigxMCkuc3RyaW5nKG1lc3NhZ2UucmVxdWVzdElkKTtcbiAgICB9XG4gICAgaWYgKG1lc3NhZ2UucXVlcnkgIT09IHVuZGVmaW5lZCkge1xuICAgICAgSGlzdG9yeVF1ZXJ5LmVuY29kZShtZXNzYWdlLnF1ZXJ5LCB3cml0ZXIudWludDMyKDE4KS5mb3JrKCkpLmxkZWxpbSgpO1xuICAgIH1cbiAgICBpZiAobWVzc2FnZS5yZXNwb25zZSAhPT0gdW5kZWZpbmVkKSB7XG4gICAgICBIaXN0b3J5UmVzcG9uc2UuZW5jb2RlKFxuICAgICAgICBtZXNzYWdlLnJlc3BvbnNlLFxuICAgICAgICB3cml0ZXIudWludDMyKDI2KS5mb3JrKClcbiAgICAgICkubGRlbGltKCk7XG4gICAgfVxuICAgIHJldHVybiB3cml0ZXI7XG4gIH0sXG5cbiAgZGVjb2RlKGlucHV0OiBfbTAuUmVhZGVyIHwgVWludDhBcnJheSwgbGVuZ3RoPzogbnVtYmVyKTogSGlzdG9yeVJQQyB7XG4gICAgY29uc3QgcmVhZGVyID0gaW5wdXQgaW5zdGFuY2VvZiBfbTAuUmVhZGVyID8gaW5wdXQgOiBuZXcgX20wLlJlYWRlcihpbnB1dCk7XG4gICAgbGV0IGVuZCA9IGxlbmd0aCA9PT0gdW5kZWZpbmVkID8gcmVhZGVyLmxlbiA6IHJlYWRlci5wb3MgKyBsZW5ndGg7XG4gICAgY29uc3QgbWVzc2FnZSA9IHsgLi4uYmFzZUhpc3RvcnlSUEMgfSBhcyBIaXN0b3J5UlBDO1xuICAgIHdoaWxlIChyZWFkZXIucG9zIDwgZW5kKSB7XG4gICAgICBjb25zdCB0YWcgPSByZWFkZXIudWludDMyKCk7XG4gICAgICBzd2l0Y2ggKHRhZyA+Pj4gMykge1xuICAgICAgICBjYXNlIDE6XG4gICAgICAgICAgbWVzc2FnZS5yZXF1ZXN0SWQgPSByZWFkZXIuc3RyaW5nKCk7XG4gICAgICAgICAgYnJlYWs7XG4gICAgICAgIGNhc2UgMjpcbiAgICAgICAgICBtZXNzYWdlLnF1ZXJ5ID0gSGlzdG9yeVF1ZXJ5LmRlY29kZShyZWFkZXIsIHJlYWRlci51aW50MzIoKSk7XG4gICAgICAgICAgYnJlYWs7XG4gICAgICAgIGNhc2UgMzpcbiAgICAgICAgICBtZXNzYWdlLnJlc3BvbnNlID0gSGlzdG9yeVJlc3BvbnNlLmRlY29kZShyZWFkZXIsIHJlYWRlci51aW50MzIoKSk7XG4gICAgICAgICAgYnJlYWs7XG4gICAgICAgIGRlZmF1bHQ6XG4gICAgICAgICAgcmVhZGVyLnNraXBUeXBlKHRhZyAmIDcpO1xuICAgICAgICAgIGJyZWFrO1xuICAgICAgfVxuICAgIH1cbiAgICByZXR1cm4gbWVzc2FnZTtcbiAgfSxcblxuICBmcm9tSlNPTihvYmplY3Q6IGFueSk6IEhpc3RvcnlSUEMge1xuICAgIGNvbnN0IG1lc3NhZ2UgPSB7IC4uLmJhc2VIaXN0b3J5UlBDIH0gYXMgSGlzdG9yeVJQQztcbiAgICBpZiAob2JqZWN0LnJlcXVlc3RJZCAhPT0gdW5kZWZpbmVkICYmIG9iamVjdC5yZXF1ZXN0SWQgIT09IG51bGwpIHtcbiAgICAgIG1lc3NhZ2UucmVxdWVzdElkID0gU3RyaW5nKG9iamVjdC5yZXF1ZXN0SWQpO1xuICAgIH0gZWxzZSB7XG4gICAgICBtZXNzYWdlLnJlcXVlc3RJZCA9ICcnO1xuICAgIH1cbiAgICBpZiAob2JqZWN0LnF1ZXJ5ICE9PSB1bmRlZmluZWQgJiYgb2JqZWN0LnF1ZXJ5ICE9PSBudWxsKSB7XG4gICAgICBtZXNzYWdlLnF1ZXJ5ID0gSGlzdG9yeVF1ZXJ5LmZyb21KU09OKG9iamVjdC5xdWVyeSk7XG4gICAgfSBlbHNlIHtcbiAgICAgIG1lc3NhZ2UucXVlcnkgPSB1bmRlZmluZWQ7XG4gICAgfVxuICAgIGlmIChvYmplY3QucmVzcG9uc2UgIT09IHVuZGVmaW5lZCAmJiBvYmplY3QucmVzcG9uc2UgIT09IG51bGwpIHtcbiAgICAgIG1lc3NhZ2UucmVzcG9uc2UgPSBIaXN0b3J5UmVzcG9uc2UuZnJvbUpTT04ob2JqZWN0LnJlc3BvbnNlKTtcbiAgICB9IGVsc2Uge1xuICAgICAgbWVzc2FnZS5yZXNwb25zZSA9IHVuZGVmaW5lZDtcbiAgICB9XG4gICAgcmV0dXJuIG1lc3NhZ2U7XG4gIH0sXG5cbiAgdG9KU09OKG1lc3NhZ2U6IEhpc3RvcnlSUEMpOiB1bmtub3duIHtcbiAgICBjb25zdCBvYmo6IGFueSA9IHt9O1xuICAgIG1lc3NhZ2UucmVxdWVzdElkICE9PSB1bmRlZmluZWQgJiYgKG9iai5yZXF1ZXN0SWQgPSBtZXNzYWdlLnJlcXVlc3RJZCk7XG4gICAgbWVzc2FnZS5xdWVyeSAhPT0gdW5kZWZpbmVkICYmXG4gICAgICAob2JqLnF1ZXJ5ID0gbWVzc2FnZS5xdWVyeVxuICAgICAgICA/IEhpc3RvcnlRdWVyeS50b0pTT04obWVzc2FnZS5xdWVyeSlcbiAgICAgICAgOiB1bmRlZmluZWQpO1xuICAgIG1lc3NhZ2UucmVzcG9uc2UgIT09IHVuZGVmaW5lZCAmJlxuICAgICAgKG9iai5yZXNwb25zZSA9IG1lc3NhZ2UucmVzcG9uc2VcbiAgICAgICAgPyBIaXN0b3J5UmVzcG9uc2UudG9KU09OKG1lc3NhZ2UucmVzcG9uc2UpXG4gICAgICAgIDogdW5kZWZpbmVkKTtcbiAgICByZXR1cm4gb2JqO1xuICB9LFxuXG4gIGZyb21QYXJ0aWFsKG9iamVjdDogRGVlcFBhcnRpYWw8SGlzdG9yeVJQQz4pOiBIaXN0b3J5UlBDIHtcbiAgICBjb25zdCBtZXNzYWdlID0geyAuLi5iYXNlSGlzdG9yeVJQQyB9IGFzIEhpc3RvcnlSUEM7XG4gICAgaWYgKG9iamVjdC5yZXF1ZXN0SWQgIT09IHVuZGVmaW5lZCAmJiBvYmplY3QucmVxdWVzdElkICE9PSBudWxsKSB7XG4gICAgICBtZXNzYWdlLnJlcXVlc3RJZCA9IG9iamVjdC5yZXF1ZXN0SWQ7XG4gICAgfSBlbHNlIHtcbiAgICAgIG1lc3NhZ2UucmVxdWVzdElkID0gJyc7XG4gICAgfVxuICAgIGlmIChvYmplY3QucXVlcnkgIT09IHVuZGVmaW5lZCAmJiBvYmplY3QucXVlcnkgIT09IG51bGwpIHtcbiAgICAgIG1lc3NhZ2UucXVlcnkgPSBIaXN0b3J5UXVlcnkuZnJvbVBhcnRpYWwob2JqZWN0LnF1ZXJ5KTtcbiAgICB9IGVsc2Uge1xuICAgICAgbWVzc2FnZS5xdWVyeSA9IHVuZGVmaW5lZDtcbiAgICB9XG4gICAgaWYgKG9iamVjdC5yZXNwb25zZSAhPT0gdW5kZWZpbmVkICYmIG9iamVjdC5yZXNwb25zZSAhPT0gbnVsbCkge1xuICAgICAgbWVzc2FnZS5yZXNwb25zZSA9IEhpc3RvcnlSZXNwb25zZS5mcm9tUGFydGlhbChvYmplY3QucmVzcG9uc2UpO1xuICAgIH0gZWxzZSB7XG4gICAgICBtZXNzYWdlLnJlc3BvbnNlID0gdW5kZWZpbmVkO1xuICAgIH1cbiAgICByZXR1cm4gbWVzc2FnZTtcbiAgfSxcbn07XG5cbmRlY2xhcmUgdmFyIHNlbGY6IGFueSB8IHVuZGVmaW5lZDtcbmRlY2xhcmUgdmFyIHdpbmRvdzogYW55IHwgdW5kZWZpbmVkO1xudmFyIGdsb2JhbFRoaXM6IGFueSA9ICgoKSA9PiB7XG4gIGlmICh0eXBlb2YgZ2xvYmFsVGhpcyAhPT0gJ3VuZGVmaW5lZCcpIHJldHVybiBnbG9iYWxUaGlzO1xuICBpZiAodHlwZW9mIHNlbGYgIT09ICd1bmRlZmluZWQnKSByZXR1cm4gc2VsZjtcbiAgaWYgKHR5cGVvZiB3aW5kb3cgIT09ICd1bmRlZmluZWQnKSByZXR1cm4gd2luZG93O1xuICBpZiAodHlwZW9mIGdsb2JhbCAhPT0gJ3VuZGVmaW5lZCcpIHJldHVybiBnbG9iYWw7XG4gIHRocm93ICdVbmFibGUgdG8gbG9jYXRlIGdsb2JhbCBvYmplY3QnO1xufSkoKTtcblxuY29uc3QgYXRvYjogKGI2NDogc3RyaW5nKSA9PiBzdHJpbmcgPVxuICBnbG9iYWxUaGlzLmF0b2IgfHxcbiAgKChiNjQpID0+IGdsb2JhbFRoaXMuQnVmZmVyLmZyb20oYjY0LCAnYmFzZTY0JykudG9TdHJpbmcoJ2JpbmFyeScpKTtcbmZ1bmN0aW9uIGJ5dGVzRnJvbUJhc2U2NChiNjQ6IHN0cmluZyk6IFVpbnQ4QXJyYXkge1xuICBjb25zdCBiaW4gPSBhdG9iKGI2NCk7XG4gIGNvbnN0IGFyciA9IG5ldyBVaW50OEFycmF5KGJpbi5sZW5ndGgpO1xuICBmb3IgKGxldCBpID0gMDsgaSA8IGJpbi5sZW5ndGg7ICsraSkge1xuICAgIGFycltpXSA9IGJpbi5jaGFyQ29kZUF0KGkpO1xuICB9XG4gIHJldHVybiBhcnI7XG59XG5cbmNvbnN0IGJ0b2E6IChiaW46IHN0cmluZykgPT4gc3RyaW5nID1cbiAgZ2xvYmFsVGhpcy5idG9hIHx8XG4gICgoYmluKSA9PiBnbG9iYWxUaGlzLkJ1ZmZlci5mcm9tKGJpbiwgJ2JpbmFyeScpLnRvU3RyaW5nKCdiYXNlNjQnKSk7XG5mdW5jdGlvbiBiYXNlNjRGcm9tQnl0ZXMoYXJyOiBVaW50OEFycmF5KTogc3RyaW5nIHtcbiAgY29uc3QgYmluOiBzdHJpbmdbXSA9IFtdO1xuICBmb3IgKGNvbnN0IGJ5dGUgb2YgYXJyKSB7XG4gICAgYmluLnB1c2goU3RyaW5nLmZyb21DaGFyQ29kZShieXRlKSk7XG4gIH1cbiAgcmV0dXJuIGJ0b2EoYmluLmpvaW4oJycpKTtcbn1cblxudHlwZSBCdWlsdGluID1cbiAgfCBEYXRlXG4gIHwgRnVuY3Rpb25cbiAgfCBVaW50OEFycmF5XG4gIHwgc3RyaW5nXG4gIHwgbnVtYmVyXG4gIHwgYm9vbGVhblxuICB8IHVuZGVmaW5lZDtcbmV4cG9ydCB0eXBlIERlZXBQYXJ0aWFsPFQ+ID0gVCBleHRlbmRzIEJ1aWx0aW5cbiAgPyBUXG4gIDogVCBleHRlbmRzIEFycmF5PGluZmVyIFU+XG4gID8gQXJyYXk8RGVlcFBhcnRpYWw8VT4+XG4gIDogVCBleHRlbmRzIFJlYWRvbmx5QXJyYXk8aW5mZXIgVT5cbiAgPyBSZWFkb25seUFycmF5PERlZXBQYXJ0aWFsPFU+PlxuICA6IFQgZXh0ZW5kcyB7fVxuICA/IHsgW0sgaW4ga2V5b2YgVF0/OiBEZWVwUGFydGlhbDxUW0tdPiB9XG4gIDogUGFydGlhbDxUPjtcblxuZnVuY3Rpb24gbG9uZ1RvTnVtYmVyKGxvbmc6IExvbmcpOiBudW1iZXIge1xuICBpZiAobG9uZy5ndChOdW1iZXIuTUFYX1NBRkVfSU5URUdFUikpIHtcbiAgICB0aHJvdyBuZXcgZ2xvYmFsVGhpcy5FcnJvcignVmFsdWUgaXMgbGFyZ2VyIHRoYW4gTnVtYmVyLk1BWF9TQUZFX0lOVEVHRVInKTtcbiAgfVxuICByZXR1cm4gbG9uZy50b051bWJlcigpO1xufVxuXG5pZiAoX20wLnV0aWwuTG9uZyAhPT0gTG9uZykge1xuICBfbTAudXRpbC5Mb25nID0gTG9uZyBhcyBhbnk7XG4gIF9tMC5jb25maWd1cmUoKTtcbn1cbiIsIi8qIChpZ25vcmVkKSAqLyIsIi8qIChpZ25vcmVkKSAqLyIsIi8qIChpZ25vcmVkKSAqLyIsIi8qIChpZ25vcmVkKSAqLyIsIi8qIChpZ25vcmVkKSAqLyIsIi8qIChpZ25vcmVkKSAqLyIsIi8qIChpZ25vcmVkKSAqLyIsIi8qIChpZ25vcmVkKSAqLyIsIi8qIChpZ25vcmVkKSAqLyIsIi8qIChpZ25vcmVkKSAqLyIsIi8qIChpZ25vcmVkKSAqLyIsIi8qIChpZ25vcmVkKSAqLyIsIi8vIFRoZSBtb2R1bGUgY2FjaGVcbnZhciBfX3dlYnBhY2tfbW9kdWxlX2NhY2hlX18gPSB7fTtcblxuLy8gVGhlIHJlcXVpcmUgZnVuY3Rpb25cbmZ1bmN0aW9uIF9fd2VicGFja19yZXF1aXJlX18obW9kdWxlSWQpIHtcblx0Ly8gQ2hlY2sgaWYgbW9kdWxlIGlzIGluIGNhY2hlXG5cdHZhciBjYWNoZWRNb2R1bGUgPSBfX3dlYnBhY2tfbW9kdWxlX2NhY2hlX19bbW9kdWxlSWRdO1xuXHRpZiAoY2FjaGVkTW9kdWxlICE9PSB1bmRlZmluZWQpIHtcblx0XHRyZXR1cm4gY2FjaGVkTW9kdWxlLmV4cG9ydHM7XG5cdH1cblx0Ly8gQ3JlYXRlIGEgbmV3IG1vZHVsZSAoYW5kIHB1dCBpdCBpbnRvIHRoZSBjYWNoZSlcblx0dmFyIG1vZHVsZSA9IF9fd2VicGFja19tb2R1bGVfY2FjaGVfX1ttb2R1bGVJZF0gPSB7XG5cdFx0aWQ6IG1vZHVsZUlkLFxuXHRcdGxvYWRlZDogZmFsc2UsXG5cdFx0ZXhwb3J0czoge31cblx0fTtcblxuXHQvLyBFeGVjdXRlIHRoZSBtb2R1bGUgZnVuY3Rpb25cblx0X193ZWJwYWNrX21vZHVsZXNfX1ttb2R1bGVJZF0uY2FsbChtb2R1bGUuZXhwb3J0cywgbW9kdWxlLCBtb2R1bGUuZXhwb3J0cywgX193ZWJwYWNrX3JlcXVpcmVfXyk7XG5cblx0Ly8gRmxhZyB0aGUgbW9kdWxlIGFzIGxvYWRlZFxuXHRtb2R1bGUubG9hZGVkID0gdHJ1ZTtcblxuXHQvLyBSZXR1cm4gdGhlIGV4cG9ydHMgb2YgdGhlIG1vZHVsZVxuXHRyZXR1cm4gbW9kdWxlLmV4cG9ydHM7XG59XG5cbi8vIGV4cG9zZSB0aGUgbW9kdWxlcyBvYmplY3QgKF9fd2VicGFja19tb2R1bGVzX18pXG5fX3dlYnBhY2tfcmVxdWlyZV9fLm0gPSBfX3dlYnBhY2tfbW9kdWxlc19fO1xuXG4iLCJfX3dlYnBhY2tfcmVxdWlyZV9fLmFtZE8gPSB7fTsiLCJ2YXIgZGVmZXJyZWQgPSBbXTtcbl9fd2VicGFja19yZXF1aXJlX18uTyA9IChyZXN1bHQsIGNodW5rSWRzLCBmbiwgcHJpb3JpdHkpID0+IHtcblx0aWYoY2h1bmtJZHMpIHtcblx0XHRwcmlvcml0eSA9IHByaW9yaXR5IHx8IDA7XG5cdFx0Zm9yKHZhciBpID0gZGVmZXJyZWQubGVuZ3RoOyBpID4gMCAmJiBkZWZlcnJlZFtpIC0gMV1bMl0gPiBwcmlvcml0eTsgaS0tKSBkZWZlcnJlZFtpXSA9IGRlZmVycmVkW2kgLSAxXTtcblx0XHRkZWZlcnJlZFtpXSA9IFtjaHVua0lkcywgZm4sIHByaW9yaXR5XTtcblx0XHRyZXR1cm47XG5cdH1cblx0dmFyIG5vdEZ1bGZpbGxlZCA9IEluZmluaXR5O1xuXHRmb3IgKHZhciBpID0gMDsgaSA8IGRlZmVycmVkLmxlbmd0aDsgaSsrKSB7XG5cdFx0dmFyIFtjaHVua0lkcywgZm4sIHByaW9yaXR5XSA9IGRlZmVycmVkW2ldO1xuXHRcdHZhciBmdWxmaWxsZWQgPSB0cnVlO1xuXHRcdGZvciAodmFyIGogPSAwOyBqIDwgY2h1bmtJZHMubGVuZ3RoOyBqKyspIHtcblx0XHRcdGlmICgocHJpb3JpdHkgJiAxID09PSAwIHx8IG5vdEZ1bGZpbGxlZCA+PSBwcmlvcml0eSkgJiYgT2JqZWN0LmtleXMoX193ZWJwYWNrX3JlcXVpcmVfXy5PKS5ldmVyeSgoa2V5KSA9PiAoX193ZWJwYWNrX3JlcXVpcmVfXy5PW2tleV0oY2h1bmtJZHNbal0pKSkpIHtcblx0XHRcdFx0Y2h1bmtJZHMuc3BsaWNlKGotLSwgMSk7XG5cdFx0XHR9IGVsc2Uge1xuXHRcdFx0XHRmdWxmaWxsZWQgPSBmYWxzZTtcblx0XHRcdFx0aWYocHJpb3JpdHkgPCBub3RGdWxmaWxsZWQpIG5vdEZ1bGZpbGxlZCA9IHByaW9yaXR5O1xuXHRcdFx0fVxuXHRcdH1cblx0XHRpZihmdWxmaWxsZWQpIHtcblx0XHRcdGRlZmVycmVkLnNwbGljZShpLS0sIDEpXG5cdFx0XHR2YXIgciA9IGZuKCk7XG5cdFx0XHRpZiAociAhPT0gdW5kZWZpbmVkKSByZXN1bHQgPSByO1xuXHRcdH1cblx0fVxuXHRyZXR1cm4gcmVzdWx0O1xufTsiLCIvLyBkZWZpbmUgZ2V0dGVyIGZ1bmN0aW9ucyBmb3IgaGFybW9ueSBleHBvcnRzXG5fX3dlYnBhY2tfcmVxdWlyZV9fLmQgPSAoZXhwb3J0cywgZGVmaW5pdGlvbikgPT4ge1xuXHRmb3IodmFyIGtleSBpbiBkZWZpbml0aW9uKSB7XG5cdFx0aWYoX193ZWJwYWNrX3JlcXVpcmVfXy5vKGRlZmluaXRpb24sIGtleSkgJiYgIV9fd2VicGFja19yZXF1aXJlX18ubyhleHBvcnRzLCBrZXkpKSB7XG5cdFx0XHRPYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywga2V5LCB7IGVudW1lcmFibGU6IHRydWUsIGdldDogZGVmaW5pdGlvbltrZXldIH0pO1xuXHRcdH1cblx0fVxufTsiLCJfX3dlYnBhY2tfcmVxdWlyZV9fLmcgPSAoZnVuY3Rpb24oKSB7XG5cdGlmICh0eXBlb2YgZ2xvYmFsVGhpcyA9PT0gJ29iamVjdCcpIHJldHVybiBnbG9iYWxUaGlzO1xuXHR0cnkge1xuXHRcdHJldHVybiB0aGlzIHx8IG5ldyBGdW5jdGlvbigncmV0dXJuIHRoaXMnKSgpO1xuXHR9IGNhdGNoIChlKSB7XG5cdFx0aWYgKHR5cGVvZiB3aW5kb3cgPT09ICdvYmplY3QnKSByZXR1cm4gd2luZG93O1xuXHR9XG59KSgpOyIsIl9fd2VicGFja19yZXF1aXJlX18ubyA9IChvYmosIHByb3ApID0+IChPYmplY3QucHJvdG90eXBlLmhhc093blByb3BlcnR5LmNhbGwob2JqLCBwcm9wKSkiLCIvLyBkZWZpbmUgX19lc01vZHVsZSBvbiBleHBvcnRzXG5fX3dlYnBhY2tfcmVxdWlyZV9fLnIgPSAoZXhwb3J0cykgPT4ge1xuXHRpZih0eXBlb2YgU3ltYm9sICE9PSAndW5kZWZpbmVkJyAmJiBTeW1ib2wudG9TdHJpbmdUYWcpIHtcblx0XHRPYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgU3ltYm9sLnRvU3RyaW5nVGFnLCB7IHZhbHVlOiAnTW9kdWxlJyB9KTtcblx0fVxuXHRPYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgJ19fZXNNb2R1bGUnLCB7IHZhbHVlOiB0cnVlIH0pO1xufTsiLCJfX3dlYnBhY2tfcmVxdWlyZV9fLm5tZCA9IChtb2R1bGUpID0+IHtcblx0bW9kdWxlLnBhdGhzID0gW107XG5cdGlmICghbW9kdWxlLmNoaWxkcmVuKSBtb2R1bGUuY2hpbGRyZW4gPSBbXTtcblx0cmV0dXJuIG1vZHVsZTtcbn07IiwiLy8gbm8gYmFzZVVSSVxuXG4vLyBvYmplY3QgdG8gc3RvcmUgbG9hZGVkIGFuZCBsb2FkaW5nIGNodW5rc1xuLy8gdW5kZWZpbmVkID0gY2h1bmsgbm90IGxvYWRlZCwgbnVsbCA9IGNodW5rIHByZWxvYWRlZC9wcmVmZXRjaGVkXG4vLyBbcmVzb2x2ZSwgcmVqZWN0LCBQcm9taXNlXSA9IGNodW5rIGxvYWRpbmcsIDAgPSBjaHVuayBsb2FkZWRcbnZhciBpbnN0YWxsZWRDaHVua3MgPSB7XG5cdFwianMtd2FrdVwiOiAwXG59O1xuXG4vLyBubyBjaHVuayBvbiBkZW1hbmQgbG9hZGluZ1xuXG4vLyBubyBwcmVmZXRjaGluZ1xuXG4vLyBubyBwcmVsb2FkZWRcblxuLy8gbm8gSE1SXG5cbi8vIG5vIEhNUiBtYW5pZmVzdFxuXG5fX3dlYnBhY2tfcmVxdWlyZV9fLk8uaiA9IChjaHVua0lkKSA9PiAoaW5zdGFsbGVkQ2h1bmtzW2NodW5rSWRdID09PSAwKTtcblxuLy8gaW5zdGFsbCBhIEpTT05QIGNhbGxiYWNrIGZvciBjaHVuayBsb2FkaW5nXG52YXIgd2VicGFja0pzb25wQ2FsbGJhY2sgPSAocGFyZW50Q2h1bmtMb2FkaW5nRnVuY3Rpb24sIGRhdGEpID0+IHtcblx0dmFyIFtjaHVua0lkcywgbW9yZU1vZHVsZXMsIHJ1bnRpbWVdID0gZGF0YTtcblx0Ly8gYWRkIFwibW9yZU1vZHVsZXNcIiB0byB0aGUgbW9kdWxlcyBvYmplY3QsXG5cdC8vIHRoZW4gZmxhZyBhbGwgXCJjaHVua0lkc1wiIGFzIGxvYWRlZCBhbmQgZmlyZSBjYWxsYmFja1xuXHR2YXIgbW9kdWxlSWQsIGNodW5rSWQsIGkgPSAwO1xuXHRpZihjaHVua0lkcy5zb21lKChpZCkgPT4gKGluc3RhbGxlZENodW5rc1tpZF0gIT09IDApKSkge1xuXHRcdGZvcihtb2R1bGVJZCBpbiBtb3JlTW9kdWxlcykge1xuXHRcdFx0aWYoX193ZWJwYWNrX3JlcXVpcmVfXy5vKG1vcmVNb2R1bGVzLCBtb2R1bGVJZCkpIHtcblx0XHRcdFx0X193ZWJwYWNrX3JlcXVpcmVfXy5tW21vZHVsZUlkXSA9IG1vcmVNb2R1bGVzW21vZHVsZUlkXTtcblx0XHRcdH1cblx0XHR9XG5cdFx0aWYocnVudGltZSkgdmFyIHJlc3VsdCA9IHJ1bnRpbWUoX193ZWJwYWNrX3JlcXVpcmVfXyk7XG5cdH1cblx0aWYocGFyZW50Q2h1bmtMb2FkaW5nRnVuY3Rpb24pIHBhcmVudENodW5rTG9hZGluZ0Z1bmN0aW9uKGRhdGEpO1xuXHRmb3IoO2kgPCBjaHVua0lkcy5sZW5ndGg7IGkrKykge1xuXHRcdGNodW5rSWQgPSBjaHVua0lkc1tpXTtcblx0XHRpZihfX3dlYnBhY2tfcmVxdWlyZV9fLm8oaW5zdGFsbGVkQ2h1bmtzLCBjaHVua0lkKSAmJiBpbnN0YWxsZWRDaHVua3NbY2h1bmtJZF0pIHtcblx0XHRcdGluc3RhbGxlZENodW5rc1tjaHVua0lkXVswXSgpO1xuXHRcdH1cblx0XHRpbnN0YWxsZWRDaHVua3NbY2h1bmtJZHNbaV1dID0gMDtcblx0fVxuXHRyZXR1cm4gX193ZWJwYWNrX3JlcXVpcmVfXy5PKHJlc3VsdCk7XG59XG5cbnZhciBjaHVua0xvYWRpbmdHbG9iYWwgPSB0aGlzW1wid2VicGFja0NodW5ranN3YWt1XCJdID0gdGhpc1tcIndlYnBhY2tDaHVua2pzd2FrdVwiXSB8fCBbXTtcbmNodW5rTG9hZGluZ0dsb2JhbC5mb3JFYWNoKHdlYnBhY2tKc29ucENhbGxiYWNrLmJpbmQobnVsbCwgMCkpO1xuY2h1bmtMb2FkaW5nR2xvYmFsLnB1c2ggPSB3ZWJwYWNrSnNvbnBDYWxsYmFjay5iaW5kKG51bGwsIGNodW5rTG9hZGluZ0dsb2JhbC5wdXNoLmJpbmQoY2h1bmtMb2FkaW5nR2xvYmFsKSk7IiwiIiwiLy8gc3RhcnR1cFxuLy8gTG9hZCBlbnRyeSBtb2R1bGUgYW5kIHJldHVybiBleHBvcnRzXG4vLyBUaGlzIGVudHJ5IG1vZHVsZSBkZXBlbmRzIG9uIG90aGVyIGxvYWRlZCBjaHVua3MgYW5kIGV4ZWN1dGlvbiBuZWVkIHRvIGJlIGRlbGF5ZWRcbnZhciBfX3dlYnBhY2tfZXhwb3J0c19fID0gX193ZWJwYWNrX3JlcXVpcmVfXy5PKHVuZGVmaW5lZCwgW1widmVuZG9yc1wiXSwgKCkgPT4gKF9fd2VicGFja19yZXF1aXJlX18oXCIuL3NyYy9pbmRleC50c1wiKSkpXG5fX3dlYnBhY2tfZXhwb3J0c19fID0gX193ZWJwYWNrX3JlcXVpcmVfXy5PKF9fd2VicGFja19leHBvcnRzX18pO1xuIiwiIl0sIm5hbWVzIjpbXSwic291cmNlUm9vdCI6IiJ9