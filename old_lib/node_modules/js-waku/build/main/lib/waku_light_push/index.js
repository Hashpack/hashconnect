"use strict";
var __importDefault = (this && this.__importDefault) || function (mod) {
    return (mod && mod.__esModule) ? mod : { "default": mod };
};
Object.defineProperty(exports, "__esModule", { value: true });
exports.WakuLightPush = exports.PushResponse = exports.LightPushCodec = void 0;
const it_concat_1 = __importDefault(require("it-concat"));
const it_length_prefixed_1 = __importDefault(require("it-length-prefixed"));
const it_pipe_1 = __importDefault(require("it-pipe"));
const light_push_1 = require("../../proto/waku/v2/light_push");
Object.defineProperty(exports, "PushResponse", { enumerable: true, get: function () { return light_push_1.PushResponse; } });
const select_peer_1 = require("../select_peer");
const waku_1 = require("../waku");
const push_rpc_1 = require("./push_rpc");
exports.LightPushCodec = '/vac/waku/lightpush/2.0.0-beta1';
/**
 * Implements the [Waku v2 Light Push protocol](https://rfc.vac.dev/spec/19/).
 */
class WakuLightPush {
    constructor(libp2p, options) {
        this.libp2p = libp2p;
        if (options === null || options === void 0 ? void 0 : options.pubSubTopic) {
            this.pubSubTopic = options.pubSubTopic;
        }
        else {
            this.pubSubTopic = waku_1.DefaultPubSubTopic;
        }
    }
    async push(message, opts) {
        let peer;
        if (opts === null || opts === void 0 ? void 0 : opts.peerId) {
            peer = this.libp2p.peerStore.get(opts.peerId);
            if (!peer)
                throw 'Peer is unknown';
        }
        else {
            peer = this.randomPeer;
        }
        if (!peer)
            throw 'No peer available';
        if (!peer.protocols.includes(exports.LightPushCodec))
            throw 'Peer does not register waku light push protocol';
        const connection = this.libp2p.connectionManager.get(peer.id);
        if (!connection)
            throw 'Failed to get a connection to the peer';
        const { stream } = await connection.newStream(exports.LightPushCodec);
        try {
            const pubSubTopic = (opts === null || opts === void 0 ? void 0 : opts.pubSubTopic)
                ? opts.pubSubTopic
                : this.pubSubTopic;
            const query = push_rpc_1.PushRPC.createRequest(message, pubSubTopic);
            const res = await it_pipe_1.default([query.encode()], it_length_prefixed_1.default.encode(), stream, it_length_prefixed_1.default.decode(), it_concat_1.default);
            try {
                const response = push_rpc_1.PushRPC.decode(res.slice()).response;
                if (!response) {
                    console.log('No response in PushRPC');
                    return null;
                }
                return response;
            }
            catch (err) {
                console.log('Failed to decode push reply', err);
            }
        }
        catch (err) {
            console.log('Failed to send waku light push request', err);
        }
        return null;
    }
    /**
     * Returns known peers from the address book (`libp2p.peerStore`) that support
     * light push protocol. Waku may or  may not be currently connected to these peers.
     */
    get peers() {
        return select_peer_1.getPeersForProtocol(this.libp2p, exports.LightPushCodec);
    }
    /**
     * Returns a random peer that supports light push protocol from the address
     * book (`libp2p.peerStore`). Waku may or  may not be currently connected to
     * this peer.
     */
    get randomPeer() {
        return select_peer_1.selectRandomPeer(this.peers);
    }
}
exports.WakuLightPush = WakuLightPush;
//# sourceMappingURL=index.js.map