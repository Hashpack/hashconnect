var __awaiter = (this && this.__awaiter) || function (thisArg, _arguments, P, generator) {
    function adopt(value) { return value instanceof P ? value : new P(function (resolve) { resolve(value); }); }
    return new (P || (P = Promise))(function (resolve, reject) {
        function fulfilled(value) { try { step(generator.next(value)); } catch (e) { reject(e); } }
        function rejected(value) { try { step(generator["throw"](value)); } catch (e) { reject(e); } }
        function step(result) { result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected); }
        step((generator = generator.apply(thisArg, _arguments || [])).next());
    });
};
var __generator = (this && this.__generator) || function (thisArg, body) {
    var _ = { label: 0, sent: function() { if (t[0] & 1) throw t[1]; return t[1]; }, trys: [], ops: [] }, f, y, t, g;
    return g = { next: verb(0), "throw": verb(1), "return": verb(2) }, typeof Symbol === "function" && (g[Symbol.iterator] = function() { return this; }), g;
    function verb(n) { return function (v) { return step([n, v]); }; }
    function step(op) {
        if (f) throw new TypeError("Generator is already executing.");
        while (_) try {
            if (f = 1, y && (t = op[0] & 2 ? y["return"] : op[0] ? y["throw"] || ((t = y["return"]) && t.call(y), 0) : y.next) && !(t = t.call(y, op[1])).done) return t;
            if (y = 0, t) op = [op[0] & 2, t.value];
            switch (op[0]) {
                case 0: case 1: t = op; break;
                case 4: _.label++; return { value: op[1], done: false };
                case 5: _.label++; y = op[1]; op = [0]; continue;
                case 7: op = _.ops.pop(); _.trys.pop(); continue;
                default:
                    if (!(t = _.trys, t = t.length > 0 && t[t.length - 1]) && (op[0] === 6 || op[0] === 2)) { _ = 0; continue; }
                    if (op[0] === 3 && (!t || (op[1] > t[0] && op[1] < t[3]))) { _.label = op[1]; break; }
                    if (op[0] === 6 && _.label < t[1]) { _.label = t[1]; t = op; break; }
                    if (t && _.label < t[2]) { _.label = t[2]; _.ops.push(op); break; }
                    if (t[2]) _.ops.pop();
                    _.trys.pop(); continue;
            }
            op = body.call(thisArg, _);
        } catch (e) { op = [6, e]; y = 0; } finally { f = t = 0; }
        if (op[0] & 5) throw op[1]; return { value: op[0] ? op[1] : void 0, done: true };
    }
};
import { Noise } from '@chainsafe/libp2p-noise/dist/src/noise';
import debug from 'debug';
import Libp2p from 'libp2p';
import Bootstrap from 'libp2p-bootstrap';
// eslint-disable-next-line @typescript-eslint/ban-ts-comment
// @ts-ignore: No types available
import Mplex from 'libp2p-mplex';
// eslint-disable-next-line @typescript-eslint/ban-ts-comment
// @ts-ignore: No types available
import Websockets from 'libp2p-websockets';
// eslint-disable-next-line @typescript-eslint/ban-ts-comment
// @ts-ignore: No types available
import filters from 'libp2p-websockets/src/filters';
import Ping from 'libp2p/src/ping';
import { multiaddr } from 'multiaddr';
import PeerId from 'peer-id';
import { getBootstrapNodes } from './discovery';
import { getPeersForProtocol } from './select_peer';
import { LightPushCodec, WakuLightPush } from './waku_light_push';
import { WakuMessage } from './waku_message';
import { RelayCodecs, WakuRelay } from './waku_relay';
import { RelayPingContentTopic } from './waku_relay/constants';
import { StoreCodec, WakuStore } from './waku_store';
var websocketsTransportKey = Websockets.prototype[Symbol.toStringTag];
export var DefaultPingKeepAliveValueSecs = 0;
export var DefaultRelayKeepAliveValueSecs = 5 * 60;
/**
 * DefaultPubSubTopic is the default gossipsub topic to use for Waku.
 */
export var DefaultPubSubTopic = '/waku/2/default-waku/proto';
var dbg = debug('waku:waku');
var Waku = /** @class */ (function () {
    function Waku(options, libp2p, store, lightPush) {
        var _this = this;
        var _a;
        this.libp2p = libp2p;
        this.relay = libp2p.pubsub;
        this.store = store;
        this.lightPush = lightPush;
        this.pingKeepAliveTimers = {};
        this.relayKeepAliveTimers = {};
        var pingKeepAlive = options.pingKeepAlive || DefaultPingKeepAliveValueSecs;
        var relayKeepAlive = options.relayKeepAlive || DefaultRelayKeepAliveValueSecs;
        libp2p.connectionManager.on('peer:connect', function (connection) {
            _this.startKeepAlive(connection.remotePeer, pingKeepAlive, relayKeepAlive);
        });
        libp2p.connectionManager.on('peer:disconnect', function (connection) {
            _this.stopKeepAlive(connection.remotePeer);
        });
        (_a = options === null || options === void 0 ? void 0 : options.decryptionKeys) === null || _a === void 0 ? void 0 : _a.forEach(this.addDecryptionKey);
    }
    /**
     * Create new waku node
     *
     * @param options Takes the same options than `Libp2p`.
     */
    Waku.create = function (options) {
        var _a, _b, _c;
        return __awaiter(this, void 0, void 0, function () {
            var libp2pOpts, bootstrap, list, e_1, libp2p, wakuStore, wakuLightPush;
            var _d, _e;
            return __generator(this, function (_f) {
                switch (_f.label) {
                    case 0:
                        libp2pOpts = Object.assign({}, options === null || options === void 0 ? void 0 : options.libp2p);
                        // Default for Websocket filter is `all`:
                        // Returns all TCP and DNS based addresses, both with ws or wss.
                        libp2pOpts.config = Object.assign({
                            transport: (_d = {},
                                _d[websocketsTransportKey] = {
                                    filter: filters.all,
                                },
                                _d),
                        }, (_a = options === null || options === void 0 ? void 0 : options.libp2p) === null || _a === void 0 ? void 0 : _a.config);
                        // Pass pubsub topic to relay
                        if (options === null || options === void 0 ? void 0 : options.pubSubTopic) {
                            libp2pOpts.config.pubsub = Object.assign({ pubSubTopic: options.pubSubTopic }, libp2pOpts.config.pubsub);
                        }
                        libp2pOpts.modules = Object.assign({}, (_b = options === null || options === void 0 ? void 0 : options.libp2p) === null || _b === void 0 ? void 0 : _b.modules);
                        // Default transport for libp2p is Websockets
                        libp2pOpts.modules = Object.assign({
                            transport: [Websockets],
                        }, (_c = options === null || options === void 0 ? void 0 : options.libp2p) === null || _c === void 0 ? void 0 : _c.modules);
                        // streamMuxer, connection encryption and pubsub are overridden
                        // as those are the only ones currently supported by Waku nodes.
                        libp2pOpts.modules = Object.assign(libp2pOpts.modules, {
                            streamMuxer: [Mplex],
                            connEncryption: [new Noise(options === null || options === void 0 ? void 0 : options.staticNoiseKey)],
                            pubsub: WakuRelay,
                        });
                        if (!(options === null || options === void 0 ? void 0 : options.bootstrap)) return [3 /*break*/, 4];
                        bootstrap = void 0;
                        if (options.bootstrap === true) {
                            bootstrap = getBootstrapNodes;
                        }
                        else if (Array.isArray(options.bootstrap)) {
                            bootstrap = function () {
                                return options.bootstrap;
                            };
                        }
                        else if (typeof options.bootstrap === 'function') {
                            bootstrap = options.bootstrap;
                        }
                        if (!(bootstrap !== undefined)) return [3 /*break*/, 4];
                        _f.label = 1;
                    case 1:
                        _f.trys.push([1, 3, , 4]);
                        return [4 /*yield*/, bootstrap()];
                    case 2:
                        list = _f.sent();
                        // Note: this overrides any other peer discover
                        libp2pOpts.modules = Object.assign(libp2pOpts.modules, {
                            peerDiscovery: [Bootstrap],
                        });
                        libp2pOpts.config.peerDiscovery = (_e = {},
                            _e[Bootstrap.tag] = {
                                list: list,
                                enabled: true,
                            },
                            _e);
                        return [3 /*break*/, 4];
                    case 3:
                        e_1 = _f.sent();
                        dbg('Failed to retrieve bootstrap nodes', e_1);
                        return [3 /*break*/, 4];
                    case 4: return [4 /*yield*/, Libp2p.create(libp2pOpts)];
                    case 5:
                        libp2p = _f.sent();
                        wakuStore = new WakuStore(libp2p, {
                            pubSubTopic: options === null || options === void 0 ? void 0 : options.pubSubTopic,
                        });
                        wakuLightPush = new WakuLightPush(libp2p);
                        return [4 /*yield*/, libp2p.start()];
                    case 6:
                        _f.sent();
                        return [2 /*return*/, new Waku(options ? options : {}, libp2p, wakuStore, wakuLightPush)];
                }
            });
        });
    };
    /**
     * Dials to the provided peer.
     *
     * @param peer The peer to dial
     */
    Waku.prototype.dial = function (peer) {
        return __awaiter(this, void 0, void 0, function () {
            return __generator(this, function (_a) {
                return [2 /*return*/, this.libp2p.dialProtocol(peer, [StoreCodec].concat(RelayCodecs))];
            });
        });
    };
    /**
     * Add peer to address book, it will be auto-dialed in the background.
     */
    Waku.prototype.addPeerToAddressBook = function (peerId, multiaddrs) {
        var peer;
        if (typeof peerId === 'string') {
            peer = PeerId.createFromB58String(peerId);
        }
        else {
            peer = peerId;
        }
        var addresses = multiaddrs.map(function (addr) {
            if (typeof addr === 'string') {
                return multiaddr(addr);
            }
            else {
                return addr;
            }
        });
        this.libp2p.peerStore.addressBook.set(peer, addresses);
    };
    Waku.prototype.stop = function () {
        return __awaiter(this, void 0, void 0, function () {
            return __generator(this, function (_a) {
                return [2 /*return*/, this.libp2p.stop()];
            });
        });
    };
    /**
     * Register a decryption key to attempt decryption of messages received via
     * [[WakuRelay]] and [[WakuStore]]. This can either be a private key for
     * asymmetric encryption or a symmetric key.
     *
     * Strings must be in hex format.
     */
    Waku.prototype.addDecryptionKey = function (key) {
        this.relay.addDecryptionKey(key);
        this.store.addDecryptionKey(key);
    };
    /**
     * Delete a decryption key that was used to attempt decryption of messages
     * received via [[WakuRelay]] or [[WakuStore]].
     *
     * Strings must be in hex format.
     */
    Waku.prototype.deleteDecryptionKey = function (key) {
        this.relay.deleteDecryptionKey(key);
        this.store.deleteDecryptionKey(key);
    };
    /**
     * Return the local multiaddr with peer id on which libp2p is listening.
     * @throws if libp2p is not listening on localhost
     */
    Waku.prototype.getLocalMultiaddrWithID = function () {
        var localMultiaddr = this.libp2p.multiaddrs.find(function (addr) {
            return addr.toString().match(/127\.0\.0\.1/);
        });
        if (!localMultiaddr || localMultiaddr.toString() === '') {
            throw 'Not listening on localhost';
        }
        return localMultiaddr + '/p2p/' + this.libp2p.peerId.toB58String();
    };
    /**
     * Wait to be connected to a peer. Useful when using the [[CreateOptions.bootstrap]]
     * with [[Waku.create]]. The Promise resolves only once we are connected to a
     * Store peer, Relay peer and Light Push peer.
     */
    Waku.prototype.waitForConnectedPeer = function () {
        return __awaiter(this, void 0, void 0, function () {
            var desiredProtocols;
            var _this = this;
            return __generator(this, function (_a) {
                switch (_a.label) {
                    case 0:
                        desiredProtocols = [[StoreCodec], [LightPushCodec], RelayCodecs];
                        return [4 /*yield*/, Promise.all(desiredProtocols.map(function (desiredProtocolVersions) {
                                var peers = new Array();
                                desiredProtocolVersions.forEach(function (proto) {
                                    getPeersForProtocol(_this.libp2p, proto).forEach(function (peer) {
                                        return peers.push(peer);
                                    });
                                });
                                if (peers.length > 0) {
                                    return Promise.resolve();
                                }
                                else {
                                    // No peer available for this protocol, waiting to connect to one.
                                    return new Promise(function (resolve) {
                                        _this.libp2p.peerStore.on('change:protocols', function (_a) {
                                            var connectedPeerProtocols = _a.protocols;
                                            desiredProtocolVersions.forEach(function (desiredProto) {
                                                if (connectedPeerProtocols.includes(desiredProto)) {
                                                    dbg('Resolving for', desiredProto, connectedPeerProtocols);
                                                    resolve();
                                                }
                                            });
                                        });
                                    });
                                }
                            }))];
                    case 1:
                        _a.sent();
                        return [2 /*return*/];
                }
            });
        });
    };
    Waku.prototype.startKeepAlive = function (peerId, pingPeriodSecs, relayPeriodSecs) {
        var _this = this;
        // Just in case a timer already exist for this peer
        this.stopKeepAlive(peerId);
        var peerIdStr = peerId.toB58String();
        if (pingPeriodSecs !== 0) {
            this.pingKeepAliveTimers[peerIdStr] = setInterval(function () {
                Ping(_this.libp2p, peerId);
            }, pingPeriodSecs * 1000);
        }
        if (relayPeriodSecs !== 0) {
            this.relayKeepAliveTimers[peerIdStr] = setInterval(function () {
                WakuMessage.fromBytes(new Uint8Array(), RelayPingContentTopic).then(function (wakuMsg) { return _this.relay.send(wakuMsg); });
            }, relayPeriodSecs * 1000);
        }
    };
    Waku.prototype.stopKeepAlive = function (peerId) {
        var peerIdStr = peerId.toB58String();
        if (this.pingKeepAliveTimers[peerIdStr]) {
            clearInterval(this.pingKeepAliveTimers[peerIdStr]);
            delete this.pingKeepAliveTimers[peerIdStr];
        }
        if (this.relayKeepAliveTimers[peerIdStr]) {
            clearInterval(this.relayKeepAliveTimers[peerIdStr]);
            delete this.relayKeepAliveTimers[peerIdStr];
        }
    };
    return Waku;
}());
export { Waku };
//# sourceMappingURL=waku.js.map