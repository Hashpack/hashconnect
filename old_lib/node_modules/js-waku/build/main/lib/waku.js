"use strict";
var __importDefault = (this && this.__importDefault) || function (mod) {
    return (mod && mod.__esModule) ? mod : { "default": mod };
};
Object.defineProperty(exports, "__esModule", { value: true });
exports.Waku = exports.DefaultPubSubTopic = exports.DefaultRelayKeepAliveValueSecs = exports.DefaultPingKeepAliveValueSecs = void 0;
const noise_1 = require("@chainsafe/libp2p-noise/dist/src/noise");
const debug_1 = __importDefault(require("debug"));
const libp2p_1 = __importDefault(require("libp2p"));
const libp2p_bootstrap_1 = __importDefault(require("libp2p-bootstrap"));
// eslint-disable-next-line @typescript-eslint/ban-ts-comment
// @ts-ignore: No types available
const libp2p_mplex_1 = __importDefault(require("libp2p-mplex"));
// eslint-disable-next-line @typescript-eslint/ban-ts-comment
// @ts-ignore: No types available
const libp2p_websockets_1 = __importDefault(require("libp2p-websockets"));
// eslint-disable-next-line @typescript-eslint/ban-ts-comment
// @ts-ignore: No types available
const filters_1 = __importDefault(require("libp2p-websockets/src/filters"));
const ping_1 = __importDefault(require("libp2p/src/ping"));
const multiaddr_1 = require("multiaddr");
const peer_id_1 = __importDefault(require("peer-id"));
const discovery_1 = require("./discovery");
const select_peer_1 = require("./select_peer");
const waku_light_push_1 = require("./waku_light_push");
const waku_message_1 = require("./waku_message");
const waku_relay_1 = require("./waku_relay");
const constants_1 = require("./waku_relay/constants");
const waku_store_1 = require("./waku_store");
const websocketsTransportKey = libp2p_websockets_1.default.prototype[Symbol.toStringTag];
exports.DefaultPingKeepAliveValueSecs = 0;
exports.DefaultRelayKeepAliveValueSecs = 5 * 60;
/**
 * DefaultPubSubTopic is the default gossipsub topic to use for Waku.
 */
exports.DefaultPubSubTopic = '/waku/2/default-waku/proto';
const dbg = debug_1.default('waku:waku');
class Waku {
    constructor(options, libp2p, store, lightPush) {
        var _a;
        this.libp2p = libp2p;
        this.relay = libp2p.pubsub;
        this.store = store;
        this.lightPush = lightPush;
        this.pingKeepAliveTimers = {};
        this.relayKeepAliveTimers = {};
        const pingKeepAlive = options.pingKeepAlive || exports.DefaultPingKeepAliveValueSecs;
        const relayKeepAlive = options.relayKeepAlive || exports.DefaultRelayKeepAliveValueSecs;
        libp2p.connectionManager.on('peer:connect', (connection) => {
            this.startKeepAlive(connection.remotePeer, pingKeepAlive, relayKeepAlive);
        });
        libp2p.connectionManager.on('peer:disconnect', (connection) => {
            this.stopKeepAlive(connection.remotePeer);
        });
        (_a = options === null || options === void 0 ? void 0 : options.decryptionKeys) === null || _a === void 0 ? void 0 : _a.forEach(this.addDecryptionKey);
    }
    /**
     * Create new waku node
     *
     * @param options Takes the same options than `Libp2p`.
     */
    static async create(options) {
        var _a, _b, _c;
        // Get an object in case options or libp2p are undefined
        const libp2pOpts = Object.assign({}, options === null || options === void 0 ? void 0 : options.libp2p);
        // Default for Websocket filter is `all`:
        // Returns all TCP and DNS based addresses, both with ws or wss.
        libp2pOpts.config = Object.assign({
            transport: {
                [websocketsTransportKey]: {
                    filter: filters_1.default.all,
                },
            },
        }, (_a = options === null || options === void 0 ? void 0 : options.libp2p) === null || _a === void 0 ? void 0 : _a.config);
        // Pass pubsub topic to relay
        if (options === null || options === void 0 ? void 0 : options.pubSubTopic) {
            libp2pOpts.config.pubsub = Object.assign({ pubSubTopic: options.pubSubTopic }, libp2pOpts.config.pubsub);
        }
        libp2pOpts.modules = Object.assign({}, (_b = options === null || options === void 0 ? void 0 : options.libp2p) === null || _b === void 0 ? void 0 : _b.modules);
        // Default transport for libp2p is Websockets
        libp2pOpts.modules = Object.assign({
            transport: [libp2p_websockets_1.default],
        }, (_c = options === null || options === void 0 ? void 0 : options.libp2p) === null || _c === void 0 ? void 0 : _c.modules);
        // streamMuxer, connection encryption and pubsub are overridden
        // as those are the only ones currently supported by Waku nodes.
        libp2pOpts.modules = Object.assign(libp2pOpts.modules, {
            streamMuxer: [libp2p_mplex_1.default],
            connEncryption: [new noise_1.Noise(options === null || options === void 0 ? void 0 : options.staticNoiseKey)],
            pubsub: waku_relay_1.WakuRelay,
        });
        if (options === null || options === void 0 ? void 0 : options.bootstrap) {
            let bootstrap;
            if (options.bootstrap === true) {
                bootstrap = discovery_1.getBootstrapNodes;
            }
            else if (Array.isArray(options.bootstrap)) {
                bootstrap = () => {
                    return options.bootstrap;
                };
            }
            else if (typeof options.bootstrap === 'function') {
                bootstrap = options.bootstrap;
            }
            if (bootstrap !== undefined) {
                try {
                    const list = await bootstrap();
                    // Note: this overrides any other peer discover
                    libp2pOpts.modules = Object.assign(libp2pOpts.modules, {
                        peerDiscovery: [libp2p_bootstrap_1.default],
                    });
                    libp2pOpts.config.peerDiscovery = {
                        [libp2p_bootstrap_1.default.tag]: {
                            list,
                            enabled: true,
                        },
                    };
                }
                catch (e) {
                    dbg('Failed to retrieve bootstrap nodes', e);
                }
            }
        }
        // eslint-disable-next-line @typescript-eslint/ban-ts-comment
        // @ts-ignore: modules property is correctly set thanks to voodoo
        const libp2p = await libp2p_1.default.create(libp2pOpts);
        const wakuStore = new waku_store_1.WakuStore(libp2p, {
            pubSubTopic: options === null || options === void 0 ? void 0 : options.pubSubTopic,
        });
        const wakuLightPush = new waku_light_push_1.WakuLightPush(libp2p);
        await libp2p.start();
        return new Waku(options ? options : {}, libp2p, wakuStore, wakuLightPush);
    }
    /**
     * Dials to the provided peer.
     *
     * @param peer The peer to dial
     */
    async dial(peer) {
        return this.libp2p.dialProtocol(peer, [waku_store_1.StoreCodec].concat(waku_relay_1.RelayCodecs));
    }
    /**
     * Add peer to address book, it will be auto-dialed in the background.
     */
    addPeerToAddressBook(peerId, multiaddrs) {
        let peer;
        if (typeof peerId === 'string') {
            peer = peer_id_1.default.createFromB58String(peerId);
        }
        else {
            peer = peerId;
        }
        const addresses = multiaddrs.map((addr) => {
            if (typeof addr === 'string') {
                return multiaddr_1.multiaddr(addr);
            }
            else {
                return addr;
            }
        });
        this.libp2p.peerStore.addressBook.set(peer, addresses);
    }
    async stop() {
        return this.libp2p.stop();
    }
    /**
     * Register a decryption key to attempt decryption of messages received via
     * [[WakuRelay]] and [[WakuStore]]. This can either be a private key for
     * asymmetric encryption or a symmetric key.
     *
     * Strings must be in hex format.
     */
    addDecryptionKey(key) {
        this.relay.addDecryptionKey(key);
        this.store.addDecryptionKey(key);
    }
    /**
     * Delete a decryption key that was used to attempt decryption of messages
     * received via [[WakuRelay]] or [[WakuStore]].
     *
     * Strings must be in hex format.
     */
    deleteDecryptionKey(key) {
        this.relay.deleteDecryptionKey(key);
        this.store.deleteDecryptionKey(key);
    }
    /**
     * Return the local multiaddr with peer id on which libp2p is listening.
     * @throws if libp2p is not listening on localhost
     */
    getLocalMultiaddrWithID() {
        const localMultiaddr = this.libp2p.multiaddrs.find((addr) => addr.toString().match(/127\.0\.0\.1/));
        if (!localMultiaddr || localMultiaddr.toString() === '') {
            throw 'Not listening on localhost';
        }
        return localMultiaddr + '/p2p/' + this.libp2p.peerId.toB58String();
    }
    /**
     * Wait to be connected to a peer. Useful when using the [[CreateOptions.bootstrap]]
     * with [[Waku.create]]. The Promise resolves only once we are connected to a
     * Store peer, Relay peer and Light Push peer.
     */
    async waitForConnectedPeer() {
        const desiredProtocols = [[waku_store_1.StoreCodec], [waku_light_push_1.LightPushCodec], waku_relay_1.RelayCodecs];
        await Promise.all(desiredProtocols.map((desiredProtocolVersions) => {
            const peers = new Array();
            desiredProtocolVersions.forEach((proto) => {
                select_peer_1.getPeersForProtocol(this.libp2p, proto).forEach((peer) => peers.push(peer));
            });
            if (peers.length > 0) {
                return Promise.resolve();
            }
            else {
                // No peer available for this protocol, waiting to connect to one.
                return new Promise((resolve) => {
                    this.libp2p.peerStore.on('change:protocols', ({ protocols: connectedPeerProtocols }) => {
                        desiredProtocolVersions.forEach((desiredProto) => {
                            if (connectedPeerProtocols.includes(desiredProto)) {
                                dbg('Resolving for', desiredProto, connectedPeerProtocols);
                                resolve();
                            }
                        });
                    });
                });
            }
        }));
    }
    startKeepAlive(peerId, pingPeriodSecs, relayPeriodSecs) {
        // Just in case a timer already exist for this peer
        this.stopKeepAlive(peerId);
        const peerIdStr = peerId.toB58String();
        if (pingPeriodSecs !== 0) {
            this.pingKeepAliveTimers[peerIdStr] = setInterval(() => {
                ping_1.default(this.libp2p, peerId);
            }, pingPeriodSecs * 1000);
        }
        if (relayPeriodSecs !== 0) {
            this.relayKeepAliveTimers[peerIdStr] = setInterval(() => {
                waku_message_1.WakuMessage.fromBytes(new Uint8Array(), constants_1.RelayPingContentTopic).then((wakuMsg) => this.relay.send(wakuMsg));
            }, relayPeriodSecs * 1000);
        }
    }
    stopKeepAlive(peerId) {
        const peerIdStr = peerId.toB58String();
        if (this.pingKeepAliveTimers[peerIdStr]) {
            clearInterval(this.pingKeepAliveTimers[peerIdStr]);
            delete this.pingKeepAliveTimers[peerIdStr];
        }
        if (this.relayKeepAliveTimers[peerIdStr]) {
            clearInterval(this.relayKeepAliveTimers[peerIdStr]);
            delete this.relayKeepAliveTimers[peerIdStr];
        }
    }
}
exports.Waku = Waku;
//# sourceMappingURL=waku.js.map