import * as proto from '../../proto/waku/v2/message';
export interface Options {
    /**
     * Timestamp to set on the message, defaults to now if not passed.
     */
    timestamp?: Date;
    /**
     * Public Key to use to encrypt the messages using ECIES (Asymmetric Encryption).
     *
     * @throws if both `encPublicKey` and `symKey` are passed
     */
    encPublicKey?: Uint8Array | string;
    /**
     * Key to use to encrypt the messages using AES (Symmetric Encryption).
     *
     * @throws if both `encPublicKey` and `symKey` are passed
     */
    symKey?: Uint8Array | string;
    /**
     * Private key to use to sign the message, either `encPublicKey` or `symKey` must be provided as only
     * encrypted messages are signed.
     */
    sigPrivKey?: Uint8Array;
}
export declare class WakuMessage {
    proto: proto.WakuMessage;
    private _signaturePublicKey?;
    private _signature?;
    private constructor();
    /**
     * Create Message with a utf-8 string as payload.
     */
    static fromUtf8String(utf8: string, contentTopic: string, opts?: Options): Promise<WakuMessage>;
    /**
     * Create a Waku Message with the given payload.
     *
     * By default, the payload is kept clear (version 0).
     * If `opts.encPublicKey` is passed, the payload is encrypted using
     * asymmetric encryption (version 1).
     *
     * If `opts.sigPrivKey` is passed and version 1 is used, the payload is signed
     * before encryption.
     *
     * @throws if both `opts.encPublicKey` and `opt.symKey` are passed
     */
    static fromBytes(payload: Uint8Array, contentTopic: string, opts?: Options): Promise<WakuMessage>;
    /**
     * Decode a byte array into Waku Message.
     *
     * @params bytes The message encoded using protobuf as defined in [14/WAKU2-MESSAGE](https://rfc.vac.dev/spec/14/).
     * @params decryptionKeys If the payload is encrypted (version = 1), then the
     * keys are used to attempt decryption of the message. The passed key can either
     * be asymmetric private keys or symmetric keys, both method are tried for each
     * key until the message is decrypted or combinations are ran out.
     */
    static decode(bytes: Uint8Array, decryptionKeys?: Uint8Array[]): Promise<WakuMessage | undefined>;
    /**
     * Decode and decrypt Waku Message Protobuf Object into Waku Message.
     *
     * @params protoBuf The message to decode and decrypt.
     * @params decryptionKeys If the payload is encrypted (version = 1), then the
     * keys are used to attempt decryption of the message. The passed key can either
     * be asymmetric private keys or symmetric keys, both method are tried for each
     * key until the message is decrypted or combinations are ran out.
     */
    static decodeProto(protoBuf: proto.WakuMessage, decryptionKeys?: Uint8Array[]): Promise<WakuMessage | undefined>;
    encode(): Uint8Array;
    get payloadAsUtf8(): string;
    get payload(): Uint8Array | undefined;
    get contentTopic(): string | undefined;
    get version(): number | undefined;
    get timestamp(): Date | undefined;
    /**
     * The public key used to sign the message.
     *
     * MAY be present if the message is version 1.
     */
    get signaturePublicKey(): Uint8Array | undefined;
    /**
     * The signature of the message.
     *
     * MAY be present if the message is version 1.
     */
    get signature(): Uint8Array | undefined;
}
