"use strict";
var __createBinding = (this && this.__createBinding) || (Object.create ? (function(o, m, k, k2) {
    if (k2 === undefined) k2 = k;
    Object.defineProperty(o, k2, { enumerable: true, get: function() { return m[k]; } });
}) : (function(o, m, k, k2) {
    if (k2 === undefined) k2 = k;
    o[k2] = m[k];
}));
var __setModuleDefault = (this && this.__setModuleDefault) || (Object.create ? (function(o, v) {
    Object.defineProperty(o, "default", { enumerable: true, value: v });
}) : function(o, v) {
    o["default"] = v;
});
var __importStar = (this && this.__importStar) || function (mod) {
    if (mod && mod.__esModule) return mod;
    var result = {};
    if (mod != null) for (var k in mod) if (k !== "default" && Object.prototype.hasOwnProperty.call(mod, k)) __createBinding(result, mod, k);
    __setModuleDefault(result, mod);
    return result;
};
Object.defineProperty(exports, "__esModule", { value: true });
exports.getPublicKey = exports.generateSymmetricKey = exports.generatePrivateKey = exports.decryptSymmetric = exports.encryptSymmetric = exports.decryptAsymmetric = exports.encryptAsymmetric = exports.clearDecode = exports.clearEncode = exports.PrivateKeySize = void 0;
const buffer_1 = require("buffer");
const crypto = __importStar(require("crypto"));
const ecies = __importStar(require("ecies-geth"));
const js_sha3_1 = require("js-sha3");
const secp256k1 = __importStar(require("secp256k1"));
const utils_1 = require("../utils");
const symmetric_1 = require("./symmetric");
const FlagsLength = 1;
const FlagMask = 3; // 0011
const IsSignedMask = 4; // 0100
const PaddingTarget = 256;
const SignatureLength = 65;
exports.PrivateKeySize = 32;
/**
 * Encode the payload pre-encryption.
 *
 * @internal
 * @param messagePayload: The payload to include in the message
 * @param sigPrivKey: If set, a signature using this private key is added.
 * @returns The encoded payload, ready for encryption using {@link encryptAsymmetric}
 * or {@link encryptSymmetric}.
 */
function clearEncode(messagePayload, sigPrivKey) {
    let envelope = buffer_1.Buffer.from([0]); // No flags
    envelope = addPayloadSizeField(envelope, messagePayload);
    envelope = buffer_1.Buffer.concat([envelope, buffer_1.Buffer.from(messagePayload)]);
    // Calculate padding:
    let rawSize = FlagsLength +
        getSizeOfPayloadSizeField(messagePayload) +
        messagePayload.length;
    if (sigPrivKey) {
        rawSize += SignatureLength;
    }
    const remainder = rawSize % PaddingTarget;
    const paddingSize = PaddingTarget - remainder;
    const pad = buffer_1.Buffer.from(randomBytes(paddingSize));
    if (!validateDataIntegrity(pad, paddingSize)) {
        throw new Error('failed to generate random padding of size ' + paddingSize);
    }
    envelope = buffer_1.Buffer.concat([envelope, pad]);
    let sig;
    if (sigPrivKey) {
        envelope[0] |= IsSignedMask;
        const hash = js_sha3_1.keccak256(envelope);
        const s = secp256k1.ecdsaSign(utils_1.hexToBuf(hash), sigPrivKey);
        envelope = buffer_1.Buffer.concat([envelope, s.signature, buffer_1.Buffer.from([s.recid])]);
        sig = {
            signature: buffer_1.Buffer.from(s.signature),
            publicKey: getPublicKey(sigPrivKey),
        };
    }
    return { payload: envelope, sig };
}
exports.clearEncode = clearEncode;
/**
 * Decode a decrypted payload.
 *
 * @internal
 */
function clearDecode(message) {
    const buf = buffer_1.Buffer.from(message);
    let start = 1;
    let sig;
    const sizeOfPayloadSizeField = buf.readUIntLE(0, 1) & FlagMask;
    if (sizeOfPayloadSizeField === 0)
        return;
    const payloadSize = buf.readUIntLE(start, sizeOfPayloadSizeField);
    start += sizeOfPayloadSizeField;
    const payload = buf.slice(start, start + payloadSize);
    const isSigned = (buf.readUIntLE(0, 1) & IsSignedMask) == IsSignedMask;
    if (isSigned) {
        const signature = getSignature(buf);
        const hash = getHash(buf, isSigned);
        const publicKey = ecRecoverPubKey(hash, signature);
        sig = { signature, publicKey };
    }
    return { payload, sig };
}
exports.clearDecode = clearDecode;
/**
 * Proceed with Asymmetric encryption of the data as per [26/WAKU-PAYLOAD](https://rfc.vac.dev/spec/26/).
 * The data MUST be flags | payload-length | payload | [signature].
 * The returned result can be set to `WakuMessage.payload`.
 *
 * @internal
 */
async function encryptAsymmetric(data, publicKey) {
    return ecies.encrypt(utils_1.hexToBuf(publicKey), buffer_1.Buffer.from(data));
}
exports.encryptAsymmetric = encryptAsymmetric;
/**
 * Proceed with Asymmetric decryption of the data as per [26/WAKU-PAYLOAD](https://rfc.vac.dev/spec/26/).
 * The return data is expect to be flags | payload-length | payload | [signature].
 *
 * @internal
 */
async function decryptAsymmetric(payload, privKey) {
    return ecies.decrypt(buffer_1.Buffer.from(privKey), buffer_1.Buffer.from(payload));
}
exports.decryptAsymmetric = decryptAsymmetric;
/**
 * Proceed with Symmetric encryption of the data as per [26/WAKU-PAYLOAD](https://rfc.vac.dev/spec/26/).
 *
 * @param data The data to encrypt, expected to be `flags | payload-length | payload | [signature]`.
 * @param key The key to use for encryption.
 * @returns The decrypted data, `cipherText | tag | iv` and can be set to `WakuMessage.payload`.
 *
 * @internal
 */
async function encryptSymmetric(data, key) {
    const iv = symmetric_1.symmetric.generateIv();
    // Returns `cipher | tag`
    const cipher = await symmetric_1.symmetric.encrypt(iv, utils_1.hexToBuf(key), buffer_1.Buffer.from(data));
    return buffer_1.Buffer.concat([cipher, buffer_1.Buffer.from(iv)]);
}
exports.encryptSymmetric = encryptSymmetric;
/**
 * Proceed with Symmetric decryption of the data as per [26/WAKU-PAYLOAD](https://rfc.vac.dev/spec/26/).
 *
 * @param payload The cipher data, it is expected to be `cipherText | tag | iv`.
 * @param key The key to use for decryption.
 * @returns The decrypted data, expected to be `flags | payload-length | payload | [signature]`.
 *
 * @internal
 */
async function decryptSymmetric(payload, key) {
    const data = buffer_1.Buffer.from(payload);
    const ivStart = data.length - symmetric_1.IvSize;
    const cipher = data.slice(0, ivStart);
    const iv = data.slice(ivStart);
    return symmetric_1.symmetric.decrypt(iv, utils_1.hexToBuf(key), cipher);
}
exports.decryptSymmetric = decryptSymmetric;
/**
 * Generate a new private key to be used for asymmetric encryption.
 *
 * Use {@link getPublicKey} to get the corresponding Public Key.
 */
function generatePrivateKey() {
    return randomBytes(exports.PrivateKeySize);
}
exports.generatePrivateKey = generatePrivateKey;
/**
 * Generate a new symmetric key to be used for symmetric encryption.
 */
function generateSymmetricKey() {
    return randomBytes(symmetric_1.SymmetricKeySize);
}
exports.generateSymmetricKey = generateSymmetricKey;
/**
 * Return the public key for the given private key, to be used for asymmetric
 * encryption.
 */
function getPublicKey(privateKey) {
    return secp256k1.publicKeyCreate(privateKey, false);
}
exports.getPublicKey = getPublicKey;
/**
 * Computes the flags & auxiliary-field as per [26/WAKU-PAYLOAD](https://rfc.vac.dev/spec/26/).
 */
function addPayloadSizeField(msg, payload) {
    const fieldSize = getSizeOfPayloadSizeField(payload);
    let field = buffer_1.Buffer.alloc(4);
    field.writeUInt32LE(payload.length, 0);
    field = field.slice(0, fieldSize);
    msg = buffer_1.Buffer.concat([msg, field]);
    msg[0] |= fieldSize;
    return msg;
}
/**
 * Returns the size of the auxiliary-field which in turns contains the payload size
 */
function getSizeOfPayloadSizeField(payload) {
    let s = 1;
    for (let i = payload.length; i >= 256; i /= 256) {
        s++;
    }
    return s;
}
function validateDataIntegrity(value, expectedSize) {
    if (value.length !== expectedSize) {
        return false;
    }
    return !(expectedSize > 3 && buffer_1.Buffer.from(value).equals(buffer_1.Buffer.alloc(value.length)));
}
function getSignature(message) {
    return message.slice(message.length - SignatureLength, message.length);
}
function getHash(message, isSigned) {
    if (isSigned) {
        return js_sha3_1.keccak256(message.slice(0, message.length - SignatureLength));
    }
    return js_sha3_1.keccak256(message);
}
function ecRecoverPubKey(messageHash, signature) {
    const recovery = signature.slice(64).readIntBE(0, 1);
    return secp256k1.ecdsaRecover(signature.slice(0, 64), recovery, utils_1.hexToBuf(messageHash), false);
}
function randomBytes(length) {
    if (typeof window !== 'undefined' && window && window.crypto) {
        const array = new Uint8Array(length);
        window.crypto.getRandomValues(array);
        return array;
    }
    else {
        return crypto.randomBytes(length);
    }
}
//# sourceMappingURL=version_1.js.map