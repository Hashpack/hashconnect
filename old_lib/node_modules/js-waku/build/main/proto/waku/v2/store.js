"use strict";
var __importDefault = (this && this.__importDefault) || function (mod) {
    return (mod && mod.__esModule) ? mod : { "default": mod };
};
Object.defineProperty(exports, "__esModule", { value: true });
exports.HistoryRPC = exports.HistoryResponse = exports.HistoryQuery = exports.ContentFilter = exports.PagingInfo = exports.Index = exports.historyResponse_ErrorToJSON = exports.historyResponse_ErrorFromJSON = exports.HistoryResponse_Error = exports.pagingInfo_DirectionToJSON = exports.pagingInfo_DirectionFromJSON = exports.PagingInfo_Direction = exports.protobufPackage = void 0;
/* eslint-disable */
const long_1 = __importDefault(require("long"));
const minimal_1 = __importDefault(require("protobufjs/minimal"));
const message_1 = require("../../waku/v2/message");
exports.protobufPackage = 'waku.v2';
var PagingInfo_Direction;
(function (PagingInfo_Direction) {
    PagingInfo_Direction[PagingInfo_Direction["DIRECTION_BACKWARD_UNSPECIFIED"] = 0] = "DIRECTION_BACKWARD_UNSPECIFIED";
    PagingInfo_Direction[PagingInfo_Direction["DIRECTION_FORWARD"] = 1] = "DIRECTION_FORWARD";
    PagingInfo_Direction[PagingInfo_Direction["UNRECOGNIZED"] = -1] = "UNRECOGNIZED";
})(PagingInfo_Direction = exports.PagingInfo_Direction || (exports.PagingInfo_Direction = {}));
function pagingInfo_DirectionFromJSON(object) {
    switch (object) {
        case 0:
        case 'DIRECTION_BACKWARD_UNSPECIFIED':
            return PagingInfo_Direction.DIRECTION_BACKWARD_UNSPECIFIED;
        case 1:
        case 'DIRECTION_FORWARD':
            return PagingInfo_Direction.DIRECTION_FORWARD;
        case -1:
        case 'UNRECOGNIZED':
        default:
            return PagingInfo_Direction.UNRECOGNIZED;
    }
}
exports.pagingInfo_DirectionFromJSON = pagingInfo_DirectionFromJSON;
function pagingInfo_DirectionToJSON(object) {
    switch (object) {
        case PagingInfo_Direction.DIRECTION_BACKWARD_UNSPECIFIED:
            return 'DIRECTION_BACKWARD_UNSPECIFIED';
        case PagingInfo_Direction.DIRECTION_FORWARD:
            return 'DIRECTION_FORWARD';
        default:
            return 'UNKNOWN';
    }
}
exports.pagingInfo_DirectionToJSON = pagingInfo_DirectionToJSON;
var HistoryResponse_Error;
(function (HistoryResponse_Error) {
    HistoryResponse_Error[HistoryResponse_Error["ERROR_NONE_UNSPECIFIED"] = 0] = "ERROR_NONE_UNSPECIFIED";
    HistoryResponse_Error[HistoryResponse_Error["ERROR_INVALID_CURSOR"] = 1] = "ERROR_INVALID_CURSOR";
    HistoryResponse_Error[HistoryResponse_Error["UNRECOGNIZED"] = -1] = "UNRECOGNIZED";
})(HistoryResponse_Error = exports.HistoryResponse_Error || (exports.HistoryResponse_Error = {}));
function historyResponse_ErrorFromJSON(object) {
    switch (object) {
        case 0:
        case 'ERROR_NONE_UNSPECIFIED':
            return HistoryResponse_Error.ERROR_NONE_UNSPECIFIED;
        case 1:
        case 'ERROR_INVALID_CURSOR':
            return HistoryResponse_Error.ERROR_INVALID_CURSOR;
        case -1:
        case 'UNRECOGNIZED':
        default:
            return HistoryResponse_Error.UNRECOGNIZED;
    }
}
exports.historyResponse_ErrorFromJSON = historyResponse_ErrorFromJSON;
function historyResponse_ErrorToJSON(object) {
    switch (object) {
        case HistoryResponse_Error.ERROR_NONE_UNSPECIFIED:
            return 'ERROR_NONE_UNSPECIFIED';
        case HistoryResponse_Error.ERROR_INVALID_CURSOR:
            return 'ERROR_INVALID_CURSOR';
        default:
            return 'UNKNOWN';
    }
}
exports.historyResponse_ErrorToJSON = historyResponse_ErrorToJSON;
const baseIndex = { receivedTime: 0, senderTime: 0 };
exports.Index = {
    encode(message, writer = minimal_1.default.Writer.create()) {
        if (message.digest.length !== 0) {
            writer.uint32(10).bytes(message.digest);
        }
        if (message.receivedTime !== 0) {
            writer.uint32(17).double(message.receivedTime);
        }
        if (message.senderTime !== 0) {
            writer.uint32(25).double(message.senderTime);
        }
        return writer;
    },
    decode(input, length) {
        const reader = input instanceof minimal_1.default.Reader ? input : new minimal_1.default.Reader(input);
        let end = length === undefined ? reader.len : reader.pos + length;
        const message = Object.assign({}, baseIndex);
        message.digest = new Uint8Array();
        while (reader.pos < end) {
            const tag = reader.uint32();
            switch (tag >>> 3) {
                case 1:
                    message.digest = reader.bytes();
                    break;
                case 2:
                    message.receivedTime = reader.double();
                    break;
                case 3:
                    message.senderTime = reader.double();
                    break;
                default:
                    reader.skipType(tag & 7);
                    break;
            }
        }
        return message;
    },
    fromJSON(object) {
        const message = Object.assign({}, baseIndex);
        message.digest = new Uint8Array();
        if (object.digest !== undefined && object.digest !== null) {
            message.digest = bytesFromBase64(object.digest);
        }
        if (object.receivedTime !== undefined && object.receivedTime !== null) {
            message.receivedTime = Number(object.receivedTime);
        }
        else {
            message.receivedTime = 0;
        }
        if (object.senderTime !== undefined && object.senderTime !== null) {
            message.senderTime = Number(object.senderTime);
        }
        else {
            message.senderTime = 0;
        }
        return message;
    },
    toJSON(message) {
        const obj = {};
        message.digest !== undefined &&
            (obj.digest = base64FromBytes(message.digest !== undefined ? message.digest : new Uint8Array()));
        message.receivedTime !== undefined &&
            (obj.receivedTime = message.receivedTime);
        message.senderTime !== undefined && (obj.senderTime = message.senderTime);
        return obj;
    },
    fromPartial(object) {
        const message = Object.assign({}, baseIndex);
        if (object.digest !== undefined && object.digest !== null) {
            message.digest = object.digest;
        }
        else {
            message.digest = new Uint8Array();
        }
        if (object.receivedTime !== undefined && object.receivedTime !== null) {
            message.receivedTime = object.receivedTime;
        }
        else {
            message.receivedTime = 0;
        }
        if (object.senderTime !== undefined && object.senderTime !== null) {
            message.senderTime = object.senderTime;
        }
        else {
            message.senderTime = 0;
        }
        return message;
    },
};
const basePagingInfo = { pageSize: 0, direction: 0 };
exports.PagingInfo = {
    encode(message, writer = minimal_1.default.Writer.create()) {
        if (message.pageSize !== 0) {
            writer.uint32(8).uint64(message.pageSize);
        }
        if (message.cursor !== undefined) {
            exports.Index.encode(message.cursor, writer.uint32(18).fork()).ldelim();
        }
        if (message.direction !== 0) {
            writer.uint32(24).int32(message.direction);
        }
        return writer;
    },
    decode(input, length) {
        const reader = input instanceof minimal_1.default.Reader ? input : new minimal_1.default.Reader(input);
        let end = length === undefined ? reader.len : reader.pos + length;
        const message = Object.assign({}, basePagingInfo);
        while (reader.pos < end) {
            const tag = reader.uint32();
            switch (tag >>> 3) {
                case 1:
                    message.pageSize = longToNumber(reader.uint64());
                    break;
                case 2:
                    message.cursor = exports.Index.decode(reader, reader.uint32());
                    break;
                case 3:
                    message.direction = reader.int32();
                    break;
                default:
                    reader.skipType(tag & 7);
                    break;
            }
        }
        return message;
    },
    fromJSON(object) {
        const message = Object.assign({}, basePagingInfo);
        if (object.pageSize !== undefined && object.pageSize !== null) {
            message.pageSize = Number(object.pageSize);
        }
        else {
            message.pageSize = 0;
        }
        if (object.cursor !== undefined && object.cursor !== null) {
            message.cursor = exports.Index.fromJSON(object.cursor);
        }
        else {
            message.cursor = undefined;
        }
        if (object.direction !== undefined && object.direction !== null) {
            message.direction = pagingInfo_DirectionFromJSON(object.direction);
        }
        else {
            message.direction = 0;
        }
        return message;
    },
    toJSON(message) {
        const obj = {};
        message.pageSize !== undefined && (obj.pageSize = message.pageSize);
        message.cursor !== undefined &&
            (obj.cursor = message.cursor ? exports.Index.toJSON(message.cursor) : undefined);
        message.direction !== undefined &&
            (obj.direction = pagingInfo_DirectionToJSON(message.direction));
        return obj;
    },
    fromPartial(object) {
        const message = Object.assign({}, basePagingInfo);
        if (object.pageSize !== undefined && object.pageSize !== null) {
            message.pageSize = object.pageSize;
        }
        else {
            message.pageSize = 0;
        }
        if (object.cursor !== undefined && object.cursor !== null) {
            message.cursor = exports.Index.fromPartial(object.cursor);
        }
        else {
            message.cursor = undefined;
        }
        if (object.direction !== undefined && object.direction !== null) {
            message.direction = object.direction;
        }
        else {
            message.direction = 0;
        }
        return message;
    },
};
const baseContentFilter = { contentTopic: '' };
exports.ContentFilter = {
    encode(message, writer = minimal_1.default.Writer.create()) {
        if (message.contentTopic !== '') {
            writer.uint32(10).string(message.contentTopic);
        }
        return writer;
    },
    decode(input, length) {
        const reader = input instanceof minimal_1.default.Reader ? input : new minimal_1.default.Reader(input);
        let end = length === undefined ? reader.len : reader.pos + length;
        const message = Object.assign({}, baseContentFilter);
        while (reader.pos < end) {
            const tag = reader.uint32();
            switch (tag >>> 3) {
                case 1:
                    message.contentTopic = reader.string();
                    break;
                default:
                    reader.skipType(tag & 7);
                    break;
            }
        }
        return message;
    },
    fromJSON(object) {
        const message = Object.assign({}, baseContentFilter);
        if (object.contentTopic !== undefined && object.contentTopic !== null) {
            message.contentTopic = String(object.contentTopic);
        }
        else {
            message.contentTopic = '';
        }
        return message;
    },
    toJSON(message) {
        const obj = {};
        message.contentTopic !== undefined &&
            (obj.contentTopic = message.contentTopic);
        return obj;
    },
    fromPartial(object) {
        const message = Object.assign({}, baseContentFilter);
        if (object.contentTopic !== undefined && object.contentTopic !== null) {
            message.contentTopic = object.contentTopic;
        }
        else {
            message.contentTopic = '';
        }
        return message;
    },
};
const baseHistoryQuery = {};
exports.HistoryQuery = {
    encode(message, writer = minimal_1.default.Writer.create()) {
        if (message.pubSubTopic !== undefined) {
            writer.uint32(18).string(message.pubSubTopic);
        }
        for (const v of message.contentFilters) {
            exports.ContentFilter.encode(v, writer.uint32(26).fork()).ldelim();
        }
        if (message.pagingInfo !== undefined) {
            exports.PagingInfo.encode(message.pagingInfo, writer.uint32(34).fork()).ldelim();
        }
        if (message.startTime !== undefined) {
            writer.uint32(41).double(message.startTime);
        }
        if (message.endTime !== undefined) {
            writer.uint32(49).double(message.endTime);
        }
        return writer;
    },
    decode(input, length) {
        const reader = input instanceof minimal_1.default.Reader ? input : new minimal_1.default.Reader(input);
        let end = length === undefined ? reader.len : reader.pos + length;
        const message = Object.assign({}, baseHistoryQuery);
        message.contentFilters = [];
        while (reader.pos < end) {
            const tag = reader.uint32();
            switch (tag >>> 3) {
                case 2:
                    message.pubSubTopic = reader.string();
                    break;
                case 3:
                    message.contentFilters.push(exports.ContentFilter.decode(reader, reader.uint32()));
                    break;
                case 4:
                    message.pagingInfo = exports.PagingInfo.decode(reader, reader.uint32());
                    break;
                case 5:
                    message.startTime = reader.double();
                    break;
                case 6:
                    message.endTime = reader.double();
                    break;
                default:
                    reader.skipType(tag & 7);
                    break;
            }
        }
        return message;
    },
    fromJSON(object) {
        const message = Object.assign({}, baseHistoryQuery);
        message.contentFilters = [];
        if (object.pubSubTopic !== undefined && object.pubSubTopic !== null) {
            message.pubSubTopic = String(object.pubSubTopic);
        }
        else {
            message.pubSubTopic = undefined;
        }
        if (object.contentFilters !== undefined && object.contentFilters !== null) {
            for (const e of object.contentFilters) {
                message.contentFilters.push(exports.ContentFilter.fromJSON(e));
            }
        }
        if (object.pagingInfo !== undefined && object.pagingInfo !== null) {
            message.pagingInfo = exports.PagingInfo.fromJSON(object.pagingInfo);
        }
        else {
            message.pagingInfo = undefined;
        }
        if (object.startTime !== undefined && object.startTime !== null) {
            message.startTime = Number(object.startTime);
        }
        else {
            message.startTime = undefined;
        }
        if (object.endTime !== undefined && object.endTime !== null) {
            message.endTime = Number(object.endTime);
        }
        else {
            message.endTime = undefined;
        }
        return message;
    },
    toJSON(message) {
        const obj = {};
        message.pubSubTopic !== undefined &&
            (obj.pubSubTopic = message.pubSubTopic);
        if (message.contentFilters) {
            obj.contentFilters = message.contentFilters.map((e) => e ? exports.ContentFilter.toJSON(e) : undefined);
        }
        else {
            obj.contentFilters = [];
        }
        message.pagingInfo !== undefined &&
            (obj.pagingInfo = message.pagingInfo
                ? exports.PagingInfo.toJSON(message.pagingInfo)
                : undefined);
        message.startTime !== undefined && (obj.startTime = message.startTime);
        message.endTime !== undefined && (obj.endTime = message.endTime);
        return obj;
    },
    fromPartial(object) {
        const message = Object.assign({}, baseHistoryQuery);
        message.contentFilters = [];
        if (object.pubSubTopic !== undefined && object.pubSubTopic !== null) {
            message.pubSubTopic = object.pubSubTopic;
        }
        else {
            message.pubSubTopic = undefined;
        }
        if (object.contentFilters !== undefined && object.contentFilters !== null) {
            for (const e of object.contentFilters) {
                message.contentFilters.push(exports.ContentFilter.fromPartial(e));
            }
        }
        if (object.pagingInfo !== undefined && object.pagingInfo !== null) {
            message.pagingInfo = exports.PagingInfo.fromPartial(object.pagingInfo);
        }
        else {
            message.pagingInfo = undefined;
        }
        if (object.startTime !== undefined && object.startTime !== null) {
            message.startTime = object.startTime;
        }
        else {
            message.startTime = undefined;
        }
        if (object.endTime !== undefined && object.endTime !== null) {
            message.endTime = object.endTime;
        }
        else {
            message.endTime = undefined;
        }
        return message;
    },
};
const baseHistoryResponse = { error: 0 };
exports.HistoryResponse = {
    encode(message, writer = minimal_1.default.Writer.create()) {
        for (const v of message.messages) {
            message_1.WakuMessage.encode(v, writer.uint32(18).fork()).ldelim();
        }
        if (message.pagingInfo !== undefined) {
            exports.PagingInfo.encode(message.pagingInfo, writer.uint32(26).fork()).ldelim();
        }
        if (message.error !== 0) {
            writer.uint32(32).int32(message.error);
        }
        return writer;
    },
    decode(input, length) {
        const reader = input instanceof minimal_1.default.Reader ? input : new minimal_1.default.Reader(input);
        let end = length === undefined ? reader.len : reader.pos + length;
        const message = Object.assign({}, baseHistoryResponse);
        message.messages = [];
        while (reader.pos < end) {
            const tag = reader.uint32();
            switch (tag >>> 3) {
                case 2:
                    message.messages.push(message_1.WakuMessage.decode(reader, reader.uint32()));
                    break;
                case 3:
                    message.pagingInfo = exports.PagingInfo.decode(reader, reader.uint32());
                    break;
                case 4:
                    message.error = reader.int32();
                    break;
                default:
                    reader.skipType(tag & 7);
                    break;
            }
        }
        return message;
    },
    fromJSON(object) {
        const message = Object.assign({}, baseHistoryResponse);
        message.messages = [];
        if (object.messages !== undefined && object.messages !== null) {
            for (const e of object.messages) {
                message.messages.push(message_1.WakuMessage.fromJSON(e));
            }
        }
        if (object.pagingInfo !== undefined && object.pagingInfo !== null) {
            message.pagingInfo = exports.PagingInfo.fromJSON(object.pagingInfo);
        }
        else {
            message.pagingInfo = undefined;
        }
        if (object.error !== undefined && object.error !== null) {
            message.error = historyResponse_ErrorFromJSON(object.error);
        }
        else {
            message.error = 0;
        }
        return message;
    },
    toJSON(message) {
        const obj = {};
        if (message.messages) {
            obj.messages = message.messages.map((e) => e ? message_1.WakuMessage.toJSON(e) : undefined);
        }
        else {
            obj.messages = [];
        }
        message.pagingInfo !== undefined &&
            (obj.pagingInfo = message.pagingInfo
                ? exports.PagingInfo.toJSON(message.pagingInfo)
                : undefined);
        message.error !== undefined &&
            (obj.error = historyResponse_ErrorToJSON(message.error));
        return obj;
    },
    fromPartial(object) {
        const message = Object.assign({}, baseHistoryResponse);
        message.messages = [];
        if (object.messages !== undefined && object.messages !== null) {
            for (const e of object.messages) {
                message.messages.push(message_1.WakuMessage.fromPartial(e));
            }
        }
        if (object.pagingInfo !== undefined && object.pagingInfo !== null) {
            message.pagingInfo = exports.PagingInfo.fromPartial(object.pagingInfo);
        }
        else {
            message.pagingInfo = undefined;
        }
        if (object.error !== undefined && object.error !== null) {
            message.error = object.error;
        }
        else {
            message.error = 0;
        }
        return message;
    },
};
const baseHistoryRPC = { requestId: '' };
exports.HistoryRPC = {
    encode(message, writer = minimal_1.default.Writer.create()) {
        if (message.requestId !== '') {
            writer.uint32(10).string(message.requestId);
        }
        if (message.query !== undefined) {
            exports.HistoryQuery.encode(message.query, writer.uint32(18).fork()).ldelim();
        }
        if (message.response !== undefined) {
            exports.HistoryResponse.encode(message.response, writer.uint32(26).fork()).ldelim();
        }
        return writer;
    },
    decode(input, length) {
        const reader = input instanceof minimal_1.default.Reader ? input : new minimal_1.default.Reader(input);
        let end = length === undefined ? reader.len : reader.pos + length;
        const message = Object.assign({}, baseHistoryRPC);
        while (reader.pos < end) {
            const tag = reader.uint32();
            switch (tag >>> 3) {
                case 1:
                    message.requestId = reader.string();
                    break;
                case 2:
                    message.query = exports.HistoryQuery.decode(reader, reader.uint32());
                    break;
                case 3:
                    message.response = exports.HistoryResponse.decode(reader, reader.uint32());
                    break;
                default:
                    reader.skipType(tag & 7);
                    break;
            }
        }
        return message;
    },
    fromJSON(object) {
        const message = Object.assign({}, baseHistoryRPC);
        if (object.requestId !== undefined && object.requestId !== null) {
            message.requestId = String(object.requestId);
        }
        else {
            message.requestId = '';
        }
        if (object.query !== undefined && object.query !== null) {
            message.query = exports.HistoryQuery.fromJSON(object.query);
        }
        else {
            message.query = undefined;
        }
        if (object.response !== undefined && object.response !== null) {
            message.response = exports.HistoryResponse.fromJSON(object.response);
        }
        else {
            message.response = undefined;
        }
        return message;
    },
    toJSON(message) {
        const obj = {};
        message.requestId !== undefined && (obj.requestId = message.requestId);
        message.query !== undefined &&
            (obj.query = message.query
                ? exports.HistoryQuery.toJSON(message.query)
                : undefined);
        message.response !== undefined &&
            (obj.response = message.response
                ? exports.HistoryResponse.toJSON(message.response)
                : undefined);
        return obj;
    },
    fromPartial(object) {
        const message = Object.assign({}, baseHistoryRPC);
        if (object.requestId !== undefined && object.requestId !== null) {
            message.requestId = object.requestId;
        }
        else {
            message.requestId = '';
        }
        if (object.query !== undefined && object.query !== null) {
            message.query = exports.HistoryQuery.fromPartial(object.query);
        }
        else {
            message.query = undefined;
        }
        if (object.response !== undefined && object.response !== null) {
            message.response = exports.HistoryResponse.fromPartial(object.response);
        }
        else {
            message.response = undefined;
        }
        return message;
    },
};
var globalThis = (() => {
    if (typeof globalThis !== 'undefined')
        return globalThis;
    if (typeof self !== 'undefined')
        return self;
    if (typeof window !== 'undefined')
        return window;
    if (typeof global !== 'undefined')
        return global;
    throw 'Unable to locate global object';
})();
const atob = globalThis.atob ||
    ((b64) => globalThis.Buffer.from(b64, 'base64').toString('binary'));
function bytesFromBase64(b64) {
    const bin = atob(b64);
    const arr = new Uint8Array(bin.length);
    for (let i = 0; i < bin.length; ++i) {
        arr[i] = bin.charCodeAt(i);
    }
    return arr;
}
const btoa = globalThis.btoa ||
    ((bin) => globalThis.Buffer.from(bin, 'binary').toString('base64'));
function base64FromBytes(arr) {
    const bin = [];
    for (const byte of arr) {
        bin.push(String.fromCharCode(byte));
    }
    return btoa(bin.join(''));
}
function longToNumber(long) {
    if (long.gt(Number.MAX_SAFE_INTEGER)) {
        throw new globalThis.Error('Value is larger than Number.MAX_SAFE_INTEGER');
    }
    return long.toNumber();
}
if (minimal_1.default.util.Long !== long_1.default) {
    minimal_1.default.util.Long = long_1.default;
    minimal_1.default.configure();
}
//# sourceMappingURL=store.js.map