{"version":3,"file":"ValidationEnhancer.js","sourceRoot":"","sources":["../../src/enhancers/ValidationEnhancer.ts"],"names":[],"mappings":"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","sourcesContent":["// Copyright (c) Microsoft Corporation. All rights reserved. Licensed under the MIT license.\r\n// See LICENSE in the project root for license information.\r\n\r\nimport * as path from 'path';\r\nimport * as ts from 'typescript';\r\n\r\nimport { Collector } from '../collector/Collector';\r\nimport { AstSymbol } from '../analyzer/AstSymbol';\r\nimport { AstDeclaration } from '../analyzer/AstDeclaration';\r\nimport { ApiItemMetadata } from '../collector/ApiItemMetadata';\r\nimport { SymbolMetadata } from '../collector/SymbolMetadata';\r\nimport { CollectorEntity } from '../collector/CollectorEntity';\r\nimport { ExtractorMessageId } from '../api/ExtractorMessageId';\r\nimport { ReleaseTag } from '@microsoft/api-extractor-model';\r\nimport { AstNamespaceImport } from '../analyzer/AstNamespaceImport';\r\nimport { AstModuleExportInfo } from '../analyzer/AstModule';\r\nimport { AstEntity } from '../analyzer/AstEntity';\r\n\r\nexport class ValidationEnhancer {\r\n  public static analyze(collector: Collector): void {\r\n    const alreadyWarnedEntities: Set<AstEntity> = new Set<AstEntity>();\r\n\r\n    for (const entity of collector.entities) {\r\n      if (!entity.consumable) {\r\n        continue;\r\n      }\r\n\r\n      if (entity.astEntity instanceof AstSymbol) {\r\n        // A regular exported AstSymbol\r\n\r\n        const astSymbol: AstSymbol = entity.astEntity;\r\n\r\n        astSymbol.forEachDeclarationRecursive((astDeclaration: AstDeclaration) => {\r\n          ValidationEnhancer._checkReferences(collector, astDeclaration, alreadyWarnedEntities);\r\n        });\r\n\r\n        const symbolMetadata: SymbolMetadata = collector.fetchSymbolMetadata(astSymbol);\r\n        ValidationEnhancer._checkForInternalUnderscore(collector, entity, astSymbol, symbolMetadata);\r\n        ValidationEnhancer._checkForInconsistentReleaseTags(collector, astSymbol, symbolMetadata);\r\n      } else if (entity.astEntity instanceof AstNamespaceImport) {\r\n        // A namespace created using \"import * as ___ from ___\"\r\n        const astNamespaceImport: AstNamespaceImport = entity.astEntity;\r\n\r\n        const astModuleExportInfo: AstModuleExportInfo =\r\n          astNamespaceImport.fetchAstModuleExportInfo(collector);\r\n\r\n        for (const namespaceMemberAstEntity of astModuleExportInfo.exportedLocalEntities.values()) {\r\n          if (namespaceMemberAstEntity instanceof AstSymbol) {\r\n            const astSymbol: AstSymbol = namespaceMemberAstEntity;\r\n\r\n            astSymbol.forEachDeclarationRecursive((astDeclaration: AstDeclaration) => {\r\n              ValidationEnhancer._checkReferences(collector, astDeclaration, alreadyWarnedEntities);\r\n            });\r\n\r\n            const symbolMetadata: SymbolMetadata = collector.fetchSymbolMetadata(astSymbol);\r\n\r\n            // (Don't apply ValidationEnhancer._checkForInternalUnderscore() for AstNamespaceImport members)\r\n\r\n            ValidationEnhancer._checkForInconsistentReleaseTags(collector, astSymbol, symbolMetadata);\r\n          }\r\n        }\r\n      }\r\n    }\r\n  }\r\n\r\n  private static _checkForInternalUnderscore(\r\n    collector: Collector,\r\n    collectorEntity: CollectorEntity,\r\n    astSymbol: AstSymbol,\r\n    symbolMetadata: SymbolMetadata\r\n  ): void {\r\n    let needsUnderscore: boolean = false;\r\n\r\n    if (symbolMetadata.maxEffectiveReleaseTag === ReleaseTag.Internal) {\r\n      if (!astSymbol.parentAstSymbol) {\r\n        // If it's marked as @internal and has no parent, then it needs and underscore.\r\n        // We use maxEffectiveReleaseTag because a merged declaration would NOT need an underscore in a case like this:\r\n        //\r\n        //   /** @public */\r\n        //   export enum X { }\r\n        //\r\n        //   /** @internal */\r\n        //   export namespace X { }\r\n        //\r\n        // (The above normally reports an error \"ae-different-release-tags\", but that may be suppressed.)\r\n        needsUnderscore = true;\r\n      } else {\r\n        // If it's marked as @internal and the parent isn't obviously already @internal, then it needs an underscore.\r\n        //\r\n        // For example, we WOULD need an underscore for a merged declaration like this:\r\n        //\r\n        //   /** @internal */\r\n        //   export namespace X {\r\n        //     export interface _Y { }\r\n        //   }\r\n        //\r\n        //   /** @public */\r\n        //   export class X {\r\n        //     /** @internal */\r\n        //     public static _Y(): void { }   // <==== different from parent\r\n        //   }\r\n        const parentSymbolMetadata: SymbolMetadata = collector.fetchSymbolMetadata(astSymbol);\r\n        if (parentSymbolMetadata.maxEffectiveReleaseTag > ReleaseTag.Internal) {\r\n          needsUnderscore = true;\r\n        }\r\n      }\r\n    }\r\n\r\n    if (needsUnderscore) {\r\n      for (const exportName of collectorEntity.exportNames) {\r\n        if (exportName[0] !== '_') {\r\n          collector.messageRouter.addAnalyzerIssue(\r\n            ExtractorMessageId.InternalMissingUnderscore,\r\n            `The name \"${exportName}\" should be prefixed with an underscore` +\r\n              ` because the declaration is marked as @internal`,\r\n            astSymbol,\r\n            { exportName }\r\n          );\r\n        }\r\n      }\r\n    }\r\n  }\r\n\r\n  private static _checkForInconsistentReleaseTags(\r\n    collector: Collector,\r\n    astSymbol: AstSymbol,\r\n    symbolMetadata: SymbolMetadata\r\n  ): void {\r\n    if (astSymbol.isExternal) {\r\n      // For now, don't report errors for external code.  If the developer cares about it, they should run\r\n      // API Extractor separately on the external project\r\n      return;\r\n    }\r\n\r\n    // Normally we will expect all release tags to be the same.  Arbitrarily we choose the maxEffectiveReleaseTag\r\n    // as the thing they should all match.\r\n    const expectedEffectiveReleaseTag: ReleaseTag = symbolMetadata.maxEffectiveReleaseTag;\r\n\r\n    // This is set to true if we find a declaration whose release tag is different from expectedEffectiveReleaseTag\r\n    let mixedReleaseTags: boolean = false;\r\n\r\n    // This is set to false if we find a declaration that is not a function/method overload\r\n    let onlyFunctionOverloads: boolean = true;\r\n\r\n    // This is set to true if we find a declaration that is @internal\r\n    let anyInternalReleaseTags: boolean = false;\r\n\r\n    for (const astDeclaration of astSymbol.astDeclarations) {\r\n      const apiItemMetadata: ApiItemMetadata = collector.fetchApiItemMetadata(astDeclaration);\r\n      const effectiveReleaseTag: ReleaseTag = apiItemMetadata.effectiveReleaseTag;\r\n\r\n      switch (astDeclaration.declaration.kind) {\r\n        case ts.SyntaxKind.FunctionDeclaration:\r\n        case ts.SyntaxKind.MethodDeclaration:\r\n          break;\r\n        default:\r\n          onlyFunctionOverloads = false;\r\n      }\r\n\r\n      if (effectiveReleaseTag !== expectedEffectiveReleaseTag) {\r\n        mixedReleaseTags = true;\r\n      }\r\n\r\n      if (effectiveReleaseTag === ReleaseTag.Internal) {\r\n        anyInternalReleaseTags = true;\r\n      }\r\n    }\r\n\r\n    if (mixedReleaseTags) {\r\n      if (!onlyFunctionOverloads) {\r\n        collector.messageRouter.addAnalyzerIssue(\r\n          ExtractorMessageId.DifferentReleaseTags,\r\n          'This symbol has another declaration with a different release tag',\r\n          astSymbol\r\n        );\r\n      }\r\n\r\n      if (anyInternalReleaseTags) {\r\n        collector.messageRouter.addAnalyzerIssue(\r\n          ExtractorMessageId.InternalMixedReleaseTag,\r\n          `Mixed release tags are not allowed for \"${astSymbol.localName}\" because one of its declarations` +\r\n            ` is marked as @internal`,\r\n          astSymbol\r\n        );\r\n      }\r\n    }\r\n  }\r\n\r\n  private static _checkReferences(\r\n    collector: Collector,\r\n    astDeclaration: AstDeclaration,\r\n    alreadyWarnedEntities: Set<AstEntity>\r\n  ): void {\r\n    const apiItemMetadata: ApiItemMetadata = collector.fetchApiItemMetadata(astDeclaration);\r\n    const declarationReleaseTag: ReleaseTag = apiItemMetadata.effectiveReleaseTag;\r\n\r\n    for (const referencedEntity of astDeclaration.referencedAstEntities) {\r\n      let collectorEntity: CollectorEntity | undefined;\r\n      let referencedReleaseTag: ReleaseTag;\r\n      let localName: string;\r\n\r\n      if (referencedEntity instanceof AstSymbol) {\r\n        // If this is e.g. a member of a namespace, then we need to be checking the top-level scope to see\r\n        // whether it's exported.\r\n        //\r\n        // TODO: Technically we should also check each of the nested scopes along the way.\r\n        const rootSymbol: AstSymbol = referencedEntity.rootAstSymbol;\r\n\r\n        if (rootSymbol.isExternal) {\r\n          continue;\r\n        }\r\n\r\n        localName = rootSymbol.localName;\r\n\r\n        collectorEntity = collector.tryGetCollectorEntity(rootSymbol);\r\n\r\n        const referencedMetadata: SymbolMetadata = collector.fetchSymbolMetadata(referencedEntity);\r\n        referencedReleaseTag = referencedMetadata.maxEffectiveReleaseTag;\r\n      } else if (referencedEntity instanceof AstNamespaceImport) {\r\n        collectorEntity = collector.tryGetCollectorEntity(referencedEntity);\r\n\r\n        // TODO: Currently the \"import * as ___ from ___\" syntax does not yet support doc comments\r\n        referencedReleaseTag = ReleaseTag.Public;\r\n\r\n        localName = referencedEntity.localName;\r\n      } else {\r\n        continue;\r\n      }\r\n\r\n      if (collectorEntity && collectorEntity.consumable) {\r\n        if (ReleaseTag.compare(declarationReleaseTag, referencedReleaseTag) > 0) {\r\n          collector.messageRouter.addAnalyzerIssue(\r\n            ExtractorMessageId.IncompatibleReleaseTags,\r\n            `The symbol \"${astDeclaration.astSymbol.localName}\"` +\r\n              ` is marked as ${ReleaseTag.getTagName(declarationReleaseTag)},` +\r\n              ` but its signature references \"${referencedEntity.localName}\"` +\r\n              ` which is marked as ${ReleaseTag.getTagName(referencedReleaseTag)}`,\r\n            astDeclaration\r\n          );\r\n        }\r\n      } else {\r\n        const entryPointFilename: string = path.basename(\r\n          collector.workingPackage.entryPointSourceFile.fileName\r\n        );\r\n\r\n        if (!alreadyWarnedEntities.has(referencedEntity)) {\r\n          alreadyWarnedEntities.add(referencedEntity);\r\n\r\n          if (\r\n            referencedEntity instanceof AstSymbol &&\r\n            ValidationEnhancer._isEcmaScriptSymbol(referencedEntity)\r\n          ) {\r\n            // The main usage scenario for ECMAScript symbols is to attach private data to a JavaScript object,\r\n            // so as a special case, we do NOT report them as forgotten exports.\r\n          } else {\r\n            collector.messageRouter.addAnalyzerIssue(\r\n              ExtractorMessageId.ForgottenExport,\r\n              `The symbol \"${localName}\" needs to be exported by the entry point ${entryPointFilename}`,\r\n              astDeclaration\r\n            );\r\n          }\r\n        }\r\n      }\r\n    }\r\n  }\r\n\r\n  // Detect an AstSymbol that refers to an ECMAScript symbol declaration such as:\r\n  //\r\n  // const mySymbol: unique symbol = Symbol('mySymbol');\r\n  private static _isEcmaScriptSymbol(astSymbol: AstSymbol): boolean {\r\n    if (astSymbol.astDeclarations.length !== 1) {\r\n      return false;\r\n    }\r\n\r\n    // We are matching a form like this:\r\n    //\r\n    // - VariableDeclaration:\r\n    //   - Identifier:  pre=[mySymbol]\r\n    //   - ColonToken:  pre=[:] sep=[ ]\r\n    //   - TypeOperator:\r\n    //     - UniqueKeyword:  pre=[unique] sep=[ ]\r\n    //     - SymbolKeyword:  pre=[symbol]\r\n    const astDeclaration: AstDeclaration = astSymbol.astDeclarations[0];\r\n    if (ts.isVariableDeclaration(astDeclaration.declaration)) {\r\n      const variableTypeNode: ts.TypeNode | undefined = astDeclaration.declaration.type;\r\n      if (variableTypeNode) {\r\n        for (const token of variableTypeNode.getChildren()) {\r\n          if (token.kind === ts.SyntaxKind.SymbolKeyword) {\r\n            return true;\r\n          }\r\n        }\r\n      }\r\n    }\r\n\r\n    return false;\r\n  }\r\n}\r\n"]}