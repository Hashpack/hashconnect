"use strict";
var __importDefault = (this && this.__importDefault) || function (mod) {
    return (mod && mod.__esModule) ? mod : { "default": mod };
};
Object.defineProperty(exports, "__esModule", { value: true });
exports.WakuStore = exports.PageDirection = exports.DefaultPageSize = exports.StoreCodec = void 0;
const debug_1 = __importDefault(require("debug"));
const it_concat_1 = __importDefault(require("it-concat"));
const it_length_prefixed_1 = __importDefault(require("it-length-prefixed"));
const it_pipe_1 = __importDefault(require("it-pipe"));
const store_1 = require("../../proto/waku/v2/store");
const select_peer_1 = require("../select_peer");
const utils_1 = require("../utils");
const waku_1 = require("../waku");
const waku_message_1 = require("../waku_message");
const history_rpc_1 = require("./history_rpc");
Object.defineProperty(exports, "PageDirection", { enumerable: true, get: function () { return history_rpc_1.PageDirection; } });
const dbg = debug_1.default('waku:store');
exports.StoreCodec = '/vac/waku/store/2.0.0-beta3';
exports.DefaultPageSize = 10;
/**
 * Implements the [Waku v2 Store protocol](https://rfc.vac.dev/spec/13/).
 */
class WakuStore {
    constructor(libp2p, options) {
        this.libp2p = libp2p;
        if (options === null || options === void 0 ? void 0 : options.pubSubTopic) {
            this.pubSubTopic = options.pubSubTopic;
        }
        else {
            this.pubSubTopic = waku_1.DefaultPubSubTopic;
        }
        this.decryptionKeys = new Set();
    }
    /**
     * Do a History Query to a Waku Store.
     *
     * @param contentTopics The content topics to pass to the query, leave empty to
     * retrieve all messages.
     *
     * @throws If not able to reach a Waku Store peer to query
     * or if an error is encountered when processing the reply.
     */
    async queryHistory(contentTopics, options) {
        var _a, _b, _c, _d;
        let startTime, endTime;
        if (options === null || options === void 0 ? void 0 : options.timeFilter) {
            startTime = options.timeFilter.startTime.getTime() / 1000;
            endTime = options.timeFilter.endTime.getTime() / 1000;
        }
        const opts = Object.assign({
            pubSubTopic: this.pubSubTopic,
            pageDirection: history_rpc_1.PageDirection.BACKWARD,
            pageSize: exports.DefaultPageSize,
        }, options, {
            startTime,
            endTime,
        }, { contentTopics });
        dbg('Querying history with the following options', options);
        let peer;
        if (opts.peerId) {
            peer = this.libp2p.peerStore.get(opts.peerId);
            if (!peer)
                throw `Failed to retrieve connection details for provided peer in peer store: ${opts.peerId.toB58String()}`;
        }
        else {
            peer = this.randomPeer;
            if (!peer)
                throw 'Failed to find known peer that registers waku store protocol';
        }
        if (!peer.protocols.includes(exports.StoreCodec))
            throw `Peer does not register waku store protocol: ${peer.id.toB58String()}`;
        const connection = this.libp2p.connectionManager.get(peer.id);
        if (!connection)
            throw 'Failed to get a connection to the peer';
        const decryptionKeys = Array.from(this.decryptionKeys.values());
        if (opts.decryptionKeys) {
            opts.decryptionKeys.forEach((key) => {
                decryptionKeys.push(utils_1.hexToBuf(key));
            });
        }
        const messages = [];
        let cursor = undefined;
        while (true) {
            const { stream } = await connection.newStream(exports.StoreCodec);
            const queryOpts = Object.assign(opts, { cursor });
            const historyRpcQuery = history_rpc_1.HistoryRPC.createQuery(queryOpts);
            dbg('Querying store peer', connection.remoteAddr.toString());
            const res = await it_pipe_1.default([historyRpcQuery.encode()], it_length_prefixed_1.default.encode(), stream, it_length_prefixed_1.default.decode(), it_concat_1.default);
            const reply = history_rpc_1.HistoryRPC.decode(res.slice());
            const response = reply.response;
            if (!response) {
                throw 'History response misses response field';
            }
            if (response.error &&
                response.error === store_1.HistoryResponse_Error.ERROR_INVALID_CURSOR) {
                throw 'History response contains an Error: INVALID CURSOR';
            }
            if (!response.messages || !response.messages.length) {
                // No messages left (or stored)
                console.log('No messages present in HistoryRPC response');
                return messages;
            }
            dbg(`${response.messages.length} messages retrieved for pubsub topic ${opts.pubSubTopic}`);
            const pageMessages = [];
            await Promise.all(response.messages.map(async (protoMsg) => {
                const msg = await waku_message_1.WakuMessage.decodeProto(protoMsg, decryptionKeys);
                if (msg) {
                    messages.push(msg);
                    pageMessages.push(msg);
                }
            }));
            let abort = false;
            if (opts.callback) {
                abort = Boolean(opts.callback(pageMessages));
            }
            const responsePageSize = (_a = response.pagingInfo) === null || _a === void 0 ? void 0 : _a.pageSize;
            const queryPageSize = (_c = (_b = historyRpcQuery.query) === null || _b === void 0 ? void 0 : _b.pagingInfo) === null || _c === void 0 ? void 0 : _c.pageSize;
            if (abort ||
                // Response page size smaller than query, meaning this is the last page
                (responsePageSize && queryPageSize && responsePageSize < queryPageSize)) {
                return messages;
            }
            cursor = (_d = response.pagingInfo) === null || _d === void 0 ? void 0 : _d.cursor;
            if (cursor === undefined) {
                // If the server does not return cursor then there is an issue,
                // Need to abort or we end up in an infinite loop
                console.log('No cursor returned by peer.');
                return messages;
            }
        }
    }
    /**
     * Register a decryption key to attempt decryption of messages received in any
     * subsequent [[queryHistory]] call. This can either be a private key for
     * asymmetric encryption or a symmetric key. [[WakuStore]] will attempt to
     * decrypt messages using both methods.
     *
     * Strings must be in hex format.
     */
    addDecryptionKey(key) {
        this.decryptionKeys.add(utils_1.hexToBuf(key));
    }
    /**
     * Delete a decryption key that was used to attempt decryption of messages
     * received in subsequent [[queryHistory]] calls.
     *
     * Strings must be in hex format.
     */
    deleteDecryptionKey(key) {
        this.decryptionKeys.delete(utils_1.hexToBuf(key));
    }
    /**
     * Returns known peers from the address book (`libp2p.peerStore`) that support
     * store protocol. Waku may or  may not be currently connected to these peers.
     */
    get peers() {
        return select_peer_1.getPeersForProtocol(this.libp2p, exports.StoreCodec);
    }
    /**
     * Returns a random peer that supports store protocol from the address
     * book (`libp2p.peerStore`). Waku may or  may not be currently connected to
     * this peer.
     */
    get randomPeer() {
        return select_peer_1.selectRandomPeer(this.peers);
    }
}
exports.WakuStore = WakuStore;
//# sourceMappingURL=index.js.map