{"version":3,"file":"EnvironmentVariableParser.js","sourceRoot":"","sources":["../../src/parameters/EnvironmentVariableParser.ts"],"names":[],"mappings":";AAAA,4FAA4F;AAC5F,2DAA2D;;;AAE3D;;;;;GAKG;AACH,MAAa,yBAAyB;IAC7B,MAAM,CAAC,WAAW,CAAC,UAAkB;QAC1C,MAAM,gBAAgB,GAAuB,OAAO,CAAC,GAAG,CAAC,UAAU,CAAC,CAAC;QAErE,IAAI,gBAAgB,KAAK,SAAS,EAAE;YAClC,mEAAmE;YACnE,0FAA0F;YAE1F,IAAI,gBAAgB,CAAC,QAAQ,EAAE,CAAC,CAAC,CAAC,KAAK,GAAG,EAAE;gBAC1C,iGAAiG;gBACjG,2FAA2F;gBAC3F,iGAAiG;gBACjG,+FAA+F;gBAC/F,mGAAmG;gBACnG,+FAA+F;gBAC/F,2BAA2B;gBAC3B,IAAI;oBACF,MAAM,UAAU,GAAY,IAAI,CAAC,KAAK,CAAC,gBAAgB,CAAC,CAAC;oBACzD,IACE,CAAC,KAAK,CAAC,OAAO,CAAC,UAAU,CAAC;wBAC1B,CAAC,UAAU,CAAC,KAAK,CAAC,CAAC,CAAC,EAAE,EAAE,CAAC,OAAO,CAAC,KAAK,QAAQ,IAAI,OAAO,CAAC,KAAK,SAAS,IAAI,OAAO,CAAC,KAAK,QAAQ,CAAC,EAClG;wBACA,MAAM,IAAI,KAAK,CACb,OAAO,gBAAgB,6CAA6C;4BAClE,wDAAwD,CAC3D,CAAC;qBACH;oBACD,OAAO,UAAU,CAAC,GAAG,CAAC,CAAC,CAAC,EAAE,EAAE,CAAC,CAAC,CAAC,QAAQ,EAAE,CAAC,CAAC;iBAC5C;gBAAC,OAAO,EAAE,EAAE;oBACX,MAAM,IAAI,KAAK,CACb,OAAO,gBAAgB,qDAAqD;wBAC1E,wBAAwB;wBACxB,EAAE,CAAC,OAAO,CACb,CAAC;iBACH;aACF;iBAAM;gBACL,gGAAgG;gBAChG,gCAAgC;gBAChC,OAAO,CAAC,gBAAgB,CAAC,CAAC;aAC3B;SACF;QAED,OAAO,SAAS,CAAC;IACnB,CAAC;CACF;AA5CD,8DA4CC","sourcesContent":["// Copyright (c) Microsoft Corporation. All rights reserved. Licensed under the MIT license.\r\n// See LICENSE in the project root for license information.\r\n\r\n/**\r\n * Some parameter types can receive their values from an environment variable instead of\r\n * a command line argument. This class provides some utility methods for parsing environment\r\n * variable values.\r\n * @internal\r\n */\r\nexport class EnvironmentVariableParser {\r\n  public static parseAsList(envVarName: string): string[] | undefined {\r\n    const environmentValue: string | undefined = process.env[envVarName];\r\n\r\n    if (environmentValue !== undefined) {\r\n      // NOTE: If the environment variable is defined as an empty string,\r\n      // here we will accept the empty string as our value.  (For number/flag we don't do that.)\r\n\r\n      if (environmentValue.trimLeft()[0] === '[') {\r\n        // Specifying multiple items in an environment variable is a somewhat rare case.  But environment\r\n        // variables are actually a pretty reliable way for a tool to avoid shell escaping problems\r\n        // when spawning another tool.  For this case, we need a reliable way to pass an array of strings\r\n        // that could contain any character.  For example, if we simply used \";\" as the list delimiter,\r\n        // then what to do if a string contains that character?  We'd need to design an escaping mechanism.\r\n        // Since JSON is simple and standard and can escape every possible string, it's a better option\r\n        // than a custom delimiter.\r\n        try {\r\n          const parsedJson: unknown = JSON.parse(environmentValue);\r\n          if (\r\n            !Array.isArray(parsedJson) ||\r\n            !parsedJson.every((x) => typeof x === 'string' || typeof x === 'boolean' || typeof x === 'number')\r\n          ) {\r\n            throw new Error(\r\n              `The ${environmentValue} environment variable value must be a JSON ` +\r\n                ` array containing only strings, numbers, and booleans.`\r\n            );\r\n          }\r\n          return parsedJson.map((x) => x.toString());\r\n        } catch (ex) {\r\n          throw new Error(\r\n            `The ${environmentValue} environment variable value looks like a JSON array` +\r\n              ` but failed to parse: ` +\r\n              ex.message\r\n          );\r\n        }\r\n      } else {\r\n        // As a shorthand, a single value may be specified without JSON encoding, as long as it does not\r\n        // start with the \"[\" character.\r\n        return [environmentValue];\r\n      }\r\n    }\r\n\r\n    return undefined;\r\n  }\r\n}\r\n"]}