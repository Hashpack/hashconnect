{"version":3,"file":"AstNamespaceImport.js","sourceRoot":"","sources":["../../src/analyzer/AstNamespaceImport.ts"],"names":[],"mappings":";AAAA,4FAA4F;AAC5F,2DAA2D;;;AAK3D,2CAAiD;AASjD;;;;;;;;;;;;;;;;;;;;;;;;;;;;;GA6BG;AACH,MAAa,kBAAmB,SAAQ,8BAAkB;IAwBxD,YAAmB,OAAmC;QACpD,KAAK,EAAE,CAAC;QAxBV;;;WAGG;QACI,aAAQ,GAAY,KAAK,CAAC;QAqB/B,IAAI,CAAC,SAAS,GAAG,OAAO,CAAC,SAAS,CAAC;QACnC,IAAI,CAAC,aAAa,GAAG,OAAO,CAAC,aAAa,CAAC;QAC3C,IAAI,CAAC,WAAW,GAAG,OAAO,CAAC,WAAW,CAAC;IACzC,CAAC;IAED,oBAAoB;IACpB,IAAW,SAAS;QAClB,WAAW;QACX,OAAO,IAAI,CAAC,aAAa,CAAC;IAC5B,CAAC;IAEM,wBAAwB,CAAC,SAAoB;QAClD,MAAM,mBAAmB,GAAwB,SAAS,CAAC,cAAc,CAAC,wBAAwB,CAChG,IAAI,CAAC,SAAS,CACf,CAAC;QACF,OAAO,mBAAmB,CAAC;IAC7B,CAAC;CACF;AA3CD,gDA2CC","sourcesContent":["// Copyright (c) Microsoft Corporation. All rights reserved. Licensed under the MIT license.\r\n// See LICENSE in the project root for license information.\r\n\r\nimport * as ts from 'typescript';\r\n\r\nimport { AstModule, AstModuleExportInfo } from './AstModule';\r\nimport { AstSyntheticEntity } from './AstEntity';\r\nimport { Collector } from '../collector/Collector';\r\n\r\nexport interface IAstNamespaceImportOptions {\r\n  readonly astModule: AstModule;\r\n  readonly namespaceName: string;\r\n  readonly declaration: ts.Declaration;\r\n}\r\n\r\n/**\r\n * `AstNamespaceImport` represents a namespace that is created implicitly by a statement\r\n * such as `import * as example from \"./file\";`\r\n *\r\n * @remarks\r\n *\r\n * A typical input looks like this:\r\n * ```ts\r\n * // Suppose that example.ts exports two functions f1() and f2().\r\n * import * as example from \"./file\";\r\n * export { example };\r\n * ```\r\n *\r\n * API Extractor's .d.ts rollup will transform it into an explicit namespace, like this:\r\n * ```ts\r\n * declare f1(): void;\r\n * declare f2(): void;\r\n *\r\n * declare namespace example {\r\n *   export {\r\n *     f1,\r\n *     f2\r\n *   }\r\n * }\r\n * ```\r\n *\r\n * The current implementation does not attempt to relocate f1()/f2() to be inside the `namespace`\r\n * because other type signatures may reference them directly (without using the namespace qualifier).\r\n * The `declare namespace example` is a synthetic construct represented by `AstNamespaceImport`.\r\n */\r\nexport class AstNamespaceImport extends AstSyntheticEntity {\r\n  /**\r\n   * Returns true if the AstSymbolTable.analyze() was called for this object.\r\n   * See that function for details.\r\n   */\r\n  public analyzed: boolean = false;\r\n\r\n  /**\r\n   * For example, if the original statement was `import * as example from \"./file\";`\r\n   * then `astModule` refers to the `./file.d.ts` file.\r\n   */\r\n  public readonly astModule: AstModule;\r\n\r\n  /**\r\n   * For example, if the original statement was `import * as example from \"./file\";`\r\n   * then `namespaceName` would be `example`.\r\n   */\r\n  public readonly namespaceName: string;\r\n\r\n  /**\r\n   * The original `ts.SyntaxKind.NamespaceImport` which can be used as a location for error messages.\r\n   */\r\n  public readonly declaration: ts.Declaration;\r\n\r\n  public constructor(options: IAstNamespaceImportOptions) {\r\n    super();\r\n    this.astModule = options.astModule;\r\n    this.namespaceName = options.namespaceName;\r\n    this.declaration = options.declaration;\r\n  }\r\n\r\n  /** {@inheritdoc} */\r\n  public get localName(): string {\r\n    // abstract\r\n    return this.namespaceName;\r\n  }\r\n\r\n  public fetchAstModuleExportInfo(collector: Collector): AstModuleExportInfo {\r\n    const astModuleExportInfo: AstModuleExportInfo = collector.astSymbolTable.fetchAstModuleExportInfo(\r\n      this.astModule\r\n    );\r\n    return astModuleExportInfo;\r\n  }\r\n}\r\n"]}