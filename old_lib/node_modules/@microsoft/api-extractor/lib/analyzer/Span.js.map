{"version":3,"file":"Span.js","sourceRoot":"","sources":["../../src/analyzer/Span.ts"],"names":[],"mappings":"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","sourcesContent":["// Copyright (c) Microsoft Corporation. All rights reserved. Licensed under the MIT license.\r\n// See LICENSE in the project root for license information.\r\n\r\nimport * as ts from 'typescript';\r\nimport { InternalError, Sort } from '@rushstack/node-core-library';\r\n\r\nimport { IndentedWriter } from '../generators/IndentedWriter';\r\n\r\ninterface IWriteModifiedTextOptions {\r\n  writer: IndentedWriter;\r\n  separatorOverride: string | undefined;\r\n  indentDocCommentState: IndentDocCommentState;\r\n}\r\n\r\nenum IndentDocCommentState {\r\n  /**\r\n   * `indentDocComment` was not requested for this subtree.\r\n   */\r\n  Inactive = 0,\r\n  /**\r\n   * `indentDocComment` was requested and we are looking for the opening `/` `*`\r\n   */\r\n  AwaitingOpenDelimiter = 1,\r\n  /**\r\n   * `indentDocComment` was requested and we are looking for the closing `*` `/`\r\n   */\r\n  AwaitingCloseDelimiter = 2,\r\n  /**\r\n   * `indentDocComment` was requested and we have finished indenting the comment.\r\n   */\r\n  Done = 3\r\n}\r\n\r\n/**\r\n * Choices for SpanModification.indentDocComment.\r\n */\r\nexport enum IndentDocCommentScope {\r\n  /**\r\n   * Do not detect and indent comments.\r\n   */\r\n  None = 0,\r\n\r\n  /**\r\n   * Look for one doc comment in the {@link Span.prefix} text only.\r\n   */\r\n  PrefixOnly = 1,\r\n\r\n  /**\r\n   * Look for one doc comment potentially distributed across the Span and its children.\r\n   */\r\n  SpanAndChildren = 2\r\n}\r\n\r\n/**\r\n * Specifies various transformations that will be performed by Span.getModifiedText().\r\n */\r\nexport class SpanModification {\r\n  /**\r\n   * If true, all of the child spans will be omitted from the Span.getModifiedText() output.\r\n   * @remarks\r\n   * Also, the modify() operation will not recurse into these spans.\r\n   */\r\n  public omitChildren: boolean = false;\r\n\r\n  /**\r\n   * If true, then the Span.separator will be removed from the Span.getModifiedText() output.\r\n   */\r\n  public omitSeparatorAfter: boolean = false;\r\n\r\n  /**\r\n   * If true, then Span.getModifiedText() will sort the immediate children according to their Span.sortKey\r\n   * property.  The separators will also be fixed up to ensure correct indentation.  If the Span.sortKey is undefined\r\n   * for some items, those items will not be moved, i.e. their array indexes will be unchanged.\r\n   */\r\n  public sortChildren: boolean = false;\r\n\r\n  /**\r\n   * Used if the parent span has Span.sortChildren=true.\r\n   */\r\n  public sortKey: string | undefined;\r\n\r\n  /**\r\n   * Optionally configures getModifiedText() to search for a \"/*\" doc comment and indent it.\r\n   * At most one comment is detected.\r\n   *\r\n   * @remarks\r\n   * The indentation can be applied to the `Span.modifier.prefix` only, or it can be applied to the\r\n   * full subtree of nodes (as needed for `ts.SyntaxKind.JSDocComment` trees).  However the enabled\r\n   * scopes must not overlap.\r\n   *\r\n   * This feature is enabled selectively because (1) we do not want to accidentally match `/*` appearing\r\n   * in a string literal or other expression that is not a comment, and (2) parsing comments is relatively\r\n   * expensive.\r\n   */\r\n  public indentDocComment: IndentDocCommentScope = IndentDocCommentScope.None;\r\n\r\n  private readonly _span: Span;\r\n  private _prefix: string | undefined;\r\n  private _suffix: string | undefined;\r\n\r\n  public constructor(span: Span) {\r\n    this._span = span;\r\n    this.reset();\r\n  }\r\n\r\n  /**\r\n   * Allows the Span.prefix text to be changed.\r\n   */\r\n  public get prefix(): string {\r\n    return this._prefix !== undefined ? this._prefix : this._span.prefix;\r\n  }\r\n\r\n  public set prefix(value: string) {\r\n    this._prefix = value;\r\n  }\r\n\r\n  /**\r\n   * Allows the Span.suffix text to be changed.\r\n   */\r\n  public get suffix(): string {\r\n    return this._suffix !== undefined ? this._suffix : this._span.suffix;\r\n  }\r\n\r\n  public set suffix(value: string) {\r\n    this._suffix = value;\r\n  }\r\n\r\n  /**\r\n   * Reverts any modifications made to this object.\r\n   */\r\n  public reset(): void {\r\n    this.omitChildren = false;\r\n    this.omitSeparatorAfter = false;\r\n    this.sortChildren = false;\r\n    this.sortKey = undefined;\r\n    this._prefix = undefined;\r\n    this._suffix = undefined;\r\n    if (this._span.kind === ts.SyntaxKind.JSDocComment) {\r\n      this.indentDocComment = IndentDocCommentScope.SpanAndChildren;\r\n    }\r\n  }\r\n\r\n  /**\r\n   * Effectively deletes the Span from the tree, by skipping its children, skipping its separator,\r\n   * and setting its prefix/suffix to the empty string.\r\n   */\r\n  public skipAll(): void {\r\n    this.prefix = '';\r\n    this.suffix = '';\r\n    this.omitChildren = true;\r\n    this.omitSeparatorAfter = true;\r\n  }\r\n}\r\n\r\n/**\r\n * The Span class provides a simple way to rewrite TypeScript source files\r\n * based on simple syntax transformations, i.e. without having to process deeper aspects\r\n * of the underlying grammar.  An example transformation might be deleting JSDoc comments\r\n * from a source file.\r\n *\r\n * @remarks\r\n * TypeScript's abstract syntax tree (AST) is represented using Node objects.\r\n * The Node text ignores its surrounding whitespace, and does not have an ordering guarantee.\r\n * For example, a JSDocComment node can be a child of a FunctionDeclaration node, even though\r\n * the actual comment precedes the function in the input stream.\r\n *\r\n * The Span class is a wrapper for a single Node, that provides access to every character\r\n * in the input stream, such that Span.getText() will exactly reproduce the corresponding\r\n * full Node.getText() output.\r\n *\r\n * A Span is comprised of these parts, which appear in sequential order:\r\n * - A prefix\r\n * - A collection of child spans\r\n * - A suffix\r\n * - A separator (e.g. whitespace between this span and the next item in the tree)\r\n *\r\n * These parts can be modified via Span.modification.  The modification is applied by\r\n * calling Span.getModifiedText().\r\n */\r\nexport class Span {\r\n  public readonly node: ts.Node;\r\n\r\n  // To improve performance, substrings are not allocated until actually needed\r\n  public readonly startIndex: number;\r\n  public readonly endIndex: number;\r\n\r\n  public readonly children: Span[];\r\n\r\n  public readonly modification: SpanModification;\r\n\r\n  private _parent: Span | undefined;\r\n  private _previousSibling: Span | undefined;\r\n  private _nextSibling: Span | undefined;\r\n\r\n  private _separatorStartIndex: number;\r\n  private _separatorEndIndex: number;\r\n\r\n  public constructor(node: ts.Node) {\r\n    this.node = node;\r\n    this.startIndex = node.kind === ts.SyntaxKind.SourceFile ? node.getFullStart() : node.getStart();\r\n    this.endIndex = node.end;\r\n    this._separatorStartIndex = 0;\r\n    this._separatorEndIndex = 0;\r\n    this.children = [];\r\n    this.modification = new SpanModification(this);\r\n\r\n    let previousChildSpan: Span | undefined = undefined;\r\n\r\n    for (const childNode of this.node.getChildren() || []) {\r\n      const childSpan: Span = new Span(childNode);\r\n      childSpan._parent = this;\r\n      childSpan._previousSibling = previousChildSpan;\r\n\r\n      if (previousChildSpan) {\r\n        previousChildSpan._nextSibling = childSpan;\r\n      }\r\n\r\n      this.children.push(childSpan);\r\n\r\n      // Normalize the bounds so that a child is never outside its parent\r\n      if (childSpan.startIndex < this.startIndex) {\r\n        this.startIndex = childSpan.startIndex;\r\n      }\r\n\r\n      if (childSpan.endIndex > this.endIndex) {\r\n        // This has never been observed empirically, but here's how we would handle it\r\n        this.endIndex = childSpan.endIndex;\r\n        throw new InternalError('Unexpected AST case');\r\n      }\r\n\r\n      if (previousChildSpan) {\r\n        if (previousChildSpan.endIndex < childSpan.startIndex) {\r\n          // There is some leftover text after previous child -- assign it as the separator for\r\n          // the preceding span.  If the preceding span has no suffix, then assign it to the\r\n          // deepest preceding span with no suffix.  This heuristic simplifies the most\r\n          // common transformations, and otherwise it can be fished out using getLastInnerSeparator().\r\n          let separatorRecipient: Span = previousChildSpan;\r\n          while (separatorRecipient.children.length > 0) {\r\n            const lastChild: Span = separatorRecipient.children[separatorRecipient.children.length - 1];\r\n            if (lastChild.endIndex !== separatorRecipient.endIndex) {\r\n              // There is a suffix, so we cannot push the separator any further down, or else\r\n              // it would get printed before this suffix.\r\n              break;\r\n            }\r\n            separatorRecipient = lastChild;\r\n          }\r\n          separatorRecipient._separatorStartIndex = previousChildSpan.endIndex;\r\n          separatorRecipient._separatorEndIndex = childSpan.startIndex;\r\n        }\r\n      }\r\n\r\n      previousChildSpan = childSpan;\r\n    }\r\n  }\r\n\r\n  public get kind(): ts.SyntaxKind {\r\n    return this.node.kind;\r\n  }\r\n\r\n  /**\r\n   * The parent Span, if any.\r\n   * NOTE: This will be undefined for a root Span, even though the corresponding Node\r\n   * may have a parent in the AST.\r\n   */\r\n  public get parent(): Span | undefined {\r\n    return this._parent;\r\n  }\r\n\r\n  /**\r\n   * If the current object is this.parent.children[i], then previousSibling corresponds\r\n   * to this.parent.children[i-1] if it exists.\r\n   * NOTE: This will be undefined for a root Span, even though the corresponding Node\r\n   * may have a previous sibling in the AST.\r\n   */\r\n  public get previousSibling(): Span | undefined {\r\n    return this._previousSibling;\r\n  }\r\n\r\n  /**\r\n   * If the current object is this.parent.children[i], then previousSibling corresponds\r\n   * to this.parent.children[i+1] if it exists.\r\n   * NOTE: This will be undefined for a root Span, even though the corresponding Node\r\n   * may have a previous sibling in the AST.\r\n   */\r\n  public get nextSibling(): Span | undefined {\r\n    return this._nextSibling;\r\n  }\r\n\r\n  /**\r\n   * The text associated with the underlying Node, up to its first child.\r\n   */\r\n  public get prefix(): string {\r\n    if (this.children.length) {\r\n      // Everything up to the first child\r\n      return this._getSubstring(this.startIndex, this.children[0].startIndex);\r\n    } else {\r\n      return this._getSubstring(this.startIndex, this.endIndex);\r\n    }\r\n  }\r\n\r\n  /**\r\n   * The text associated with the underlying Node, after its last child.\r\n   * If there are no children, this is always an empty string.\r\n   */\r\n  public get suffix(): string {\r\n    if (this.children.length) {\r\n      // Everything after the last child\r\n      return this._getSubstring(this.children[this.children.length - 1].endIndex, this.endIndex);\r\n    } else {\r\n      return '';\r\n    }\r\n  }\r\n\r\n  /**\r\n   * Whitespace that appeared after this node, and before the \"next\" node in the tree.\r\n   * Here we mean \"next\" according to an inorder traversal, not necessarily a sibling.\r\n   */\r\n  public get separator(): string {\r\n    return this._getSubstring(this._separatorStartIndex, this._separatorEndIndex);\r\n  }\r\n\r\n  /**\r\n   * Returns the separator of this Span, or else recursively calls getLastInnerSeparator()\r\n   * on the last child.\r\n   */\r\n  public getLastInnerSeparator(): string {\r\n    if (this.separator) {\r\n      return this.separator;\r\n    }\r\n    if (this.children.length > 0) {\r\n      return this.children[this.children.length - 1].getLastInnerSeparator();\r\n    }\r\n    return '';\r\n  }\r\n\r\n  /**\r\n   * Returns the first parent node with the specified  SyntaxKind, or undefined if there is no match.\r\n   */\r\n  public findFirstParent(kindToMatch: ts.SyntaxKind): Span | undefined {\r\n    let current: Span | undefined = this;\r\n\r\n    while (current) {\r\n      if (current.kind === kindToMatch) {\r\n        return current;\r\n      }\r\n      current = current.parent;\r\n    }\r\n\r\n    return undefined;\r\n  }\r\n\r\n  /**\r\n   * Recursively invokes the callback on this Span and all its children.  The callback\r\n   * can make changes to Span.modification for each node.\r\n   */\r\n  public forEach(callback: (span: Span) => void): void {\r\n    callback(this);\r\n    for (const child of this.children) {\r\n      child.forEach(callback);\r\n    }\r\n  }\r\n\r\n  /**\r\n   * Returns the original unmodified text represented by this Span.\r\n   */\r\n  public getText(): string {\r\n    let result: string = '';\r\n    result += this.prefix;\r\n\r\n    for (const child of this.children) {\r\n      result += child.getText();\r\n    }\r\n\r\n    result += this.suffix;\r\n    result += this.separator;\r\n\r\n    return result;\r\n  }\r\n\r\n  /**\r\n   * Returns the text represented by this Span, after applying all requested modifications.\r\n   */\r\n  public getModifiedText(): string {\r\n    const writer: IndentedWriter = new IndentedWriter();\r\n    writer.trimLeadingSpaces = true;\r\n\r\n    this._writeModifiedText({\r\n      writer: writer,\r\n      separatorOverride: undefined,\r\n      indentDocCommentState: IndentDocCommentState.Inactive\r\n    });\r\n\r\n    return writer.getText();\r\n  }\r\n\r\n  public writeModifiedText(output: IndentedWriter): void {\r\n    this._writeModifiedText({\r\n      writer: output,\r\n      separatorOverride: undefined,\r\n      indentDocCommentState: IndentDocCommentState.Inactive\r\n    });\r\n  }\r\n\r\n  /**\r\n   * Returns a diagnostic dump of the tree, showing the prefix/suffix/separator for\r\n   * each node.\r\n   */\r\n  public getDump(indent: string = ''): string {\r\n    let result: string = indent + ts.SyntaxKind[this.node.kind] + ': ';\r\n\r\n    if (this.prefix) {\r\n      result += ' pre=[' + this._getTrimmed(this.prefix) + ']';\r\n    }\r\n    if (this.suffix) {\r\n      result += ' suf=[' + this._getTrimmed(this.suffix) + ']';\r\n    }\r\n    if (this.separator) {\r\n      result += ' sep=[' + this._getTrimmed(this.separator) + ']';\r\n    }\r\n    result += '\\n';\r\n\r\n    for (const child of this.children) {\r\n      result += child.getDump(indent + '  ');\r\n    }\r\n\r\n    return result;\r\n  }\r\n\r\n  /**\r\n   * Returns a diagnostic dump of the tree, showing the SpanModification settings for each nodde.\r\n   */\r\n  public getModifiedDump(indent: string = ''): string {\r\n    let result: string = indent + ts.SyntaxKind[this.node.kind] + ': ';\r\n\r\n    if (this.prefix) {\r\n      result += ' pre=[' + this._getTrimmed(this.modification.prefix) + ']';\r\n    }\r\n    if (this.suffix) {\r\n      result += ' suf=[' + this._getTrimmed(this.modification.suffix) + ']';\r\n    }\r\n    if (this.separator) {\r\n      result += ' sep=[' + this._getTrimmed(this.separator) + ']';\r\n    }\r\n    if (this.modification.indentDocComment !== IndentDocCommentScope.None) {\r\n      result += ' indentDocComment=' + IndentDocCommentScope[this.modification.indentDocComment];\r\n    }\r\n    if (this.modification.omitChildren) {\r\n      result += ' omitChildren';\r\n    }\r\n    if (this.modification.omitSeparatorAfter) {\r\n      result += ' omitSeparatorAfter';\r\n    }\r\n    if (this.modification.sortChildren) {\r\n      result += ' sortChildren';\r\n    }\r\n    if (this.modification.sortKey !== undefined) {\r\n      result += ` sortKey=\"${this.modification.sortKey}\"`;\r\n    }\r\n    result += '\\n';\r\n\r\n    if (!this.modification.omitChildren) {\r\n      for (const child of this.children) {\r\n        result += child.getModifiedDump(indent + '  ');\r\n      }\r\n    } else {\r\n      result += `${indent}  (${this.children.length} children)\\n`;\r\n    }\r\n\r\n    return result;\r\n  }\r\n\r\n  /**\r\n   * Recursive implementation of `getModifiedText()` and `writeModifiedText()`.\r\n   */\r\n  private _writeModifiedText(options: IWriteModifiedTextOptions): void {\r\n    // Apply indentation based on \"{\" and \"}\"\r\n    if (this.prefix === '{') {\r\n      options.writer.increaseIndent();\r\n    } else if (this.prefix === '}') {\r\n      options.writer.decreaseIndent();\r\n    }\r\n\r\n    if (this.modification.indentDocComment !== IndentDocCommentScope.None) {\r\n      this._beginIndentDocComment(options);\r\n    }\r\n\r\n    this._write(this.modification.prefix, options);\r\n\r\n    if (this.modification.indentDocComment === IndentDocCommentScope.PrefixOnly) {\r\n      this._endIndentDocComment(options);\r\n    }\r\n\r\n    let sortedSubset: Span[] | undefined;\r\n\r\n    if (!this.modification.omitChildren) {\r\n      if (this.modification.sortChildren) {\r\n        // We will only sort the items with a sortKey\r\n        const filtered: Span[] = this.children.filter((x) => x.modification.sortKey !== undefined);\r\n\r\n        // Is there at least one of them?\r\n        if (filtered.length > 1) {\r\n          sortedSubset = filtered;\r\n        }\r\n      }\r\n    }\r\n\r\n    if (sortedSubset) {\r\n      // This is the complicated special case that sorts an arbitrary subset of the child nodes,\r\n      // preserving the surrounding nodes.\r\n\r\n      const sortedSubsetCount: number = sortedSubset.length;\r\n      // Remember the separator for the first and last ones\r\n      const firstSeparator: string = sortedSubset[0].getLastInnerSeparator();\r\n      const lastSeparator: string = sortedSubset[sortedSubsetCount - 1].getLastInnerSeparator();\r\n\r\n      Sort.sortBy(sortedSubset, (x) => x.modification.sortKey);\r\n\r\n      const childOptions: IWriteModifiedTextOptions = { ...options };\r\n\r\n      let sortedSubsetIndex: number = 0;\r\n      for (let index: number = 0; index < this.children.length; ++index) {\r\n        let current: Span;\r\n\r\n        // Is this an item that we sorted?\r\n        if (this.children[index].modification.sortKey === undefined) {\r\n          // No, take the next item from the original array\r\n          current = this.children[index];\r\n          childOptions.separatorOverride = undefined;\r\n        } else {\r\n          // Yes, take the next item from the sortedSubset\r\n          current = sortedSubset[sortedSubsetIndex++];\r\n\r\n          if (sortedSubsetIndex < sortedSubsetCount) {\r\n            childOptions.separatorOverride = firstSeparator;\r\n          } else {\r\n            childOptions.separatorOverride = lastSeparator;\r\n          }\r\n        }\r\n\r\n        current._writeModifiedText(childOptions);\r\n      }\r\n    } else {\r\n      // This is the normal case that does not need to sort children\r\n      const childrenLength: number = this.children.length;\r\n\r\n      if (!this.modification.omitChildren) {\r\n        if (options.separatorOverride !== undefined) {\r\n          // Special case where the separatorOverride is passed down to the \"last inner separator\" span\r\n          for (let i: number = 0; i < childrenLength; ++i) {\r\n            const child: Span = this.children[i];\r\n\r\n            if (\r\n              // Only the last child inherits the separatorOverride, because only it can contain\r\n              // the \"last inner separator\" span\r\n              i < childrenLength - 1 ||\r\n              // If this.separator is specified, then we will write separatorOverride below, so don't pass it along\r\n              this.separator\r\n            ) {\r\n              const childOptions: IWriteModifiedTextOptions = { ...options };\r\n              childOptions.separatorOverride = undefined;\r\n              child._writeModifiedText(childOptions);\r\n            } else {\r\n              child._writeModifiedText(options);\r\n            }\r\n          }\r\n        } else {\r\n          // The normal simple case\r\n          for (const child of this.children) {\r\n            child._writeModifiedText(options);\r\n          }\r\n        }\r\n      }\r\n\r\n      this._write(this.modification.suffix, options);\r\n\r\n      if (options.separatorOverride !== undefined) {\r\n        if (this.separator || childrenLength === 0) {\r\n          this._write(options.separatorOverride, options);\r\n        }\r\n      } else {\r\n        if (!this.modification.omitSeparatorAfter) {\r\n          this._write(this.separator, options);\r\n        }\r\n      }\r\n    }\r\n\r\n    if (this.modification.indentDocComment === IndentDocCommentScope.SpanAndChildren) {\r\n      this._endIndentDocComment(options);\r\n    }\r\n  }\r\n\r\n  private _beginIndentDocComment(options: IWriteModifiedTextOptions): void {\r\n    if (options.indentDocCommentState !== IndentDocCommentState.Inactive) {\r\n      throw new InternalError('indentDocComment cannot be nested');\r\n    }\r\n    options.indentDocCommentState = IndentDocCommentState.AwaitingOpenDelimiter;\r\n  }\r\n\r\n  private _endIndentDocComment(options: IWriteModifiedTextOptions): void {\r\n    if (options.indentDocCommentState === IndentDocCommentState.AwaitingCloseDelimiter) {\r\n      throw new InternalError('missing \"*/\" delimiter for comment block');\r\n    }\r\n    options.indentDocCommentState = IndentDocCommentState.Inactive;\r\n  }\r\n\r\n  /**\r\n   * Writes one chunk of `text` to the `options.writer`, applying the `indentDocComment` rewriting.\r\n   */\r\n  private _write(text: string, options: IWriteModifiedTextOptions): void {\r\n    let parsedText: string = text;\r\n\r\n    if (options.indentDocCommentState === IndentDocCommentState.AwaitingOpenDelimiter) {\r\n      let index: number = parsedText.indexOf('/*');\r\n      if (index >= 0) {\r\n        index += '/*'.length;\r\n        options.writer.write(parsedText.substring(0, index));\r\n        parsedText = parsedText.substring(index);\r\n        options.indentDocCommentState = IndentDocCommentState.AwaitingCloseDelimiter;\r\n\r\n        options.writer.increaseIndent(' ');\r\n      }\r\n    }\r\n\r\n    if (options.indentDocCommentState === IndentDocCommentState.AwaitingCloseDelimiter) {\r\n      let index: number = parsedText.indexOf('*/');\r\n      if (index >= 0) {\r\n        index += '*/'.length;\r\n        options.writer.write(parsedText.substring(0, index));\r\n        parsedText = parsedText.substring(index);\r\n        options.indentDocCommentState = IndentDocCommentState.Done;\r\n\r\n        options.writer.decreaseIndent();\r\n      }\r\n    }\r\n\r\n    options.writer.write(parsedText);\r\n  }\r\n\r\n  private _getTrimmed(text: string): string {\r\n    const trimmed: string = text.replace(/\\r?\\n/g, '\\\\n');\r\n\r\n    if (trimmed.length > 100) {\r\n      return trimmed.substr(0, 97) + '...';\r\n    }\r\n    return trimmed;\r\n  }\r\n\r\n  private _getSubstring(startIndex: number, endIndex: number): string {\r\n    if (startIndex === endIndex) {\r\n      return '';\r\n    }\r\n    return this.node.getSourceFile().text.substring(startIndex, endIndex);\r\n  }\r\n}\r\n"]}