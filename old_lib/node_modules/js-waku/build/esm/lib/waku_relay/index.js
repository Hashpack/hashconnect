var __extends = (this && this.__extends) || (function () {
    var extendStatics = function (d, b) {
        extendStatics = Object.setPrototypeOf ||
            ({ __proto__: [] } instanceof Array && function (d, b) { d.__proto__ = b; }) ||
            function (d, b) { for (var p in b) if (Object.prototype.hasOwnProperty.call(b, p)) d[p] = b[p]; };
        return extendStatics(d, b);
    };
    return function (d, b) {
        if (typeof b !== "function" && b !== null)
            throw new TypeError("Class extends value " + String(b) + " is not a constructor or null");
        extendStatics(d, b);
        function __() { this.constructor = d; }
        d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
    };
})();
var __awaiter = (this && this.__awaiter) || function (thisArg, _arguments, P, generator) {
    function adopt(value) { return value instanceof P ? value : new P(function (resolve) { resolve(value); }); }
    return new (P || (P = Promise))(function (resolve, reject) {
        function fulfilled(value) { try { step(generator.next(value)); } catch (e) { reject(e); } }
        function rejected(value) { try { step(generator["throw"](value)); } catch (e) { reject(e); } }
        function step(result) { result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected); }
        step((generator = generator.apply(thisArg, _arguments || [])).next());
    });
};
var __generator = (this && this.__generator) || function (thisArg, body) {
    var _ = { label: 0, sent: function() { if (t[0] & 1) throw t[1]; return t[1]; }, trys: [], ops: [] }, f, y, t, g;
    return g = { next: verb(0), "throw": verb(1), "return": verb(2) }, typeof Symbol === "function" && (g[Symbol.iterator] = function() { return this; }), g;
    function verb(n) { return function (v) { return step([n, v]); }; }
    function step(op) {
        if (f) throw new TypeError("Generator is already executing.");
        while (_) try {
            if (f = 1, y && (t = op[0] & 2 ? y["return"] : op[0] ? y["throw"] || ((t = y["return"]) && t.call(y), 0) : y.next) && !(t = t.call(y, op[1])).done) return t;
            if (y = 0, t) op = [op[0] & 2, t.value];
            switch (op[0]) {
                case 0: case 1: t = op; break;
                case 4: _.label++; return { value: op[1], done: false };
                case 5: _.label++; y = op[1]; op = [0]; continue;
                case 7: op = _.ops.pop(); _.trys.pop(); continue;
                default:
                    if (!(t = _.trys, t = t.length > 0 && t[t.length - 1]) && (op[0] === 6 || op[0] === 2)) { _ = 0; continue; }
                    if (op[0] === 3 && (!t || (op[1] > t[0] && op[1] < t[3]))) { _.label = op[1]; break; }
                    if (op[0] === 6 && _.label < t[1]) { _.label = t[1]; t = op; break; }
                    if (t && _.label < t[2]) { _.label = t[2]; _.ops.push(op); break; }
                    if (t[2]) _.ops.pop();
                    _.trys.pop(); continue;
            }
            op = body.call(thisArg, _);
        } catch (e) { op = [6, e]; y = 0; } finally { f = t = 0; }
        if (op[0] & 5) throw op[1]; return { value: op[0] ? op[1] : void 0, done: true };
    }
};
import debug from 'debug';
import Gossipsub from 'libp2p-gossipsub';
import { createGossipRpc, messageIdToString, shuffle, } from 'libp2p-gossipsub/src/utils';
import { SignaturePolicy } from 'libp2p-interfaces/src/pubsub/signature-policy';
import PeerId from 'peer-id';
import { hexToBuf } from '../utils';
import { DefaultPubSubTopic } from '../waku';
import { WakuMessage } from '../waku_message';
import * as constants from './constants';
import { RelayCodecs } from './constants';
import { getRelayPeers } from './get_relay_peers';
import { RelayHeartbeat } from './relay_heartbeat';
var dbg = debug('waku:relay');
export { RelayCodecs };
/**
 * Implements the [Waku v2 Relay protocol]{@link https://rfc.vac.dev/spec/11/}.
 * Must be passed as a `pubsub` module to a {Libp2p} instance.
 *
 * @implements {require('libp2p-interfaces/src/pubsub')}
 * @noInheritDoc
 */
var WakuRelay = /** @class */ (function (_super) {
    __extends(WakuRelay, _super);
    function WakuRelay(libp2p, options) {
        var _this = _super.call(this, libp2p, Object.assign(options, {
            // Ensure that no signature is included nor expected in the messages.
            globalSignaturePolicy: SignaturePolicy.StrictNoSign,
        })) || this;
        _this.heartbeat = new RelayHeartbeat(_this);
        _this.observers = {};
        _this.decryptionKeys = new Set();
        var multicodecs = constants.RelayCodecs;
        Object.assign(_this, { multicodecs: multicodecs });
        _this.pubSubTopic = (options === null || options === void 0 ? void 0 : options.pubSubTopic) || DefaultPubSubTopic;
        return _this;
    }
    /**
     * Mounts the gossipsub protocol onto the libp2p node
     * and subscribes to the default topic.
     *
     * @override
     * @returns {void}
     */
    WakuRelay.prototype.start = function () {
        _super.prototype.start.call(this);
        this.subscribe(this.pubSubTopic);
    };
    /**
     * Send Waku message.
     *
     * @param {WakuMessage} message
     * @returns {Promise<void>}
     */
    WakuRelay.prototype.send = function (message) {
        return __awaiter(this, void 0, void 0, function () {
            var msg;
            return __generator(this, function (_a) {
                switch (_a.label) {
                    case 0:
                        msg = message.encode();
                        return [4 /*yield*/, _super.prototype.publish.call(this, this.pubSubTopic, Buffer.from(msg))];
                    case 1:
                        _a.sent();
                        return [2 /*return*/];
                }
            });
        });
    };
    /**
     * Register a decryption key to attempt decryption of received messages.
     * This can either be a private key for asymmetric encryption or a symmetric
     * key. `WakuRelay` will attempt to decrypt messages using both methods.
     *
     * Strings must be in hex format.
     */
    WakuRelay.prototype.addDecryptionKey = function (key) {
        this.decryptionKeys.add(hexToBuf(key));
    };
    /**
     * Delete a decryption key that was used to attempt decryption of received
     * messages.
     *
     * Strings must be in hex format.
     */
    WakuRelay.prototype.deleteDecryptionKey = function (key) {
        this.decryptionKeys.delete(hexToBuf(key));
    };
    /**
     * Register an observer of new messages received via waku relay
     *
     * @param callback called when a new message is received via waku relay
     * @param contentTopics Content Topics for which the callback with be called,
     * all of them if undefined, [] or ["",..] is passed.
     * @returns {void}
     */
    WakuRelay.prototype.addObserver = function (callback, contentTopics) {
        var _this = this;
        if (contentTopics === void 0) { contentTopics = []; }
        if (contentTopics.length === 0) {
            if (!this.observers['']) {
                this.observers[''] = new Set();
            }
            this.observers[''].add(callback);
        }
        else {
            contentTopics.forEach(function (contentTopic) {
                if (!_this.observers[contentTopic]) {
                    _this.observers[contentTopic] = new Set();
                }
                _this.observers[contentTopic].add(callback);
            });
        }
    };
    /**
     * Remove an observer of new messages received via waku relay.
     * Useful to ensure the same observer is not registered several time
     * (e.g when loading React components)
     */
    WakuRelay.prototype.deleteObserver = function (callback, contentTopics) {
        var _this = this;
        if (contentTopics === void 0) { contentTopics = []; }
        if (contentTopics.length === 0) {
            if (this.observers['']) {
                this.observers[''].delete(callback);
            }
        }
        else {
            contentTopics.forEach(function (contentTopic) {
                if (_this.observers[contentTopic]) {
                    _this.observers[contentTopic].delete(callback);
                }
            });
        }
    };
    /**
     * Return the relay peers we are connected to and we would publish a message to
     */
    WakuRelay.prototype.getPeers = function () {
        var _this = this;
        return getRelayPeers(this, this.pubSubTopic, this._options.D, function (id) {
            // Filter peers we would not publish to
            return (_this.score.score(id) >= _this._options.scoreThresholds.publishThreshold);
        });
    };
    /**
     * Subscribe to a pubsub topic and start emitting Waku messages to observers.
     *
     * @override
     */
    WakuRelay.prototype.subscribe = function (pubSubTopic) {
        var _this = this;
        this.on(pubSubTopic, function (event) {
            dbg("Message received on " + pubSubTopic);
            WakuMessage.decode(event.data, Array.from(_this.decryptionKeys))
                .then(function (wakuMsg) {
                if (!wakuMsg) {
                    dbg('Failed to decode Waku Message');
                    return;
                }
                if (_this.observers['']) {
                    _this.observers[''].forEach(function (callbackFn) {
                        callbackFn(wakuMsg);
                    });
                }
                if (wakuMsg.contentTopic) {
                    if (_this.observers[wakuMsg.contentTopic]) {
                        _this.observers[wakuMsg.contentTopic].forEach(function (callbackFn) {
                            callbackFn(wakuMsg);
                        });
                    }
                }
            })
                .catch(function (e) {
                dbg('Failed to decode Waku Message', e);
            });
        });
        _super.prototype.subscribe.call(this, pubSubTopic);
    };
    /**
     * Join pubsub topic.
     * This is present to override the behavior of Gossipsub and should not
     * be used by API Consumers
     *
     * @internal
     * @param {string} topic
     * @returns {void}
     * @override
     */
    WakuRelay.prototype.join = function (topic) {
        var _this = this;
        var _a;
        if (!this.started) {
            throw new Error('WakuRelayPubSub has not started');
        }
        var fanoutPeers = this.fanout.get(topic);
        if (fanoutPeers) {
            // these peers have a score above the publish threshold, which may be negative
            // so drop the ones with a negative score
            fanoutPeers.forEach(function (id) {
                if (_this.score.score(id) < 0) {
                    fanoutPeers.delete(id);
                }
            });
            if (fanoutPeers.size < this._options.D) {
                // we need more peers; eager, as this would get fixed in the next heartbeat
                getRelayPeers(this, topic, this._options.D - fanoutPeers.size, function (id) {
                    // filter our current peers, direct peers, and peers with negative scores
                    return (!fanoutPeers.has(id) &&
                        !_this.direct.has(id) &&
                        _this.score.score(id) >= 0);
                }).forEach(function (id) { return fanoutPeers.add(id); });
            }
            this.mesh.set(topic, fanoutPeers);
            this.fanout.delete(topic);
            this.lastpub.delete(topic);
        }
        else {
            var peers = getRelayPeers(this, topic, this._options.D, function (id) {
                // filter direct peers and peers with negative score
                return !_this.direct.has(id) && _this.score.score(id) >= 0;
            });
            this.mesh.set(topic, peers);
        }
        (_a = this.mesh.get(topic)) === null || _a === void 0 ? void 0 : _a.forEach(function (id) {
            _this.log('JOIN: Add mesh link to %s in %s', id, topic);
            _this._sendGraft(id, topic);
        });
    };
    /**
     * Publish messages.
     * This is present to override the behavior of Gossipsub and should not
     * be used by API Consumers
     *
     * @ignore
     * @override
     * @param {InMessage} msg
     * @returns {void}
     */
    WakuRelay.prototype._publish = function (msg) {
        return __awaiter(this, void 0, void 0, function () {
            var msgID, msgIdStr, toSend, rpc;
            var _this = this;
            return __generator(this, function (_a) {
                switch (_a.label) {
                    case 0:
                        if (msg.receivedFrom !== this.peerId.toB58String()) {
                            this.score.deliverMessage(msg);
                            this.gossipTracer.deliverMessage(msg);
                        }
                        return [4 /*yield*/, this.getMsgId(msg)];
                    case 1:
                        msgID = _a.sent();
                        msgIdStr = messageIdToString(msgID);
                        // put in seen cache
                        this.seenCache.put(msgIdStr);
                        this.messageCache.put(msg);
                        toSend = new Set();
                        msg.topicIDs.forEach(function (topic) {
                            var peersInTopic = _this.topics.get(topic);
                            if (!peersInTopic) {
                                return;
                            }
                            // direct peers
                            _this.direct.forEach(function (id) {
                                toSend.add(id);
                            });
                            var meshPeers = _this.mesh.get(topic);
                            if (!meshPeers || !meshPeers.size) {
                                // We are not in the mesh for topic, use fanout peers
                                meshPeers = _this.fanout.get(topic);
                                if (!meshPeers) {
                                    // If we are not in the fanout, then pick peers in topic above the publishThreshold
                                    var peers = getRelayPeers(_this, topic, _this._options.D, function (id) {
                                        return (_this.score.score(id) >=
                                            _this._options.scoreThresholds.publishThreshold);
                                    });
                                    if (peers.size > 0) {
                                        meshPeers = peers;
                                        _this.fanout.set(topic, peers);
                                    }
                                    else {
                                        meshPeers = new Set();
                                    }
                                }
                                // Store the latest publishing time
                                _this.lastpub.set(topic, _this._now());
                            }
                            meshPeers === null || meshPeers === void 0 ? void 0 : meshPeers.forEach(function (peer) {
                                toSend.add(peer);
                            });
                        });
                        rpc = createGossipRpc([Gossipsub.utils.normalizeOutRpcMessage(msg)]);
                        toSend.forEach(function (id) {
                            if (id === msg.from) {
                                return;
                            }
                            _this._sendRpc(id, rpc);
                        });
                        return [2 /*return*/];
                }
            });
        });
    };
    /**
     * Emits gossip to peers in a particular topic.
     *
     * This is present to override the behavior of Gossipsub and should not
     * be used by API Consumers
     *
     * @ignore
     * @override
     * @param {string} topic
     * @param {Set<string>} exclude peers to exclude
     * @returns {void}
     */
    WakuRelay.prototype._emitGossip = function (topic, exclude) {
        var _this = this;
        var messageIDs = this.messageCache.getGossipIDs(topic);
        if (!messageIDs.length) {
            return;
        }
        // shuffle to emit in random order
        shuffle(messageIDs);
        // if we are emitting more than GossipsubMaxIHaveLength ids, truncate the list
        if (messageIDs.length > constants.RelayMaxIHaveLength) {
            // we do the truncation (with shuffling) per peer below
            this.log('too many messages for gossip; will truncate IHAVE list (%d messages)', messageIDs.length);
        }
        // Send gossip to GossipFactor peers above threshold with a minimum of D_lazy
        // First we collect the peers above gossipThreshold that are not in the exclude set
        // and then randomly select from that set
        // We also exclude direct peers, as there is no reason to emit gossip to them
        var peersToGossip = [];
        var topicPeers = this.topics.get(topic);
        if (!topicPeers) {
            // no topic peers, no gossip
            return;
        }
        topicPeers.forEach(function (id) {
            var peerStreams = _this.peers.get(id);
            if (!peerStreams) {
                return;
            }
            if (!exclude.has(id) &&
                !_this.direct.has(id) &&
                constants.RelayCodecs.includes(peerStreams.protocol) &&
                _this.score.score(id) >= _this._options.scoreThresholds.gossipThreshold) {
                peersToGossip.push(id);
            }
        });
        var target = this._options.Dlazy;
        var factor = constants.RelayGossipFactor * peersToGossip.length;
        if (factor > target) {
            target = factor;
        }
        if (target > peersToGossip.length) {
            target = peersToGossip.length;
        }
        else {
            shuffle(peersToGossip);
        }
        // Emit the IHAVE gossip to the selected peers up to the target
        peersToGossip.slice(0, target).forEach(function (id) {
            var peerMessageIDs = messageIDs;
            if (messageIDs.length > constants.RelayMaxIHaveLength) {
                // shuffle and slice message IDs per peer so that we emit a different set for each peer
                // we have enough redundancy in the system that this will significantly increase the message
                // coverage when we do truncate
                peerMessageIDs = shuffle(peerMessageIDs.slice()).slice(0, constants.RelayMaxIHaveLength);
            }
            _this._pushGossip(id, {
                topicID: topic,
                messageIDs: peerMessageIDs,
            });
        });
    };
    /**
     * Make a PRUNE control message for a peer in a topic.
     * This is present to override the behavior of Gossipsub and should not
     * be used by API Consumers
     *
     * @ignore
     * @override
     * @param {string} id
     * @param {string} topic
     * @param {boolean} doPX
     * @returns {RPC.IControlPrune}
     */
    WakuRelay.prototype._makePrune = function (id, topic, doPX) {
        var _this = this;
        // backoff is measured in seconds
        // RelayPruneBackoff is measured in milliseconds
        var backoff = constants.RelayPruneBackoff / 1000;
        var px = [];
        if (doPX) {
            // select peers for Peer eXchange
            var peers = getRelayPeers(this, topic, constants.RelayPrunePeers, function (xid) {
                return xid !== id && _this.score.score(xid) >= 0;
            });
            peers.forEach(function (p) {
                // see if we have a signed record to send back; if we don't, just send
                // the peer ID and let the pruned peer find them in the DHT -- we can't trust
                // unsigned address records through PX anyways
                // Finding signed records in the DHT is not supported at the time of writing in js-libp2p
                var peerId = PeerId.createFromB58String(p);
                px.push({
                    peerID: peerId.toBytes(),
                    signedPeerRecord: _this._libp2p.peerStore.addressBook.getRawEnvelope(peerId),
                });
            });
        }
        return {
            topicID: topic,
            peers: px,
            backoff: backoff,
        };
    };
    return WakuRelay;
}(Gossipsub));
export { WakuRelay };
//# sourceMappingURL=index.js.map