/**
 * @hidden
 * @module
 */
var __extends = (this && this.__extends) || (function () {
    var extendStatics = function (d, b) {
        extendStatics = Object.setPrototypeOf ||
            ({ __proto__: [] } instanceof Array && function (d, b) { d.__proto__ = b; }) ||
            function (d, b) { for (var p in b) if (Object.prototype.hasOwnProperty.call(b, p)) d[p] = b[p]; };
        return extendStatics(d, b);
    };
    return function (d, b) {
        if (typeof b !== "function" && b !== null)
            throw new TypeError("Class extends value " + String(b) + " is not a constructor or null");
        extendStatics(d, b);
        function __() { this.constructor = d; }
        d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
    };
})();
import { Heartbeat } from 'libp2p-gossipsub/src/heartbeat';
import { shuffle } from 'libp2p-gossipsub/src/utils';
import * as constants from './constants';
import { getRelayPeers } from './get_relay_peers';
var RelayHeartbeat = /** @class */ (function (_super) {
    __extends(RelayHeartbeat, _super);
    /**
     * @param {Object} gossipsub
     * @constructor
     */
    function RelayHeartbeat(gossipsub) {
        return _super.call(this, gossipsub) || this;
    }
    RelayHeartbeat.prototype.start = function () {
        var _this = this;
        if (this._heartbeatTimer) {
            return;
        }
        var heartbeat = this._heartbeat.bind(this);
        var timeout = setTimeout(function () {
            var _a;
            heartbeat();
            (_a = _this._heartbeatTimer) === null || _a === void 0 ? void 0 : _a.runPeriodically(heartbeat, constants.RelayHeartbeatInterval);
        }, constants.RelayHeartbeatInitialDelay);
        this._heartbeatTimer = {
            _intervalId: undefined,
            runPeriodically: function (fn, period) {
                // this._heartbeatTimer cannot be null, it is being assigned.
                // eslint-disable-next-line @typescript-eslint/no-non-null-assertion
                _this._heartbeatTimer._intervalId = setInterval(fn, period);
            },
            cancel: function () {
                var _a;
                clearTimeout(timeout);
                clearInterval((_a = _this._heartbeatTimer) === null || _a === void 0 ? void 0 : _a._intervalId);
            },
        };
    };
    /**
     * Unmounts the gossipsub protocol and shuts down every connection
     * @override
     * @returns {void}
     */
    RelayHeartbeat.prototype.stop = function () {
        if (!this._heartbeatTimer) {
            return;
        }
        this._heartbeatTimer.cancel();
        this._heartbeatTimer = null;
    };
    /**
     * Maintains the mesh and fanout maps in gossipsub.
     *
     * @returns {void}
     */
    RelayHeartbeat.prototype._heartbeat = function () {
        var _this = this;
        var _a = this.gossipsub._options, D = _a.D, Dlo = _a.Dlo, Dhi = _a.Dhi, Dscore = _a.Dscore, Dout = _a.Dout;
        this.gossipsub.heartbeatTicks++;
        // cache scores through the heartbeat
        var scores = new Map();
        var getScore = function (id) {
            var s = scores.get(id);
            if (s === undefined) {
                s = _this.gossipsub.score.score(id);
                scores.set(id, s);
            }
            return s;
        };
        // peer id => topic[]
        var toGraft = new Map();
        // peer id => topic[]
        var toPrune = new Map();
        // peer id => don't px
        var noPX = new Map();
        // clean up expired backoffs
        this.gossipsub._clearBackoff();
        // clean up peerhave/iasked counters
        this.gossipsub.peerhave.clear();
        this.gossipsub.iasked.clear();
        // apply IWANT request penalties
        this.gossipsub._applyIwantPenalties();
        // ensure direct peers are connected
        this.gossipsub._directConnect();
        // maintain the mesh for topics we have joined
        this.gossipsub.mesh.forEach(function (peers, topic) {
            // prune/graft helper functions (defined per topic)
            var prunePeer = function (id) {
                _this.gossipsub.log('HEARTBEAT: Remove mesh link to %s in %s', id, topic);
                // update peer score
                _this.gossipsub.score.prune(id, topic);
                // add prune backoff record
                _this.gossipsub._addBackoff(id, topic);
                // remove peer from mesh
                peers.delete(id);
                // add to toPrune
                var topics = toPrune.get(id);
                if (!topics) {
                    toPrune.set(id, [topic]);
                }
                else {
                    topics.push(topic);
                }
            };
            var graftPeer = function (id) {
                _this.gossipsub.log('HEARTBEAT: Add mesh link to %s in %s', id, topic);
                // update peer score
                _this.gossipsub.score.graft(id, topic);
                // add peer to mesh
                peers.add(id);
                // add to toGraft
                var topics = toGraft.get(id);
                if (!topics) {
                    toGraft.set(id, [topic]);
                }
                else {
                    topics.push(topic);
                }
            };
            // drop all peers with negative score, without PX
            peers.forEach(function (id) {
                var score = getScore(id);
                if (score < 0) {
                    _this.gossipsub.log('HEARTBEAT: Prune peer %s with negative score: score=%d, topic=%s', id, score, topic);
                    prunePeer(id);
                    noPX.set(id, true);
                }
            });
            // do we have enough peers?
            if (peers.size < Dlo) {
                var backoff_1 = _this.gossipsub.backoff.get(topic);
                var ineed = D - peers.size;
                var peersSet = getRelayPeers(_this.gossipsub, topic, ineed, function (id) {
                    // filter out mesh peers, direct peers, peers we are backing off, peers with negative score
                    return (!peers.has(id) &&
                        !_this.gossipsub.direct.has(id) &&
                        (!backoff_1 || !backoff_1.has(id)) &&
                        getScore(id) >= 0);
                });
                peersSet.forEach(graftPeer);
            }
            // do we have to many peers?
            if (peers.size > Dhi) {
                var peersArray_1 = Array.from(peers);
                // sort by score
                peersArray_1.sort(function (a, b) { return getScore(b) - getScore(a); });
                // We keep the first D_score peers by score and the remaining up to D randomly
                // under the constraint that we keep D_out peers in the mesh (if we have that many)
                peersArray_1 = peersArray_1
                    .slice(0, Dscore)
                    .concat(shuffle(peersArray_1.slice(Dscore)));
                // count the outbound peers we are keeping
                var outbound_1 = 0;
                peersArray_1.slice(0, D).forEach(function (p) {
                    if (_this.gossipsub.outbound.get(p)) {
                        outbound_1++;
                    }
                });
                // if it's less than D_out, bubble up some outbound peers from the random selection
                if (outbound_1 < Dout) {
                    var rotate = function (i) {
                        // rotate the peersArray to the right and put the ith peer in the front
                        var p = peersArray_1[i];
                        for (var j = i; j > 0; j--) {
                            peersArray_1[j] = peersArray_1[j - 1];
                        }
                        peersArray_1[0] = p;
                    };
                    // first bubble up all outbound peers already in the selection to the front
                    if (outbound_1 > 0) {
                        var ihave = outbound_1;
                        for (var i = 1; i < D && ihave > 0; i++) {
                            if (_this.gossipsub.outbound.get(peersArray_1[i])) {
                                rotate(i);
                                ihave--;
                            }
                        }
                    }
                    // now bubble up enough outbound peers outside the selection to the front
                    var ineed = D - outbound_1;
                    for (var i = D; i < peersArray_1.length && ineed > 0; i++) {
                        if (_this.gossipsub.outbound.get(peersArray_1[i])) {
                            rotate(i);
                            ineed--;
                        }
                    }
                }
                // prune the excess peers
                peersArray_1.slice(D).forEach(prunePeer);
            }
            // do we have enough outbound peers?
            if (peers.size >= Dlo) {
                // count the outbound peers we have
                var outbound_2 = 0;
                peers.forEach(function (p) {
                    if (_this.gossipsub.outbound.get(p)) {
                        outbound_2++;
                    }
                });
                // if it's less than D_out, select some peers with outbound connections and graft them
                if (outbound_2 < Dout) {
                    var ineed = Dout - outbound_2;
                    var backoff_2 = _this.gossipsub.backoff.get(topic);
                    getRelayPeers(_this.gossipsub, topic, ineed, function (id) {
                        // filter our current mesh peers, direct peers, peers we are backing off, peers with negative score
                        return (!peers.has(id) &&
                            !_this.gossipsub.direct.has(id) &&
                            (!backoff_2 || !backoff_2.has(id)) &&
                            getScore(id) >= 0);
                    }).forEach(graftPeer);
                }
            }
            // should we try to improve the mesh with opportunistic grafting?
            if (_this.gossipsub.heartbeatTicks %
                constants.RelayOpportunisticGraftTicks ===
                0 &&
                peers.size > 1) {
                // Opportunistic grafting works as follows: we check the median score of peers in the
                // mesh; if this score is below the opportunisticGraftThreshold, we select a few peers at
                // random with score over the median.
                // The intention is to (slowly) improve an under performing mesh by introducing good
                // scoring peers that may have been gossiping at us. This allows us to get out of sticky
                // situations where we are stuck with poor peers and also recover from churn of good peers.
                // now compute the median peer score in the mesh
                var peersList = Array.from(peers).sort(function (a, b) { return getScore(a) - getScore(b); });
                var medianIndex = Math.floor(peers.size / 2);
                var medianScore_1 = getScore(peersList[medianIndex]);
                // if the median score is below the threshold, select a better peer (if any) and GRAFT
                if (medianScore_1 <
                    _this.gossipsub._options.scoreThresholds.opportunisticGraftThreshold) {
                    var backoff_3 = _this.gossipsub.backoff.get(topic);
                    var peersToGraft = getRelayPeers(_this.gossipsub, topic, constants.RelayOpportunisticGraftPeers, function (id) {
                        // filter out current mesh peers, direct peers, peers we are backing off, peers below or at threshold
                        return (peers.has(id) &&
                            !_this.gossipsub.direct.has(id) &&
                            (!backoff_3 || !backoff_3.has(id)) &&
                            getScore(id) > medianScore_1);
                    });
                    peersToGraft.forEach(function (id) {
                        _this.gossipsub.log('HEARTBEAT: Opportunistically graft peer %s on topic %s', id, topic);
                        graftPeer(id);
                    });
                }
            }
            // 2nd arg are mesh peers excluded from gossip. We have already pushed
            // messages to them, so its redundant to gossip IHAVEs.
            _this.gossipsub._emitGossip(topic, peers);
        });
        // expire fanout for topics we haven't published to in a while
        var now = this.gossipsub._now();
        this.gossipsub.lastpub.forEach(function (lastpub, topic) {
            if (lastpub + constants.RelayFanoutTTL < now) {
                _this.gossipsub.fanout.delete(topic);
                _this.gossipsub.lastpub.delete(topic);
            }
        });
        // maintain our fanout for topics we are publishing but we have not joined
        this.gossipsub.fanout.forEach(function (fanoutPeers, topic) {
            // checks whether our peers are still in the topic and have a score above the publish threshold
            var topicPeers = _this.gossipsub.topics.get(topic);
            fanoutPeers.forEach(function (id) {
                if (!(topicPeers === null || topicPeers === void 0 ? void 0 : topicPeers.has(id)) ||
                    getScore(id) <
                        _this.gossipsub._options.scoreThresholds.publishThreshold) {
                    fanoutPeers.delete(id);
                }
            });
            // do we need more peers?
            if (fanoutPeers.size < D) {
                var ineed = D - fanoutPeers.size;
                var peersSet = getRelayPeers(_this.gossipsub, topic, ineed, function (id) {
                    // filter out existing fanout peers, direct peers, and peers with score above the publish threshold
                    return (!fanoutPeers.has(id) &&
                        !_this.gossipsub.direct.has(id) &&
                        getScore(id) >=
                            _this.gossipsub._options.scoreThresholds.publishThreshold);
                });
                peersSet.forEach(function (id) {
                    fanoutPeers.add(id);
                });
            }
            // 2nd arg are fanout peers excluded from gossip.
            // We have already pushed messages to them, so its redundant to gossip IHAVEs
            _this.gossipsub._emitGossip(topic, fanoutPeers);
        });
        // send coalesced GRAFT/PRUNE messages (will piggyback gossip)
        this.gossipsub._sendGraftPrune(toGraft, toPrune, noPX);
        // flush pending gossip that wasn't piggybacked above
        this.gossipsub._flush();
        // advance the message history window
        this.gossipsub.messageCache.shift();
        this.gossipsub.emit('gossipsub:heartbeat');
    };
    return RelayHeartbeat;
}(Heartbeat));
export { RelayHeartbeat };
//# sourceMappingURL=relay_heartbeat.js.map