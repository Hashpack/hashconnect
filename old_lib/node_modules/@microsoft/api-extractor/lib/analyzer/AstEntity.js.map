{"version":3,"file":"AstEntity.js","sourceRoot":"","sources":["../../src/analyzer/AstEntity.ts"],"names":[],"mappings":";AAAA,4FAA4F;AAC5F,2DAA2D;;;AAE3D;;;;;;;;;;;;;GAaG;AACH,MAAsB,SAAS;CAY9B;AAZD,8BAYC;AAED;;;;;;;;;;;;;GAaG;AACH,MAAsB,kBAAmB,SAAQ,SAAS;CAAG;AAA7D,gDAA6D","sourcesContent":["// Copyright (c) Microsoft Corporation. All rights reserved. Licensed under the MIT license.\r\n// See LICENSE in the project root for license information.\r\n\r\n/**\r\n * `AstEntity` is the abstract base class for analyzer objects that can become a `CollectorEntity`.\r\n *\r\n * @remarks\r\n *\r\n * The subclasses are:\r\n * ```\r\n * - AstEntity\r\n *   - AstSymbol\r\n *   - AstSyntheticEntity\r\n *     - AstImport\r\n *     - AstNamespaceImport\r\n * ```\r\n */\r\nexport abstract class AstEntity {\r\n  /**\r\n   * The original name of the symbol, as exported from the module (i.e. source file)\r\n   * containing the original TypeScript definition.  Constructs such as\r\n   * `import { X as Y } from` may introduce other names that differ from the local name.\r\n   *\r\n   * @remarks\r\n   * For the most part, `localName` corresponds to `followedSymbol.name`, but there\r\n   * are some edge cases.  For example, the ts.Symbol.name for `export default class X { }`\r\n   * is actually `\"default\"`, not `\"X\"`.\r\n   */\r\n  public abstract readonly localName: string;\r\n}\r\n\r\n/**\r\n * `AstSyntheticEntity` is the abstract base class for analyzer objects whose emitted declarations\r\n * are not text transformations performed by the `Span` helper.\r\n *\r\n * @remarks\r\n * Most of API Extractor's output is produced by using the using the `Span` utility to regurgitate strings from\r\n * the input .d.ts files.  If we need to rename an identifier, the `Span` visitor can pick out an interesting\r\n * node and rewrite its string, but otherwise the transformation operates on dumb text and not compiler concepts.\r\n * (Historically we did this because the compiler's emitter was an internal API, but it still has some advantages,\r\n * for example preserving syntaxes generated by an older compiler to avoid incompatibilities.)\r\n *\r\n * This strategy does not work for cases where the output looks very different from the input.  Today these\r\n * cases are always kinds of `import` statements, but that may change in the future.\r\n */\r\nexport abstract class AstSyntheticEntity extends AstEntity {}\r\n"]}