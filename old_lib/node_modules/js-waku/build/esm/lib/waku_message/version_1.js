var __awaiter = (this && this.__awaiter) || function (thisArg, _arguments, P, generator) {
    function adopt(value) { return value instanceof P ? value : new P(function (resolve) { resolve(value); }); }
    return new (P || (P = Promise))(function (resolve, reject) {
        function fulfilled(value) { try { step(generator.next(value)); } catch (e) { reject(e); } }
        function rejected(value) { try { step(generator["throw"](value)); } catch (e) { reject(e); } }
        function step(result) { result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected); }
        step((generator = generator.apply(thisArg, _arguments || [])).next());
    });
};
var __generator = (this && this.__generator) || function (thisArg, body) {
    var _ = { label: 0, sent: function() { if (t[0] & 1) throw t[1]; return t[1]; }, trys: [], ops: [] }, f, y, t, g;
    return g = { next: verb(0), "throw": verb(1), "return": verb(2) }, typeof Symbol === "function" && (g[Symbol.iterator] = function() { return this; }), g;
    function verb(n) { return function (v) { return step([n, v]); }; }
    function step(op) {
        if (f) throw new TypeError("Generator is already executing.");
        while (_) try {
            if (f = 1, y && (t = op[0] & 2 ? y["return"] : op[0] ? y["throw"] || ((t = y["return"]) && t.call(y), 0) : y.next) && !(t = t.call(y, op[1])).done) return t;
            if (y = 0, t) op = [op[0] & 2, t.value];
            switch (op[0]) {
                case 0: case 1: t = op; break;
                case 4: _.label++; return { value: op[1], done: false };
                case 5: _.label++; y = op[1]; op = [0]; continue;
                case 7: op = _.ops.pop(); _.trys.pop(); continue;
                default:
                    if (!(t = _.trys, t = t.length > 0 && t[t.length - 1]) && (op[0] === 6 || op[0] === 2)) { _ = 0; continue; }
                    if (op[0] === 3 && (!t || (op[1] > t[0] && op[1] < t[3]))) { _.label = op[1]; break; }
                    if (op[0] === 6 && _.label < t[1]) { _.label = t[1]; t = op; break; }
                    if (t && _.label < t[2]) { _.label = t[2]; _.ops.push(op); break; }
                    if (t[2]) _.ops.pop();
                    _.trys.pop(); continue;
            }
            op = body.call(thisArg, _);
        } catch (e) { op = [6, e]; y = 0; } finally { f = t = 0; }
        if (op[0] & 5) throw op[1]; return { value: op[0] ? op[1] : void 0, done: true };
    }
};
import { Buffer } from 'buffer';
import * as crypto from 'crypto';
import * as ecies from 'ecies-geth';
import { keccak256 } from 'js-sha3';
import * as secp256k1 from 'secp256k1';
import { hexToBuf } from '../utils';
import { IvSize, symmetric, SymmetricKeySize } from './symmetric';
var FlagsLength = 1;
var FlagMask = 3; // 0011
var IsSignedMask = 4; // 0100
var PaddingTarget = 256;
var SignatureLength = 65;
export var PrivateKeySize = 32;
/**
 * Encode the payload pre-encryption.
 *
 * @internal
 * @param messagePayload: The payload to include in the message
 * @param sigPrivKey: If set, a signature using this private key is added.
 * @returns The encoded payload, ready for encryption using {@link encryptAsymmetric}
 * or {@link encryptSymmetric}.
 */
export function clearEncode(messagePayload, sigPrivKey) {
    var envelope = Buffer.from([0]); // No flags
    envelope = addPayloadSizeField(envelope, messagePayload);
    envelope = Buffer.concat([envelope, Buffer.from(messagePayload)]);
    // Calculate padding:
    var rawSize = FlagsLength +
        getSizeOfPayloadSizeField(messagePayload) +
        messagePayload.length;
    if (sigPrivKey) {
        rawSize += SignatureLength;
    }
    var remainder = rawSize % PaddingTarget;
    var paddingSize = PaddingTarget - remainder;
    var pad = Buffer.from(randomBytes(paddingSize));
    if (!validateDataIntegrity(pad, paddingSize)) {
        throw new Error('failed to generate random padding of size ' + paddingSize);
    }
    envelope = Buffer.concat([envelope, pad]);
    var sig;
    if (sigPrivKey) {
        envelope[0] |= IsSignedMask;
        var hash = keccak256(envelope);
        var s = secp256k1.ecdsaSign(hexToBuf(hash), sigPrivKey);
        envelope = Buffer.concat([envelope, s.signature, Buffer.from([s.recid])]);
        sig = {
            signature: Buffer.from(s.signature),
            publicKey: getPublicKey(sigPrivKey),
        };
    }
    return { payload: envelope, sig: sig };
}
/**
 * Decode a decrypted payload.
 *
 * @internal
 */
export function clearDecode(message) {
    var buf = Buffer.from(message);
    var start = 1;
    var sig;
    var sizeOfPayloadSizeField = buf.readUIntLE(0, 1) & FlagMask;
    if (sizeOfPayloadSizeField === 0)
        return;
    var payloadSize = buf.readUIntLE(start, sizeOfPayloadSizeField);
    start += sizeOfPayloadSizeField;
    var payload = buf.slice(start, start + payloadSize);
    var isSigned = (buf.readUIntLE(0, 1) & IsSignedMask) == IsSignedMask;
    if (isSigned) {
        var signature = getSignature(buf);
        var hash = getHash(buf, isSigned);
        var publicKey = ecRecoverPubKey(hash, signature);
        sig = { signature: signature, publicKey: publicKey };
    }
    return { payload: payload, sig: sig };
}
/**
 * Proceed with Asymmetric encryption of the data as per [26/WAKU-PAYLOAD](https://rfc.vac.dev/spec/26/).
 * The data MUST be flags | payload-length | payload | [signature].
 * The returned result can be set to `WakuMessage.payload`.
 *
 * @internal
 */
export function encryptAsymmetric(data, publicKey) {
    return __awaiter(this, void 0, void 0, function () {
        return __generator(this, function (_a) {
            return [2 /*return*/, ecies.encrypt(hexToBuf(publicKey), Buffer.from(data))];
        });
    });
}
/**
 * Proceed with Asymmetric decryption of the data as per [26/WAKU-PAYLOAD](https://rfc.vac.dev/spec/26/).
 * The return data is expect to be flags | payload-length | payload | [signature].
 *
 * @internal
 */
export function decryptAsymmetric(payload, privKey) {
    return __awaiter(this, void 0, void 0, function () {
        return __generator(this, function (_a) {
            return [2 /*return*/, ecies.decrypt(Buffer.from(privKey), Buffer.from(payload))];
        });
    });
}
/**
 * Proceed with Symmetric encryption of the data as per [26/WAKU-PAYLOAD](https://rfc.vac.dev/spec/26/).
 *
 * @param data The data to encrypt, expected to be `flags | payload-length | payload | [signature]`.
 * @param key The key to use for encryption.
 * @returns The decrypted data, `cipherText | tag | iv` and can be set to `WakuMessage.payload`.
 *
 * @internal
 */
export function encryptSymmetric(data, key) {
    return __awaiter(this, void 0, void 0, function () {
        var iv, cipher;
        return __generator(this, function (_a) {
            switch (_a.label) {
                case 0:
                    iv = symmetric.generateIv();
                    return [4 /*yield*/, symmetric.encrypt(iv, hexToBuf(key), Buffer.from(data))];
                case 1:
                    cipher = _a.sent();
                    return [2 /*return*/, Buffer.concat([cipher, Buffer.from(iv)])];
            }
        });
    });
}
/**
 * Proceed with Symmetric decryption of the data as per [26/WAKU-PAYLOAD](https://rfc.vac.dev/spec/26/).
 *
 * @param payload The cipher data, it is expected to be `cipherText | tag | iv`.
 * @param key The key to use for decryption.
 * @returns The decrypted data, expected to be `flags | payload-length | payload | [signature]`.
 *
 * @internal
 */
export function decryptSymmetric(payload, key) {
    return __awaiter(this, void 0, void 0, function () {
        var data, ivStart, cipher, iv;
        return __generator(this, function (_a) {
            data = Buffer.from(payload);
            ivStart = data.length - IvSize;
            cipher = data.slice(0, ivStart);
            iv = data.slice(ivStart);
            return [2 /*return*/, symmetric.decrypt(iv, hexToBuf(key), cipher)];
        });
    });
}
/**
 * Generate a new private key to be used for asymmetric encryption.
 *
 * Use {@link getPublicKey} to get the corresponding Public Key.
 */
export function generatePrivateKey() {
    return randomBytes(PrivateKeySize);
}
/**
 * Generate a new symmetric key to be used for symmetric encryption.
 */
export function generateSymmetricKey() {
    return randomBytes(SymmetricKeySize);
}
/**
 * Return the public key for the given private key, to be used for asymmetric
 * encryption.
 */
export function getPublicKey(privateKey) {
    return secp256k1.publicKeyCreate(privateKey, false);
}
/**
 * Computes the flags & auxiliary-field as per [26/WAKU-PAYLOAD](https://rfc.vac.dev/spec/26/).
 */
function addPayloadSizeField(msg, payload) {
    var fieldSize = getSizeOfPayloadSizeField(payload);
    var field = Buffer.alloc(4);
    field.writeUInt32LE(payload.length, 0);
    field = field.slice(0, fieldSize);
    msg = Buffer.concat([msg, field]);
    msg[0] |= fieldSize;
    return msg;
}
/**
 * Returns the size of the auxiliary-field which in turns contains the payload size
 */
function getSizeOfPayloadSizeField(payload) {
    var s = 1;
    for (var i = payload.length; i >= 256; i /= 256) {
        s++;
    }
    return s;
}
function validateDataIntegrity(value, expectedSize) {
    if (value.length !== expectedSize) {
        return false;
    }
    return !(expectedSize > 3 && Buffer.from(value).equals(Buffer.alloc(value.length)));
}
function getSignature(message) {
    return message.slice(message.length - SignatureLength, message.length);
}
function getHash(message, isSigned) {
    if (isSigned) {
        return keccak256(message.slice(0, message.length - SignatureLength));
    }
    return keccak256(message);
}
function ecRecoverPubKey(messageHash, signature) {
    var recovery = signature.slice(64).readIntBE(0, 1);
    return secp256k1.ecdsaRecover(signature.slice(0, 64), recovery, hexToBuf(messageHash), false);
}
function randomBytes(length) {
    if (typeof window !== 'undefined' && window && window.crypto) {
        var array = new Uint8Array(length);
        window.crypto.getRandomValues(array);
        return array;
    }
    else {
        return crypto.randomBytes(length);
    }
}
//# sourceMappingURL=version_1.js.map